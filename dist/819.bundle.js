/*! For license information please see 819.bundle.js.LICENSE.txt */
(self.webpackChunkdrp_mouse=self.webpackChunkdrp_mouse||[]).push([[819],{9159:(e,t,r)=>{e.exports={RBTree:r(6951),BinTree:r(4158)}},4158:(e,t,r)=>{var n=r(8930);function s(e){this.data=e,this.left=null,this.right=null}function i(e){this._root=null,this._comparator=e,this.size=0}s.prototype.get_child=function(e){return e?this.right:this.left},s.prototype.set_child=function(e,t){e?this.right=t:this.left=t},i.prototype=new n,i.prototype.insert=function(e){if(null===this._root)return this._root=new s(e),this.size++,!0;for(var t=0,r=null,n=this._root;;){if(null===n)return n=new s(e),r.set_child(t,n),ret=!0,this.size++,!0;if(0===this._comparator(n.data,e))return!1;t=this._comparator(n.data,e)<0,r=n,n=n.get_child(t)}},i.prototype.remove=function(e){if(null===this._root)return!1;var t=new s(void 0),r=t;r.right=this._root;for(var n=null,i=null,o=1;null!==r.get_child(o);){n=r,r=r.get_child(o);var a=this._comparator(e,r.data);o=a>0,0===a&&(i=r)}return null!==i&&(i.data=r.data,n.set_child(n.right===r,r.get_child(null===r.left)),this._root=t.right,this.size--,!0)},e.exports=i},6951:(e,t,r)=>{var n=r(8930);function s(e){this.data=e,this.left=null,this.right=null,this.red=!0}function i(e){this._root=null,this._comparator=e,this.size=0}function o(e){return null!==e&&e.red}function a(e,t){var r=e.get_child(!t);return e.set_child(!t,r.get_child(t)),r.set_child(t,e),e.red=!0,r.red=!1,r}function c(e,t){return e.set_child(!t,a(e.get_child(!t),!t)),a(e,t)}s.prototype.get_child=function(e){return e?this.right:this.left},s.prototype.set_child=function(e,t){e?this.right=t:this.left=t},i.prototype=new n,i.prototype.insert=function(e){var t=!1;if(null===this._root)this._root=new s(e),t=!0,this.size++;else{var r=new s(void 0),n=0,i=0,l=null,u=r,h=null,d=this._root;for(u.right=this._root;;){if(null===d?(d=new s(e),h.set_child(n,d),t=!0,this.size++):o(d.left)&&o(d.right)&&(d.red=!0,d.left.red=!1,d.right.red=!1),o(d)&&o(h)){var p=u.right===l;d===h.get_child(i)?u.set_child(p,a(l,!i)):u.set_child(p,c(l,!i))}var f=this._comparator(d.data,e);if(0===f)break;i=n,n=f<0,null!==l&&(u=l),l=h,h=d,d=d.get_child(n)}this._root=r.right}return this._root.red=!1,t},i.prototype.remove=function(e){if(null===this._root)return!1;var t=new s(void 0),r=t;r.right=this._root;for(var n=null,i=null,l=null,u=1;null!==r.get_child(u);){var h=u;i=n,n=r,r=r.get_child(u);var d=this._comparator(e,r.data);if(u=d>0,0===d&&(l=r),!o(r)&&!o(r.get_child(u)))if(o(r.get_child(!u))){var p=a(r,u);n.set_child(h,p),n=p}else if(!o(r.get_child(!u))){var f=n.get_child(!h);if(null!==f)if(o(f.get_child(!h))||o(f.get_child(h))){var g=i.right===n;o(f.get_child(h))?i.set_child(g,c(n,h)):o(f.get_child(!h))&&i.set_child(g,a(n,h));var m=i.get_child(g);m.red=!0,r.red=!0,m.left.red=!1,m.right.red=!1}else n.red=!1,f.red=!0,r.red=!0}}return null!==l&&(l.data=r.data,n.set_child(n.right===r,r.get_child(null===r.left)),this.size--),this._root=t.right,null!==this._root&&(this._root.red=!1),null!==l},e.exports=i},8930:e=>{function t(){}function r(e){this._tree=e,this._ancestors=[],this._cursor=null}t.prototype.clear=function(){this._root=null,this.size=0},t.prototype.find=function(e){for(var t=this._root;null!==t;){var r=this._comparator(e,t.data);if(0===r)return t.data;t=t.get_child(r>0)}return null},t.prototype.findIter=function(e){for(var t=this._root,r=this.iterator();null!==t;){var n=this._comparator(e,t.data);if(0===n)return r._cursor=t,r;r._ancestors.push(t),t=t.get_child(n>0)}return null},t.prototype.lowerBound=function(e){for(var t=this._root,r=this.iterator(),n=this._comparator;null!==t;){var s=n(e,t.data);if(0===s)return r._cursor=t,r;r._ancestors.push(t),t=t.get_child(s>0)}for(var i=r._ancestors.length-1;i>=0;--i)if(n(e,(t=r._ancestors[i]).data)<0)return r._cursor=t,r._ancestors.length=i,r;return r._ancestors.length=0,r},t.prototype.upperBound=function(e){for(var t=this.lowerBound(e),r=this._comparator;null!==t.data()&&0===r(t.data(),e);)t.next();return t},t.prototype.min=function(){var e=this._root;if(null===e)return null;for(;null!==e.left;)e=e.left;return e.data},t.prototype.max=function(){var e=this._root;if(null===e)return null;for(;null!==e.right;)e=e.right;return e.data},t.prototype.iterator=function(){return new r(this)},t.prototype.each=function(e){for(var t,r=this.iterator();null!==(t=r.next());)if(!1===e(t))return},t.prototype.reach=function(e){for(var t,r=this.iterator();null!==(t=r.prev());)if(!1===e(t))return},r.prototype.data=function(){return null!==this._cursor?this._cursor.data:null},r.prototype.next=function(){if(null===this._cursor){var e=this._tree._root;null!==e&&this._minNode(e)}else{var t;if(null===this._cursor.right)do{if(t=this._cursor,!this._ancestors.length){this._cursor=null;break}this._cursor=this._ancestors.pop()}while(this._cursor.right===t);else this._ancestors.push(this._cursor),this._minNode(this._cursor.right)}return null!==this._cursor?this._cursor.data:null},r.prototype.prev=function(){if(null===this._cursor){var e=this._tree._root;null!==e&&this._maxNode(e)}else{var t;if(null===this._cursor.left)do{if(t=this._cursor,!this._ancestors.length){this._cursor=null;break}this._cursor=this._ancestors.pop()}while(this._cursor.left===t);else this._ancestors.push(this._cursor),this._maxNode(this._cursor.left)}return null!==this._cursor?this._cursor.data:null},r.prototype._minNode=function(e){for(;null!==e.left;)this._ancestors.push(e),e=e.left;this._cursor=e},r.prototype._maxNode=function(e){for(;null!==e.right;)this._ancestors.push(e),e=e.right;this._cursor=e},e.exports=t},2153:e=>{"use strict";function t(e,t){t=t||{},this._capacity=t.capacity,this._head=0,this._tail=0,Array.isArray(e)?this._fromArray(e):(this._capacityMask=3,this._list=new Array(4))}t.prototype.peekAt=function(e){var t=e;if(t===(0|t)){var r=this.size();if(!(t>=r||t<-r))return t<0&&(t+=r),t=this._head+t&this._capacityMask,this._list[t]}},t.prototype.get=function(e){return this.peekAt(e)},t.prototype.peek=function(){if(this._head!==this._tail)return this._list[this._head]},t.prototype.peekFront=function(){return this.peek()},t.prototype.peekBack=function(){return this.peekAt(-1)},Object.defineProperty(t.prototype,"length",{get:function(){return this.size()}}),t.prototype.size=function(){return this._head===this._tail?0:this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.unshift=function(e){if(0===arguments.length)return this.size();var t=this._list.length;return this._head=this._head-1+t&this._capacityMask,this._list[this._head]=e,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.pop(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.shift=function(){var e=this._head;if(e!==this._tail){var t=this._list[e];return this._list[e]=void 0,this._head=e+1&this._capacityMask,e<2&&this._tail>1e4&&this._tail<=this._list.length>>>2&&this._shrinkArray(),t}},t.prototype.push=function(e){if(0===arguments.length)return this.size();var t=this._tail;return this._list[t]=e,this._tail=t+1&this._capacityMask,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.shift(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.pop=function(){var e=this._tail;if(e!==this._head){var t=this._list.length;this._tail=e-1+t&this._capacityMask;var r=this._list[this._tail];return this._list[this._tail]=void 0,this._head<2&&e>1e4&&e<=t>>>2&&this._shrinkArray(),r}},t.prototype.removeOne=function(e){var t=e;if(t===(0|t)&&this._head!==this._tail){var r=this.size(),n=this._list.length;if(!(t>=r||t<-r)){t<0&&(t+=r),t=this._head+t&this._capacityMask;var s,i=this._list[t];if(e<r/2){for(s=e;s>0;s--)this._list[t]=this._list[t=t-1+n&this._capacityMask];this._list[t]=void 0,this._head=this._head+1+n&this._capacityMask}else{for(s=r-1-e;s>0;s--)this._list[t]=this._list[t=t+1+n&this._capacityMask];this._list[t]=void 0,this._tail=this._tail-1+n&this._capacityMask}return i}}},t.prototype.remove=function(e,t){var r,n=e,s=t;if(n===(0|n)&&this._head!==this._tail){var i=this.size(),o=this._list.length;if(!(n>=i||n<-i||t<1)){if(n<0&&(n+=i),1===t||!t)return(r=new Array(1))[0]=this.removeOne(n),r;if(0===n&&n+t>=i)return r=this.toArray(),this.clear(),r;var a;for(n+t>i&&(t=i-n),r=new Array(t),a=0;a<t;a++)r[a]=this._list[this._head+n+a&this._capacityMask];if(n=this._head+n&this._capacityMask,e+t===i){for(this._tail=this._tail-t+o&this._capacityMask,a=t;a>0;a--)this._list[n=n+1+o&this._capacityMask]=void 0;return r}if(0===e){for(this._head=this._head+t+o&this._capacityMask,a=t-1;a>0;a--)this._list[n=n+1+o&this._capacityMask]=void 0;return r}if(n<i/2){for(this._head=this._head+e+t+o&this._capacityMask,a=e;a>0;a--)this.unshift(this._list[n=n-1+o&this._capacityMask]);for(n=this._head-1+o&this._capacityMask;s>0;)this._list[n=n-1+o&this._capacityMask]=void 0,s--;e<0&&(this._tail=n)}else{for(this._tail=n,n=n+t+o&this._capacityMask,a=i-(t+e);a>0;a--)this.push(this._list[n++]);for(n=this._tail;s>0;)this._list[n=n+1+o&this._capacityMask]=void 0,s--}return this._head<2&&this._tail>1e4&&this._tail<=o>>>2&&this._shrinkArray(),r}}},t.prototype.splice=function(e,t){var r=e;if(r===(0|r)){var n=this.size();if(r<0&&(r+=n),!(r>n)){if(arguments.length>2){var s,i,o,a=arguments.length,c=this._list.length,l=2;if(!n||r<n/2){for(i=new Array(r),s=0;s<r;s++)i[s]=this._list[this._head+s&this._capacityMask];for(0===t?(o=[],r>0&&(this._head=this._head+r+c&this._capacityMask)):(o=this.remove(r,t),this._head=this._head+r+c&this._capacityMask);a>l;)this.unshift(arguments[--a]);for(s=r;s>0;s--)this.unshift(i[s-1])}else{var u=(i=new Array(n-(r+t))).length;for(s=0;s<u;s++)i[s]=this._list[this._head+r+t+s&this._capacityMask];for(0===t?(o=[],r!=n&&(this._tail=this._head+r+c&this._capacityMask)):(o=this.remove(r,t),this._tail=this._tail-u+c&this._capacityMask);l<a;)this.push(arguments[l++]);for(s=0;s<u;s++)this.push(i[s])}return o}return this.remove(r,t)}}},t.prototype.clear=function(){this._list=new Array(this._list.length),this._head=0,this._tail=0},t.prototype.isEmpty=function(){return this._head===this._tail},t.prototype.toArray=function(){return this._copyArray(!1)},t.prototype._fromArray=function(e){var t=e.length,r=this._nextPowerOf2(t);this._list=new Array(r),this._capacityMask=r-1,this._tail=t;for(var n=0;n<t;n++)this._list[n]=e[n]},t.prototype._copyArray=function(e,t){var r=this._list,n=r.length,s=this.length;if((t|=s)==s&&this._head<this._tail)return this._list.slice(this._head,this._tail);var i,o=new Array(t),a=0;if(e||this._head>this._tail){for(i=this._head;i<n;i++)o[a++]=r[i];for(i=0;i<this._tail;i++)o[a++]=r[i]}else for(i=this._head;i<this._tail;i++)o[a++]=r[i];return o},t.prototype._growArray=function(){if(0!=this._head){var e=this._copyArray(!0,this._list.length<<1);this._tail=this._list.length,this._head=0,this._list=e}else this._tail=this._list.length,this._list.length<<=1;this._capacityMask=this._capacityMask<<1|1},t.prototype._shrinkArray=function(){this._list.length>>>=1,this._capacityMask>>>=1},t.prototype._nextPowerOf2=function(e){var t=1<<Math.log(e)/Math.log(2)+1;return Math.max(t,4)},e.exports=t},544:(e,t,r)=>{"use strict";const n=r(9939);t.PP=n.EventIterator,n.EventIterator},9939:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});class r{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(e){if(this.isStopped)return;const t={value:e,done:!1};if(this.pullQueue.length){const e=this.pullQueue.shift();e&&e.resolve(t)}else this.pushQueue.push(Promise.resolve(t)),void 0!==this.highWaterMark&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const e of this.pullQueue)e.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(e){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const t of this.pullQueue)t.reject(e);this.pullQueue.length=0}else{const t=Promise.reject(e);t.catch((()=>{})),this.pushQueue.push(t)}}remove(){Promise.resolve().then((()=>{this.removeCallback&&this.removeCallback()}))}[Symbol.asyncIterator](){return{next:e=>{const t=this.pushQueue.shift();return t?(void 0!==this.lowWaterMark&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),t):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise(((e,t)=>{this.pullQueue.push({resolve:e,reject:t})}))},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class n{constructor(e,{highWaterMark:t=100,lowWaterMark:n=1}={}){const s=new r;s.highWaterMark=t,s.lowWaterMark=n,s.removeCallback=e({push:e=>s.push(e),stop:()=>s.stop(),fail:e=>s.fail(e),on:(e,t)=>{s.eventHandlers[e]=t}})||(()=>{}),this[Symbol.asyncIterator]=()=>s[Symbol.asyncIterator](),Object.freeze(this)}}t.EventIterator=n,t.default=n},228:e=>{"use strict";var t=Object.prototype.hasOwnProperty,r="~";function n(){}function s(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function i(e,t,n,i,o){if("function"!=typeof n)throw new TypeError("The listener must be a function");var a=new s(n,i||e,o),c=r?r+t:t;return e._events[c]?e._events[c].fn?e._events[c]=[e._events[c],a]:e._events[c].push(a):(e._events[c]=a,e._eventsCount++),e}function o(e,t){0==--e._eventsCount?e._events=new n:delete e._events[t]}function a(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),a.prototype.eventNames=function(){var e,n,s=[];if(0===this._eventsCount)return s;for(n in e=this._events)t.call(e,n)&&s.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(e)):s},a.prototype.listeners=function(e){var t=r?r+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,i=n.length,o=new Array(i);s<i;s++)o[s]=n[s].fn;return o},a.prototype.listenerCount=function(e){var t=r?r+e:e,n=this._events[t];return n?n.fn?1:n.length:0},a.prototype.emit=function(e,t,n,s,i,o){var a=r?r+e:e;if(!this._events[a])return!1;var c,l,u=this._events[a],h=arguments.length;if(u.fn){switch(u.once&&this.removeListener(e,u.fn,void 0,!0),h){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,t),!0;case 3:return u.fn.call(u.context,t,n),!0;case 4:return u.fn.call(u.context,t,n,s),!0;case 5:return u.fn.call(u.context,t,n,s,i),!0;case 6:return u.fn.call(u.context,t,n,s,i,o),!0}for(l=1,c=new Array(h-1);l<h;l++)c[l-1]=arguments[l];u.fn.apply(u.context,c)}else{var d,p=u.length;for(l=0;l<p;l++)switch(u[l].once&&this.removeListener(e,u[l].fn,void 0,!0),h){case 1:u[l].fn.call(u[l].context);break;case 2:u[l].fn.call(u[l].context,t);break;case 3:u[l].fn.call(u[l].context,t,n);break;case 4:u[l].fn.call(u[l].context,t,n,s);break;default:if(!c)for(d=1,c=new Array(h-1);d<h;d++)c[d-1]=arguments[d];u[l].fn.apply(u[l].context,c)}}return!0},a.prototype.on=function(e,t,r){return i(this,e,t,r,!1)},a.prototype.once=function(e,t,r){return i(this,e,t,r,!0)},a.prototype.removeListener=function(e,t,n,s){var i=r?r+e:e;if(!this._events[i])return this;if(!t)return o(this,i),this;var a=this._events[i];if(a.fn)a.fn!==t||s&&!a.once||n&&a.context!==n||o(this,i);else{for(var c=0,l=[],u=a.length;c<u;c++)(a[c].fn!==t||s&&!a[c].once||n&&a[c].context!==n)&&l.push(a[c]);l.length?this._events[i]=1===l.length?l[0]:l:o(this,i)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=r?r+e:e,this._events[t]&&o(this,t)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a},194:e=>{e.exports=function(e){if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,r=Object.create(null),n=Object.create(null);function s(s,i){r[s]=i,++t>=e&&(t=0,n=r,r=Object.create(null))}return{has:function(e){return void 0!==r[e]||void 0!==n[e]},remove:function(e){void 0!==r[e]&&(r[e]=void 0),void 0!==n[e]&&(n[e]=void 0)},get:function(e){var t=r[e];return void 0!==t?t:void 0!==(t=n[e])?(s(e,t),t):void 0},set:function(e,t){void 0!==r[e]?r[e]=t:s(e,t)},clear:function(){r=Object.create(null),n=Object.create(null)}}}},4866:(e,t,r)=>{var n=r(5606);e.exports=function(){return"undefined"!=typeof window&&"object"==typeof window.process&&"renderer"===window.process.type||!(void 0===n||"object"!=typeof n.versions||!n.versions.electron)||"object"==typeof navigator&&"string"==typeof navigator.userAgent&&navigator.userAgent.indexOf("Electron")>=0}},6368:e=>{"use strict";e.exports=e=>{if("[object Object]"!==Object.prototype.toString.call(e))return!1;const t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}},6864:function(e,t,r){"use strict";const n=r(6368),{hasOwnProperty:s}=Object.prototype,{propertyIsEnumerable:i}=Object,o=(e,t,r)=>Object.defineProperty(e,t,{value:r,writable:!0,enumerable:!0,configurable:!0}),a=this,c={concatArrays:!1,ignoreUndefined:!1},l=e=>{const t=[];for(const r in e)s.call(e,r)&&t.push(r);if(Object.getOwnPropertySymbols){const r=Object.getOwnPropertySymbols(e);for(const n of r)i.call(e,n)&&t.push(n)}return t};function u(e){return Array.isArray(e)?function(e){const t=e.slice(0,0);return l(e).forEach((r=>{o(t,r,u(e[r]))})),t}(e):n(e)?function(e){const t=null===Object.getPrototypeOf(e)?Object.create(null):{};return l(e).forEach((r=>{o(t,r,u(e[r]))})),t}(e):e}const h=(e,t,r,n)=>(r.forEach((r=>{void 0===t[r]&&n.ignoreUndefined||(r in e&&e[r]!==Object.getPrototypeOf(e)?o(e,r,p(e[r],t[r],n)):o(e,r,u(t[r])))})),e),d=(e,t,r)=>{let n=e.slice(0,0),i=0;return[e,t].forEach((t=>{const a=[];for(let r=0;r<t.length;r++)s.call(t,r)&&(a.push(String(r)),o(n,i++,t===e?t[r]:u(t[r])));n=h(n,t,l(t).filter((e=>!a.includes(e))),r)})),n};function p(e,t,r){return r.concatArrays&&Array.isArray(e)&&Array.isArray(t)?d(e,t,r):n(t)&&n(e)?h(e,t,l(t),r):u(t)}e.exports=function(...e){const t=p(u(c),this!==a&&this||{},c);let r={_:{}};for(const s of e)if(void 0!==s){if(!n(s))throw new TypeError("`"+s+"` is not an Option Object");r=p(r,{_:s},t)}return r._}},8437:(e,t,r)=>{e.exports=r(4327)},4327:function(e,t){!function(r,n){"use strict";var s={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function i(e){if(!Array.isArray(e)&&!ArrayBuffer.isView(e))return!1;for(var t=0;t<e.length;t++)if(!Number.isInteger(e[t])||e[t]<0||e[t]>255)return!1;return!0}function o(e,t){return(65535&e)*t+(((e>>>16)*t&65535)<<16)}function a(e,t){return e<<t|e>>>32-t}function c(e){return e=o(e^=e>>>16,2246822507),(e=o(e^=e>>>13,3266489909))^e>>>16}function l(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]+t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]+t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]+t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]+t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]}function u(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]*t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]*t[3],r[1]+=r[2]>>>16,r[2]&=65535,r[2]+=e[3]*t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]*t[3],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[2]*t[2],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[3]*t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]*t[3]+e[1]*t[2]+e[2]*t[1]+e[3]*t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]}function h(e,t){return 32==(t%=64)?[e[1],e[0]]:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t|e[0]>>>32-t]:(t-=32,[e[1]<<t|e[0]>>>32-t,e[0]<<t|e[1]>>>32-t])}function d(e,t){return 0==(t%=64)?e:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t]:[e[1]<<t-32,0]}function p(e,t){return[e[0]^t[0],e[1]^t[1]]}function f(e){return e=p(e,[0,e[0]>>>1]),e=p(e=u(e,[4283543511,3981806797]),[0,e[0]>>>1]),p(e=u(e,[3301882366,444984403]),[0,e[0]>>>1])}s.x86.hash32=function(e,t){if(s.inputValidation&&!i(e))return n;t=t||0;for(var r=e.length%4,l=e.length-r,u=t,h=0,d=3432918353,p=461845907,f=0;f<l;f+=4)h=o(h=e[f]|e[f+1]<<8|e[f+2]<<16|e[f+3]<<24,d),h=o(h=a(h,15),p),u=o(u=a(u^=h,13),5)+3864292196;switch(h=0,r){case 3:h^=e[f+2]<<16;case 2:h^=e[f+1]<<8;case 1:h=o(h^=e[f],d),u^=h=o(h=a(h,15),p)}return(u=c(u^=e.length))>>>0},s.x86.hash128=function(e,t){if(s.inputValidation&&!i(e))return n;t=t||0;for(var r=e.length%16,l=e.length-r,u=t,h=t,d=t,p=t,f=0,g=0,m=0,y=0,w=597399067,b=2869860233,v=951274213,S=2716044179,E=0;E<l;E+=16)f=e[E]|e[E+1]<<8|e[E+2]<<16|e[E+3]<<24,g=e[E+4]|e[E+5]<<8|e[E+6]<<16|e[E+7]<<24,m=e[E+8]|e[E+9]<<8|e[E+10]<<16|e[E+11]<<24,y=e[E+12]|e[E+13]<<8|e[E+14]<<16|e[E+15]<<24,f=a(f=o(f,w),15),u=a(u^=f=o(f,b),19),u=o(u+=h,5)+1444728091,g=a(g=o(g,b),16),h=a(h^=g=o(g,v),17),h=o(h+=d,5)+197830471,m=a(m=o(m,v),17),d=a(d^=m=o(m,S),15),d=o(d+=p,5)+2530024501,y=a(y=o(y,S),18),p=a(p^=y=o(y,w),13),p=o(p+=u,5)+850148119;switch(f=0,g=0,m=0,y=0,r){case 15:y^=e[E+14]<<16;case 14:y^=e[E+13]<<8;case 13:y=o(y^=e[E+12],S),p^=y=o(y=a(y,18),w);case 12:m^=e[E+11]<<24;case 11:m^=e[E+10]<<16;case 10:m^=e[E+9]<<8;case 9:m=o(m^=e[E+8],v),d^=m=o(m=a(m,17),S);case 8:g^=e[E+7]<<24;case 7:g^=e[E+6]<<16;case 6:g^=e[E+5]<<8;case 5:g=o(g^=e[E+4],b),h^=g=o(g=a(g,16),v);case 4:f^=e[E+3]<<24;case 3:f^=e[E+2]<<16;case 2:f^=e[E+1]<<8;case 1:f=o(f^=e[E],w),u^=f=o(f=a(f,15),b)}return u^=e.length,u+=h^=e.length,u+=d^=e.length,h+=u+=p^=e.length,d+=u,p+=u,u=c(u),u+=h=c(h),u+=d=c(d),h+=u+=p=c(p),d+=u,p+=u,("00000000"+(u>>>0).toString(16)).slice(-8)+("00000000"+(h>>>0).toString(16)).slice(-8)+("00000000"+(d>>>0).toString(16)).slice(-8)+("00000000"+(p>>>0).toString(16)).slice(-8)},s.x64.hash128=function(e,t){if(s.inputValidation&&!i(e))return n;t=t||0;for(var r=e.length%16,o=e.length-r,a=[0,t],c=[0,t],g=[0,0],m=[0,0],y=[2277735313,289559509],w=[1291169091,658871167],b=0;b<o;b+=16)g=[e[b+4]|e[b+5]<<8|e[b+6]<<16|e[b+7]<<24,e[b]|e[b+1]<<8|e[b+2]<<16|e[b+3]<<24],m=[e[b+12]|e[b+13]<<8|e[b+14]<<16|e[b+15]<<24,e[b+8]|e[b+9]<<8|e[b+10]<<16|e[b+11]<<24],g=h(g=u(g,y),31),a=l(a=h(a=p(a,g=u(g,w)),27),c),a=l(u(a,[0,5]),[0,1390208809]),m=h(m=u(m,w),33),c=l(c=h(c=p(c,m=u(m,y)),31),a),c=l(u(c,[0,5]),[0,944331445]);switch(g=[0,0],m=[0,0],r){case 15:m=p(m,d([0,e[b+14]],48));case 14:m=p(m,d([0,e[b+13]],40));case 13:m=p(m,d([0,e[b+12]],32));case 12:m=p(m,d([0,e[b+11]],24));case 11:m=p(m,d([0,e[b+10]],16));case 10:m=p(m,d([0,e[b+9]],8));case 9:m=u(m=p(m,[0,e[b+8]]),w),c=p(c,m=u(m=h(m,33),y));case 8:g=p(g,d([0,e[b+7]],56));case 7:g=p(g,d([0,e[b+6]],48));case 6:g=p(g,d([0,e[b+5]],40));case 5:g=p(g,d([0,e[b+4]],32));case 4:g=p(g,d([0,e[b+3]],24));case 3:g=p(g,d([0,e[b+2]],16));case 2:g=p(g,d([0,e[b+1]],8));case 1:g=u(g=p(g,[0,e[b]]),y),a=p(a,g=u(g=h(g,31),w))}return a=l(a=p(a,[0,e.length]),c=p(c,[0,e.length])),c=l(c,a),a=l(a=f(a),c=f(c)),c=l(c,a),("00000000"+(a[0]>>>0).toString(16)).slice(-8)+("00000000"+(a[1]>>>0).toString(16)).slice(-8)+("00000000"+(c[0]>>>0).toString(16)).slice(-8)+("00000000"+(c[1]>>>0).toString(16)).slice(-8)},e.exports&&(t=e.exports=s),t.murmurHash3=s}()},5507:function(e,t){(function(){var e,r,n,s,i,o,a,c;c=function(e){return[(e&255<<24)>>>24,(e&255<<16)>>>16,(65280&e)>>>8,255&e].join(".")},a=function(e){var t,n,s,i,o,a;for(t=[],s=i=0;i<=3&&0!==e.length;s=++i){if(s>0){if("."!==e[0])throw new Error("Invalid IP");e=e.substring(1)}o=(a=r(e))[0],n=a[1],e=e.substring(n),t.push(o)}if(0!==e.length)throw new Error("Invalid IP");switch(t.length){case 1:if(t[0]>4294967295)throw new Error("Invalid IP");return t[0]>>>0;case 2:if(t[0]>255||t[1]>16777215)throw new Error("Invalid IP");return(t[0]<<24|t[1])>>>0;case 3:if(t[0]>255||t[1]>255||t[2]>65535)throw new Error("Invalid IP");return(t[0]<<24|t[1]<<16|t[2])>>>0;case 4:if(t[0]>255||t[1]>255||t[2]>255||t[3]>255)throw new Error("Invalid IP");return(t[0]<<24|t[1]<<16|t[2]<<8|t[3])>>>0;default:throw new Error("Invalid IP")}},s=(n=function(e){return e.charCodeAt(0)})("0"),o=n("a"),i=n("A"),r=function(e){var t,r,a,c,l;for(c=0,t=10,r="9",a=0,e.length>1&&"0"===e[a]&&("x"===e[a+1]||"X"===e[a+1]?(a+=2,t=16):"0"<=e[a+1]&&e[a+1]<="9"&&(a++,t=8,r="7")),l=a;a<e.length;){if("0"<=e[a]&&e[a]<=r)c=c*t+(n(e[a])-s)>>>0;else{if(16!==t)break;if("a"<=e[a]&&e[a]<="f")c=c*t+(10+n(e[a])-o)>>>0;else{if(!("A"<=e[a]&&e[a]<="F"))break;c=c*t+(10+n(e[a])-i)>>>0}}if(c>4294967295)throw new Error("too large");a++}if(a===l)throw new Error("empty octet");return[c,a]},e=function(){function e(e,t){var r,n,s;if("string"!=typeof e)throw new Error("Missing `net' parameter");if(t||(s=e.split("/",2),e=s[0],t=s[1]),t||(t=32),"string"==typeof t&&t.indexOf(".")>-1){try{this.maskLong=a(t)}catch(e){throw new Error("Invalid mask: "+t)}for(r=n=32;n>=0;r=--n)if(this.maskLong===4294967295<<32-r>>>0){this.bitmask=r;break}}else{if(!t&&0!==t)throw new Error("Invalid mask: empty");this.bitmask=parseInt(t,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0)}try{this.netLong=(a(e)&this.maskLong)>>>0}catch(t){throw new Error("Invalid net address: "+e)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+t);this.size=Math.pow(2,32-this.bitmask),this.base=c(this.netLong),this.mask=c(this.maskLong),this.hostmask=c(~this.maskLong),this.first=this.bitmask<=30?c(this.netLong+1):this.base,this.last=this.bitmask<=30?c(this.netLong+this.size-2):c(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?c(this.netLong+this.size-1):void 0}return e.prototype.contains=function(t){return"string"==typeof t&&(t.indexOf("/")>0||4!==t.split(".").length)&&(t=new e(t)),t instanceof e?this.contains(t.base)&&this.contains(t.broadcast||t.last):(a(t)&this.maskLong)>>>0==(this.netLong&this.maskLong)>>>0},e.prototype.next=function(t){return null==t&&(t=1),new e(c(this.netLong+this.size*t),this.mask)},e.prototype.forEach=function(e){var t,r,n;for(n=a(this.first),r=a(this.last),t=0;n<=r;)e(c(n),n,t),t++,n++},e.prototype.toString=function(){return this.base+"/"+this.bitmask},e}(),t.ip2long=a,t.long2ip=c,t.Netmask=e}).call(this)},152:(e,t,r)=>{"use strict";var n=r(8287).Buffer;class s{static isArrayBuffer(e){return"[object ArrayBuffer]"===Object.prototype.toString.call(e)}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||0===e.byteOffset&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=s.toUint8Array(e),n=s.toUint8Array(t);if(r.length!==n.byteLength)return!1;for(let e=0;e<r.length;e++)if(r[e]!==n[e])return!1;return!0}static concat(...e){let t;t=!Array.isArray(e[0])||e[1]instanceof Function?Array.isArray(e[0])&&e[1]instanceof Function?e[0]:e[e.length-1]instanceof Function?e.slice(0,e.length-1):e:e[0];let r=0;for(const e of t)r+=e.byteLength;const n=new Uint8Array(r);let s=0;for(const e of t){const t=this.toUint8Array(e);n.set(t,s),s+=t.length}return e[e.length-1]instanceof Function?this.toView(n,e[e.length-1]):n.buffer}}const i="string",o=/^[0-9a-f\s]+$/i,a=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,c=/^[a-zA-Z0-9-_]+$/;class l{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer}static toString(e){const t=s.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return decodeURIComponent(escape(r))}}class u{static toString(e,t=!1){const r=s.toArrayBuffer(e),n=new DataView(r);let i="";for(let e=0;e<r.byteLength;e+=2){const r=n.getUint16(e,t);i+=String.fromCharCode(r)}return i}static fromString(e,t=!1){const r=new ArrayBuffer(2*e.length),n=new DataView(r);for(let r=0;r<e.length;r++)n.setUint16(2*r,e.charCodeAt(r),t);return r}}class h{static isHex(e){return typeof e===i&&o.test(e)}static isBase64(e){return typeof e===i&&a.test(e)}static isBase64Url(e){return typeof e===i&&c.test(e)}static ToString(e,t="utf8"){const r=s.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return u.toString(r,!0);case"utf16":case"utf16be":return u.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return u.fromString(e,!0);case"utf16":case"utf16be":return u.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=s.toUint8Array(e);if("undefined"!=typeof btoa){const e=this.ToString(t,"binary");return btoa(e)}return n.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!h.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(n.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!h.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=h.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return l.fromString(e);case"utf16":case"utf16be":return u.fromString(e);case"utf16le":case"usc2":return u.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=h.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return l.toString(e);case"utf16":case"utf16be":return u.toString(e);case"utf16le":case"usc2":return u.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);return r.buffer}static ToBinary(e){const t=s.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return r}static ToHex(e){const t=s.toUint8Array(e);let r="";const n=t.length;for(let e=0;e<n;e++){const n=t[e];n<16&&(r+="0"),r+=n.toString(16)}return r}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!h.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let e=0;e<t.length;e+=2){const n=t.slice(e,e+2);r[e/2]=parseInt(n,16)}return r.buffer}static ToUtf16String(e,t=!1){return u.toString(e,t)}static FromUtf16String(e,t=!1){return u.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(null==e?void 0:e.replace(/[\n\r\t ]/g,""))||""}}h.DEFAULT_UTF8_ENCODING="utf8",t._H=s,t.U$=h},5617:(e,t,r)=>{e.exports=r(8303)},8303:(e,t,r)=>{var n=r(3961);t.operation=function(e){var r=t.timeouts(e);return new n(r,{forever:e&&(e.forever||e.retries===1/0),unref:e&&e.unref,maxRetryTime:e&&e.maxRetryTime})},t.timeouts=function(e){if(e instanceof Array)return[].concat(e);var t={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var r in e)t[r]=e[r];if(t.minTimeout>t.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var n=[],s=0;s<t.retries;s++)n.push(this.createTimeout(s,t));return e&&e.forever&&!n.length&&n.push(this.createTimeout(s,t)),n.sort((function(e,t){return e-t})),n},t.createTimeout=function(e,t){var r=t.randomize?Math.random()+1:1,n=Math.round(r*Math.max(t.minTimeout,1)*Math.pow(t.factor,e));return Math.min(n,t.maxTimeout)},t.wrap=function(e,r,n){if(r instanceof Array&&(n=r,r=null),!n)for(var s in n=[],e)"function"==typeof e[s]&&n.push(s);for(var i=0;i<n.length;i++){var o=n[i],a=e[o];e[o]=function(n){var s=t.operation(r),i=Array.prototype.slice.call(arguments,1),o=i.pop();i.push((function(e){s.retry(e)||(e&&(arguments[0]=s.mainError()),o.apply(this,arguments))})),s.attempt((function(){n.apply(e,i)}))}.bind(e,a),e[o].options=r}}},3961:e=>{function t(e,t){"boolean"==typeof t&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}e.exports=t,t.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},t.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},t.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=(new Date).getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var r=this._timeouts.shift();if(void 0===r){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1)}var n=this;return this._timer=setTimeout((function(){n._attempts++,n._operationTimeoutCb&&(n._timeout=setTimeout((function(){n._operationTimeoutCb(n._attempts)}),n._operationTimeout),n._options.unref&&n._timeout.unref()),n._fn(n._attempts)}),r),this._options.unref&&this._timer.unref(),!0},t.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout((function(){r._operationTimeoutCb()}),r._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},t.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},t.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},t.prototype.start=t.prototype.try,t.prototype.errors=function(){return this._errors},t.prototype.attempts=function(){return this._attempts},t.prototype.mainError=function(){if(0===this._errors.length)return null;for(var e={},t=null,r=0,n=0;n<this._errors.length;n++){var s=this._errors[n],i=s.message,o=(e[i]||0)+1;e[i]=o,o>=r&&(t=s,r=o)}return t}},3007:(e,t,r)=>{var n=r(9159).RBTree;function s(e,t,r){this.discrete=!1===e,this.delta=e||.01,this.K=void 0===t?25:t,this.CX=void 0===r?1.1:r,this.centroids=new n(i),this.nreset=0,this.reset()}function i(e,t){return e.mean>t.mean?1:e.mean<t.mean?-1:0}function o(e,t){return e.mean_cumn-t.mean_cumn}function a(e){this.config=e||{},this.mode=this.config.mode||"auto",s.call(this,"cont"===this.mode&&e.delta),this.digest_ratio=this.config.ratio||.9,this.digest_thresh=this.config.thresh||1e3,this.n_unique=0}s.prototype.reset=function(){this.centroids.clear(),this.n=0,this.nreset+=1,this.last_cumulate=0},s.prototype.size=function(){return this.centroids.size},s.prototype.toArray=function(e){var t=[];return e?(this._cumulate(!0),this.centroids.each((function(e){t.push(e)}))):this.centroids.each((function(e){t.push({mean:e.mean,n:e.n})})),t},s.prototype.summary=function(){return[(this.discrete?"exact ":"approximating ")+this.n+" samples using "+this.size()+" centroids","min = "+this.percentile(0),"Q1  = "+this.percentile(.25),"Q2  = "+this.percentile(.5),"Q3  = "+this.percentile(.75),"max = "+this.percentile(1)].join("\n")},s.prototype.push=function(e,t){t=t||1,e=Array.isArray(e)?e:[e];for(var r=0;r<e.length;r++)this._digest(e[r],t)},s.prototype.push_centroid=function(e){e=Array.isArray(e)?e:[e];for(var t=0;t<e.length;t++)this._digest(e[t].mean,e[t].n)},s.prototype._cumulate=function(e){if(!(this.n===this.last_cumulate||!e&&this.CX&&this.CX>this.n/this.last_cumulate)){var t=0;this.centroids.each((function(e){e.mean_cumn=t+e.n/2,t=e.cumn=t+e.n})),this.n=this.last_cumulate=t}},s.prototype.find_nearest=function(e){if(0===this.size())return null;var t=this.centroids.lowerBound({mean:e}),r=null===t.data()?t.prev():t.data();if(r.mean===e||this.discrete)return r;var n=t.prev();return n&&Math.abs(n.mean-e)<Math.abs(r.mean-e)?n:r},s.prototype._new_centroid=function(e,t,r){var n={mean:e,n:t,cumn:r};return this.centroids.insert(n),this.n+=t,n},s.prototype._addweight=function(e,t,r){t!==e.mean&&(e.mean+=r*(t-e.mean)/(e.n+r)),e.cumn+=r,e.mean_cumn+=r/2,e.n+=r,this.n+=r},s.prototype._digest=function(e,t){var r=this.centroids.min(),n=this.centroids.max(),s=this.find_nearest(e);if(s&&s.mean===e)this._addweight(s,e,t);else if(s===r)this._new_centroid(e,t,0);else if(s===n)this._new_centroid(e,t,this.n);else if(this.discrete)this._new_centroid(e,t,s.cumn);else{var i=s.mean_cumn/this.n;Math.floor(4*this.n*this.delta*i*(1-i))-s.n>=t?this._addweight(s,e,t):this._new_centroid(e,t,s.cumn)}this._cumulate(!1),!this.discrete&&this.K&&this.size()>this.K/this.delta&&this.compress()},s.prototype.bound_mean=function(e){var t=this.centroids.upperBound({mean:e}),r=t.prev();return[r,r.mean===e?r:t.next()]},s.prototype.p_rank=function(e){var t=(Array.isArray(e)?e:[e]).map(this._p_rank,this);return Array.isArray(e)?t:t[0]},s.prototype._p_rank=function(e){if(0!==this.size()){if(e<this.centroids.min().mean)return 0;if(e>this.centroids.max().mean)return 1;this._cumulate(!0);var t=this.bound_mean(e),r=t[0],n=t[1];if(this.discrete)return r.cumn/this.n;var s=r.mean_cumn;return r!==n&&(s+=(e-r.mean)*(n.mean_cumn-r.mean_cumn)/(n.mean-r.mean)),s/this.n}},s.prototype.bound_mean_cumn=function(e){this.centroids._comparator=o;var t=this.centroids.upperBound({mean_cumn:e});this.centroids._comparator=i;var r=t.prev();return[r,r&&r.mean_cumn===e?r:t.next()]},s.prototype.percentile=function(e){var t=(Array.isArray(e)?e:[e]).map(this._percentile,this);return Array.isArray(e)?t:t[0]},s.prototype._percentile=function(e){if(0!==this.size()){this._cumulate(!0);var t=this.n*e,r=this.bound_mean_cumn(t),n=r[0],s=r[1];return s===n||null===n||null===s?(n||s).mean:this.discrete?t<=n.cumn?n.mean:s.mean:n.mean+(t-n.mean_cumn)*(s.mean-n.mean)/(s.mean_cumn-n.mean_cumn)}},s.prototype.compress=function(){if(!this.compressing){var e,t,r=this.toArray();for(this.reset(),this.compressing=!0;r.length>0;)this.push_centroid((e=r,void 0,t=Math.floor(Math.random()*e.length),e.splice(t,1)[0]));this._cumulate(!0),this.compressing=!1}},a.prototype=Object.create(s.prototype),a.prototype.constructor=a,a.prototype.push=function(e){s.prototype.push.call(this,e),this.check_continuous()},a.prototype._new_centroid=function(e,t,r){this.n_unique+=1,s.prototype._new_centroid.call(this,e,t,r)},a.prototype._addweight=function(e,t,r){1===e.n&&(this.n_unique-=1),s.prototype._addweight.call(this,e,t,r)},a.prototype.check_continuous=function(){return!("auto"!==this.mode||this.size()<this.digest_thresh)&&this.n_unique/this.size()>this.digest_ratio&&(this.mode="cont",this.discrete=!1,this.delta=this.config.delta||.01,this.compress(),!0)},e.exports={TDigest:s,Digest:a}},8819:(e,t,r)=>{"use strict";r.d(t,{DRPNode:()=>yk,R:()=>mk});var n={};r.r(n),r.d(n,{base58btc:()=>ue,base58flickr:()=>he});var s={};r.r(s),r.d(s,{base32:()=>de,base32hex:()=>me,base32hexpad:()=>we,base32hexpadupper:()=>be,base32hexupper:()=>ye,base32pad:()=>fe,base32padupper:()=>ge,base32upper:()=>pe,base32z:()=>ve});var i={};r.r(i),r.d(i,{base36:()=>Se,base36upper:()=>Ee});var o={};r.r(o),r.d(o,{identity:()=>Xe});var a={};r.r(a),r.d(a,{aK:()=>jt,e8:()=>Tt,DO:()=>xt,dJ:()=>Wt,OG:()=>Kt,My:()=>Pt,Ph:()=>Ot,lX:()=>Ut,Id:()=>Ht,fg:()=>Jt,qj:()=>$t,aT:()=>Lt,r4:()=>qt,aY:()=>Ct,x:()=>Xt,lq:()=>Ft,z:()=>Vt,zW:()=>Dt,Q5:()=>Zt});var c={};r.r(c),r.d(c,{base10:()=>Dn});var l={};r.r(l),r.d(l,{base16:()=>Nn,base16upper:()=>Rn});var u={};r.r(u),r.d(u,{base2:()=>Bn});var h={};r.r(h),r.d(h,{base256emoji:()=>Fn});var d={};r.r(d),r.d(d,{base64:()=>Vn,base64pad:()=>$n,base64url:()=>Hn,base64urlpad:()=>zn});var p={};r.r(p),r.d(p,{base8:()=>qn});var f={};r.r(f),r.d(f,{identity:()=>jn});var g={};r.r(g),r.d(g,{code:()=>Yn,decode:()=>Qn,encode:()=>Jn,name:()=>Gn});var m={};r.r(m),r.d(m,{code:()=>Xn,decode:()=>ts,encode:()=>es,name:()=>Zn});var y={};r.r(y),r.d(y,{sha256:()=>is,sha512:()=>os});var w=r(4653);class b extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return null==t?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let n=this.#e.get(e);null==n&&(n=[],this.#e.set(e,n)),n.push({callback:t,once:(!0!==r&&!1!==r&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let n=this.#e.get(e);null!=n&&(n=n.filter((({callback:e})=>e!==t)),this.#e.set(e,n))}dispatchEvent(e){const t=super.dispatchEvent(e);let r=this.#e.get(e.type);return null==r||(r=r.filter((({once:e})=>!e)),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}const v="StrictSign",S="StrictNoSign";var E;!function(e){e.Accept="accept",e.Ignore="ignore",e.Reject="reject"}(E||(E={}));const k=Symbol.for("@libp2p/pubsub");function A(e){return Boolean(e?.[k])}const I=Symbol.for("@libp2p/service-capabilities"),_=Symbol.for("@libp2p/service-dependencies");class C extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}}class x extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}class T extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}}class M extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}}class P extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class D extends Error{static name="InvalidPrivateKeyError";constructor(e="Invalid private key"){super(e),this.name="InvalidPrivateKeyError"}}Error;class N extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class R extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class B extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class L extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class O extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class U extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}class F extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}}class V extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}class $ extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}}class H extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class z extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class q extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class j extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}Error;class W extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}}class K extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}Error;class G extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Y extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class J extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class Q extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class Z extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class X extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}function ee(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}new Uint8Array(0);const te=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var s=0;s<e.length;s++){var i=e.charAt(s),o=i.charCodeAt(0);if(255!==r[o])throw new TypeError(i+" is ambiguous");r[o]=s}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,s=0;e[t]===c;)n++,t++;for(var i=(e.length-t)*l+1>>>0,o=new Uint8Array(i);e[t];){var u=r[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=i-1;(0!==u||h<s)&&-1!==d;d--,h++)u+=a*o[d]>>>0,o[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");s=h,t++}if(" "!==e[t]){for(var p=i-s;p!==i&&0===o[p];)p++;for(var f=new Uint8Array(n+(i-p)),g=n;p!==i;)f[g++]=o[p++];return f}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,s=0,i=t.length;s!==i&&0===t[s];)s++,r++;for(var o=(i-s)*u+1>>>0,l=new Uint8Array(o);s!==i;){for(var h=t[s],d=0,p=o-1;(0!==h||d<n)&&-1!==p;p--,d++)h+=256*l[p]>>>0,l[p]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");n=d,s++}for(var f=o-n;f!==o&&0===l[f];)f++;for(var g=c.repeat(r);f<o;++f)g+=e.charAt(l[f]);return g},decodeUnsafe:h,decode:function(e){var r=h(e);if(r)return r;throw new Error(`Non-${t} character`)}}};class re{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class ne{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const n=t.codePointAt(0);if(void 0===n)throw new Error("Invalid prefix character");this.prefixCodePoint=n,this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return ie(this,e)}}class se{decoders;constructor(e){this.decoders=e}or(e){return ie(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(null!=r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function ie(e,t){return new se({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class oe{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new re(e,t,r),this.decoder=new ne(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function ae({name:e,prefix:t,encode:r,decode:n}){return new oe(e,t,r,n)}function ce({name:e,prefix:t,alphabet:r}){const{encode:n,decode:s}=te(r,e);return ae({prefix:t,name:e,encode:n,decode:e=>ee(s(e))})}function le({name:e,prefix:t,bitsPerChar:r,alphabet:n}){return ae({prefix:t,name:e,encode:e=>function(e,t,r){const n="="===t[t.length-1],s=(1<<r)-1;let i="",o=0,a=0;for(let n=0;n<e.length;++n)for(a=a<<8|e[n],o+=8;o>r;)o-=r,i+=t[s&a>>o];if(0!==o&&(i+=t[s&a<<r-o]),n)for(;i.length*r&7;)i+="=";return i}(e,n,r),decode:t=>function(e,t,r,n){const s={};for(let e=0;e<t.length;++e)s[t[e]]=e;let i=e.length;for(;"="===e[i-1];)--i;const o=new Uint8Array(i*r/8|0);let a=0,c=0,l=0;for(let t=0;t<i;++t){const i=s[e[t]];if(void 0===i)throw new SyntaxError(`Non-${n} character`);c=c<<r|i,a+=r,a>=8&&(a-=8,o[l++]=255&c>>a)}if(a>=r||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o}(t,n,r,e)})}const ue=ce({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),he=ce({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),de=le({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),pe=le({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),fe=le({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),ge=le({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),me=le({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ye=le({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),we=le({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),be=le({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ve=le({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Se=ce({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ee=ce({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var ke=128,Ae=-128,Ie=Math.pow(2,31),_e=128,Ce=127,xe=Math.pow(2,7),Te=Math.pow(2,14),Me=Math.pow(2,21),Pe=Math.pow(2,28),De=Math.pow(2,35),Ne=Math.pow(2,42),Re=Math.pow(2,49),Be=Math.pow(2,56),Le=Math.pow(2,63);const Oe={encode:function e(t,r,n){r=r||[];for(var s=n=n||0;t>=Ie;)r[n++]=255&t|ke,t/=128;for(;t&Ae;)r[n++]=255&t|ke,t>>>=7;return r[n]=0|t,e.bytes=n-s+1,r},decode:function e(t,r){var n,s=0,i=0,o=r=r||0,a=t.length;do{if(o>=a)throw e.bytes=0,new RangeError("Could not decode varint");n=t[o++],s+=i<28?(n&Ce)<<i:(n&Ce)*Math.pow(2,i),i+=7}while(n>=_e);return e.bytes=o-r,s},encodingLength:function(e){return e<xe?1:e<Te?2:e<Me?3:e<Pe?4:e<De?5:e<Ne?6:e<Re?7:e<Be?8:e<Le?9:10}};function Ue(e,t=0){return[Oe.decode(e,t),Oe.decode.bytes]}function Fe(e,t,r=0){return Oe.encode(e,t,r),t}function Ve(e){return Oe.encodingLength(e)}function $e(e,t){const r=t.byteLength,n=Ve(e),s=n+Ve(r),i=new Uint8Array(s+r);return Fe(e,i,0),Fe(r,i,n),i.set(t,s),new ze(e,r,t,i)}function He(e){const t=ee(e),[r,n]=Ue(t),[s,i]=Ue(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new ze(r,s,o,t)}class ze{code;size;digest;bytes;constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}function qe(e,t){const{bytes:r,version:n}=e;return 0===n?function(e,t,r){const{prefix:n}=r;if(n!==ue.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const s=t.get(n);if(null==s){const s=r.encode(e).slice(1);return t.set(n,s),s}return s}(r,We(e),t??ue.encoder):function(e,t,r){const{prefix:n}=r,s=t.get(n);if(null==s){const s=r.encode(e);return t.set(n,s),s}return s}(r,We(e),t??de.encoder)}const je=new WeakMap;function We(e){const t=je.get(e);if(null==t){const t=new Map;return je.set(e,t),t}return t}class Ke{code;version;multihash;bytes;"/";constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Ge)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Ye)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Ke.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=$e(e,t);return Ke.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Ke.equals(this,e)}static equals(e,t){const r=t;return null!=r&&e.code===r.code&&e.version===r.version&&function(e,t){if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&function(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}(e.bytes,r.bytes)}}(e.multihash,r.multihash)}toString(e){return qe(this,e)}toJSON(){return{"/":qe(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof Ke)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:s}=t;return new Ke(e,r,n,s??Je(e,r,n.bytes))}if(!0===t[Qe]){const{version:e,multihash:r,code:n}=t,s=He(r);return Ke.create(e,n,s)}return null}static create(e,t,r){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==Ge)throw new Error(`Version 0 CID must use dag-pb (code: ${Ge}) block encoding`);return new Ke(e,t,r,r.bytes);case 1:{const n=Je(e,t,r.bytes);return new Ke(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return Ke.create(0,Ge,e)}static createV1(e,t){return Ke.create(1,e,t)}static decode(e){const[t,r]=Ke.decodeFirst(e);if(0!==r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Ke.inspectBytes(e),r=t.size-t.multihashSize,n=ee(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=n.subarray(t.multihashSize-t.digestSize),i=new ze(t.multihashCode,t.digestSize,s,n);return[0===t.version?Ke.createV0(i):Ke.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=Ue(e.subarray(t));return t+=n,r};let n=r(),s=Ge;if(18===n?(n=0,t=0):s=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const i=t,o=r(),a=r(),c=t+a;return{version:n,codec:s,multihashCode:o,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[r,n]=function(e,t){switch(e[0]){case"Q":{const r=t??ue;return[ue.prefix,r.decode(`${ue.prefix}${e}`)]}case ue.prefix:{const r=t??ue;return[ue.prefix,r.decode(e)]}case de.prefix:{const r=t??de;return[de.prefix,r.decode(e)]}case Se.prefix:{const r=t??Se;return[Se.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),s=Ke.decode(n);if(0===s.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return We(s).set(r,e),s}}const Ge=112,Ye=18;function Je(e,t,r){const n=Ve(e),s=n+Ve(t),i=new Uint8Array(s+r.byteLength);return Fe(e,i,0),Fe(t,i,n),i.set(r,s),i}const Qe=Symbol.for("@ipld/js-cid/CID"),Ze=ee,Xe={code:0,name:"identity",encode:Ze,digest:function(e){return $e(0,Ze(e))}};function et(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}function tt(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function rt(e,...t){if(!((r=e)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function nt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}const st="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,it=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),ot=(e,t)=>e<<32-t|e>>>t;function at(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),rt(e),e}class ct{clone(){return this._cloneInto()}}function lt(e){const t=t=>e().update(at(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function ut(e=32){if(st&&"function"==typeof st.getRandomValues)return st.getRandomValues(new Uint8Array(e));if(st&&"function"==typeof st.randomBytes)return st.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}const ht=(e,t,r)=>e&t^e&r^t&r;class dt extends ct{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=it(this.buffer)}update(e){nt(this);const{view:t,buffer:r,blockLen:n}=this,s=(e=at(e)).length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o!==n)r.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=it(e);for(;n<=s-i;i+=n)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){nt(this),function(e,t){rt(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:s}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i),c=n?4:0,l=n?0:4;e.setUint32(t+c,o,n),e.setUint32(t+l,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const o=it(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,l=this.get();if(c>l.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)o.setUint32(4*e,l[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:s,destroyed:i,pos:o}=this;return e.length=n,e.pos=o,e.finished=s,e.destroyed=i,n%t&&e.buffer.set(r),e}}const pt=BigInt(2**32-1),ft=BigInt(32);function gt(e,t=!1){return t?{h:Number(e&pt),l:Number(e>>ft&pt)}:{h:0|Number(e>>ft&pt),l:0|Number(e&pt)}}const mt={fromBig:gt,split:function(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let s=0;s<e.length;s++){const{h:i,l:o}=gt(e[s],t);[r[s],n[s]]=[i,o]}return[r,n]},toBig:(e,t)=>BigInt(e>>>0)<<ft|BigInt(t>>>0),shrSH:(e,t,r)=>e>>>r,shrSL:(e,t,r)=>e<<32-r|t>>>r,rotrSH:(e,t,r)=>e>>>r|t<<32-r,rotrSL:(e,t,r)=>e<<32-r|t>>>r,rotrBH:(e,t,r)=>e<<64-r|t>>>r-32,rotrBL:(e,t,r)=>e>>>r-32|t<<64-r,rotr32H:(e,t)=>t,rotr32L:(e,t)=>e,rotlSH:(e,t,r)=>e<<r|t>>>32-r,rotlSL:(e,t,r)=>t<<r|e>>>32-r,rotlBH:(e,t,r)=>t<<r-32|e>>>64-r,rotlBL:(e,t,r)=>e<<r-32|t>>>64-r,add:function(e,t,r,n){const s=(t>>>0)+(n>>>0);return{h:e+r+(s/2**32|0)|0,l:0|s}},add3L:(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H:(e,t,r,n)=>t+r+n+(e/2**32|0)|0,add4L:(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),add4H:(e,t,r,n,s)=>t+r+n+s+(e/2**32|0)|0,add5H:(e,t,r,n,s,i)=>t+r+n+s+i+(e/2**32|0)|0,add5L:(e,t,r,n,s)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(s>>>0)},yt=mt,[wt,bt]=(()=>yt.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),vt=new Uint32Array(80),St=new Uint32Array(80);class Et extends dt{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:s,Cl:i,Dh:o,Dl:a,Eh:c,El:l,Fh:u,Fl:h,Gh:d,Gl:p,Hh:f,Hl:g}=this;return[e,t,r,n,s,i,o,a,c,l,u,h,d,p,f,g]}set(e,t,r,n,s,i,o,a,c,l,u,h,d,p,f,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|s,this.Cl=0|i,this.Dh=0|o,this.Dl=0|a,this.Eh=0|c,this.El=0|l,this.Fh=0|u,this.Fl=0|h,this.Gh=0|d,this.Gl=0|p,this.Hh=0|f,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)vt[r]=e.getUint32(t),St[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|vt[e-15],r=0|St[e-15],n=yt.rotrSH(t,r,1)^yt.rotrSH(t,r,8)^yt.shrSH(t,r,7),s=yt.rotrSL(t,r,1)^yt.rotrSL(t,r,8)^yt.shrSL(t,r,7),i=0|vt[e-2],o=0|St[e-2],a=yt.rotrSH(i,o,19)^yt.rotrBH(i,o,61)^yt.shrSH(i,o,6),c=yt.rotrSL(i,o,19)^yt.rotrBL(i,o,61)^yt.shrSL(i,o,6),l=yt.add4L(s,c,St[e-7],St[e-16]),u=yt.add4H(l,n,a,vt[e-7],vt[e-16]);vt[e]=0|u,St[e]=0|l}let{Ah:r,Al:n,Bh:s,Bl:i,Ch:o,Cl:a,Dh:c,Dl:l,Eh:u,El:h,Fh:d,Fl:p,Gh:f,Gl:g,Hh:m,Hl:y}=this;for(let e=0;e<80;e++){const t=yt.rotrSH(u,h,14)^yt.rotrSH(u,h,18)^yt.rotrBH(u,h,41),w=yt.rotrSL(u,h,14)^yt.rotrSL(u,h,18)^yt.rotrBL(u,h,41),b=u&d^~u&f,v=h&p^~h&g,S=yt.add5L(y,w,v,bt[e],St[e]),E=yt.add5H(S,m,t,b,wt[e],vt[e]),k=0|S,A=yt.rotrSH(r,n,28)^yt.rotrBH(r,n,34)^yt.rotrBH(r,n,39),I=yt.rotrSL(r,n,28)^yt.rotrBL(r,n,34)^yt.rotrBL(r,n,39),_=r&s^r&o^s&o,C=n&i^n&a^i&a;m=0|f,y=0|g,f=0|d,g=0|p,d=0|u,p=0|h,({h:u,l:h}=yt.add(0|c,0|l,0|E,0|k)),c=0|o,l=0|a,o=0|s,a=0|i,s=0|r,i=0|n;const x=yt.add3L(k,I,C);r=yt.add3H(x,E,A,_),n=0|x}({h:r,l:n}=yt.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:s,l:i}=yt.add(0|this.Bh,0|this.Bl,0|s,0|i)),({h:o,l:a}=yt.add(0|this.Ch,0|this.Cl,0|o,0|a)),({h:c,l}=yt.add(0|this.Dh,0|this.Dl,0|c,0|l)),({h:u,l:h}=yt.add(0|this.Eh,0|this.El,0|u,0|h)),({h:d,l:p}=yt.add(0|this.Fh,0|this.Fl,0|d,0|p)),({h:f,l:g}=yt.add(0|this.Gh,0|this.Gl,0|f,0|g)),({h:m,l:y}=yt.add(0|this.Hh,0|this.Hl,0|m,0|y)),this.set(r,n,s,i,o,a,c,l,u,h,d,p,f,g,m,y)}roundClean(){vt.fill(0),St.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const kt=lt((()=>new Et)),At=BigInt(0),It=BigInt(1),_t=BigInt(2);function Ct(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function xt(e){if(!Ct(e))throw new Error("Uint8Array expected")}function Tt(e,t){if("boolean"!=typeof t)throw new Error(e+" boolean expected, got "+t)}const Mt=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function Pt(e){xt(e);let t="";for(let r=0;r<e.length;r++)t+=Mt[e[r]];return t}function Dt(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function Nt(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?At:BigInt("0x"+e)}const Rt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Bt(e){return e>=Rt._0&&e<=Rt._9?e-Rt._0:e>=Rt.A&&e<=Rt.F?e-(Rt.A-10):e>=Rt.a&&e<=Rt.f?e-(Rt.a-10):void 0}function Lt(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,s=0;t<r;t++,s+=2){const r=Bt(e.charCodeAt(s)),i=Bt(e.charCodeAt(s+1));if(void 0===r||void 0===i){const t=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+s)}n[t]=16*r+i}return n}function Ot(e){return Nt(Pt(e))}function Ut(e){return xt(e),Nt(Pt(Uint8Array.from(e).reverse()))}function Ft(e,t){return Lt(e.toString(16).padStart(2*t,"0"))}function Vt(e,t){return Ft(e,t).reverse()}function $t(e,t,r){let n;if("string"==typeof t)try{n=Lt(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!Ct(t))throw new Error(e+" must be hex string or Uint8Array");n=Uint8Array.from(t)}const s=n.length;if("number"==typeof r&&s!==r)throw new Error(e+" of length "+r+" expected, got "+s);return n}function Ht(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];xt(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}const zt=e=>"bigint"==typeof e&&At<=e;function qt(e,t,r){return zt(e)&&zt(t)&&zt(r)&&t<=e&&e<r}function jt(e,t,r,n){if(!qt(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function Wt(e){let t;for(t=0;e>At;e>>=It,t+=1);return t}const Kt=e=>(_t<<BigInt(e-1))-It,Gt=e=>new Uint8Array(e),Yt=e=>Uint8Array.from(e);function Jt(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=Gt(e),s=Gt(e),i=0;const o=()=>{n.fill(1),s.fill(0),i=0},a=(...e)=>r(s,n,...e),c=(e=Gt())=>{s=a(Yt([0]),e),n=a(),0!==e.length&&(s=a(Yt([1]),e),n=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=a();const t=n.slice();r.push(t),e+=n.length}return Ht(...r)};return(e,t)=>{let r;for(o(),c(e);!(r=t(l()));)c();return o(),r}}const Qt={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||Ct(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function Zt(e,t,r={}){const n=(t,r,n)=>{const s=Qt[r];if("function"!=typeof s)throw new Error("invalid validator function");const i=e[t];if(!(n&&void 0===i||s(i,e)))throw new Error("param "+String(t)+" is invalid. Expected "+r+", got "+i)};for(const[e,r]of Object.entries(t))n(e,r,!1);for(const[e,t]of Object.entries(r))n(e,t,!0);return e}function Xt(e){const t=new WeakMap;return(r,...n)=>{const s=t.get(r);if(void 0!==s)return s;const i=e(r,...n);return t.set(r,i),i}}const er=BigInt(0),tr=BigInt(1),rr=BigInt(2),nr=BigInt(3),sr=BigInt(4),ir=BigInt(5),or=BigInt(8);function ar(e,t){const r=e%t;return r>=er?r:t+r}function cr(e,t,r){if(t<er)throw new Error("invalid exponent, negatives unsupported");if(r<=er)throw new Error("invalid modulus");if(r===tr)return er;let n=tr;for(;t>er;)t&tr&&(n=n*e%r),e=e*e%r,t>>=tr;return n}function lr(e,t,r){let n=e;for(;t-- >er;)n*=n,n%=r;return n}function ur(e,t){if(e===er)throw new Error("invert: expected non-zero number");if(t<=er)throw new Error("invert: expected positive modulus, got "+t);let r=ar(e,t),n=t,s=er,i=tr,o=tr,a=er;for(;r!==er;){const e=n/r,t=n%r,c=s-o*e,l=i-a*e;n=r,r=t,s=o,i=a,o=c,a=l}if(n!==tr)throw new Error("invert: does not exist");return ar(s,t)}const hr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function dr(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function pr(e,t,r=!1,n={}){if(e<=er)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:s,nByteLength:i}=dr(e,t);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:e,BITS:s,BYTES:i,MASK:Kt(s),ZERO:er,ONE:tr,create:t=>ar(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return er<=t&&t<e},is0:e=>e===er,isOdd:e=>(e&tr)===tr,neg:t=>ar(-t,e),eql:(e,t)=>e===t,sqr:t=>ar(t*t,e),add:(t,r)=>ar(t+r,e),sub:(t,r)=>ar(t-r,e),mul:(t,r)=>ar(t*r,e),pow:(e,t)=>function(e,t,r){if(r<er)throw new Error("invalid exponent, negatives unsupported");if(r===er)return e.ONE;if(r===tr)return t;let n=e.ONE,s=t;for(;r>er;)r&tr&&(n=e.mul(n,s)),s=e.sqr(s),r>>=tr;return n}(a,e,t),div:(t,r)=>ar(t*ur(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>ur(t,e),sqrt:n.sqrt||(t=>(o||(o=function(e){if(e%sr===nr){const t=(e+tr)/sr;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%or===ir){const t=(e-ir)/or;return function(e,r){const n=e.mul(r,rr),s=e.pow(n,t),i=e.mul(r,s),o=e.mul(e.mul(i,rr),s),a=e.mul(i,e.sub(o,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(e){const t=(e-tr)/rr;let r,n,s;for(r=e-tr,n=0;r%rr===er;r/=rr,n++);for(s=rr;s<e&&cr(s,t,e)!==e-tr;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===n){const t=(e+tr)/sr;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const i=(r+tr)/rr;return function(e,o){if(e.pow(o,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,c=e.pow(e.mul(e.ONE,s),r),l=e.pow(o,i),u=e.pow(o,r);for(;!e.eql(u,e.ONE);){if(e.eql(u,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(u);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(c,tr<<BigInt(a-t-1));c=e.sqr(r),l=e.mul(l,r),u=e.mul(u,c),a=t}return l}}(e)}(e)),o(a,t))),invertBatch:e=>function(e,t){const r=new Array(t.length),n=t.reduce(((t,n,s)=>e.is0(n)?t:(r[s]=t,e.mul(t,n))),e.ONE),s=e.inv(n);return t.reduceRight(((t,n,s)=>e.is0(n)?t:(r[s]=e.mul(t,r[s]),e.mul(t,n))),s),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?Vt(e,i):Ft(e,i),fromBytes:e=>{if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);return r?Ut(e):Ot(e)}});return Object.freeze(a)}function fr(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function gr(e){const t=fr(e);return t+Math.ceil(t/2)}const mr=BigInt(0),yr=BigInt(1);function wr(e,t){const r=t.negate();return e?r:t}function br(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function vr(e,t){return br(e,t),{windows:Math.ceil(t/e)+1,windowSize:2**(e-1)}}const Sr=new WeakMap,Er=new WeakMap;function kr(e){return Er.get(e)||1}function Ar(e,t){return{constTimeNegate:wr,hasPrecomputes:e=>1!==kr(e),unsafeLadder(t,r,n=e.ZERO){let s=t;for(;r>mr;)r&yr&&(n=n.add(s)),s=s.double(),r>>=yr;return n},precomputeWindow(e,r){const{windows:n,windowSize:s}=vr(r,t),i=[];let o=e,a=o;for(let e=0;e<n;e++){a=o,i.push(a);for(let e=1;e<s;e++)a=a.add(o),i.push(a);o=a.double()}return i},wNAF(r,n,s){const{windows:i,windowSize:o}=vr(r,t);let a=e.ZERO,c=e.BASE;const l=BigInt(2**r-1),u=2**r,h=BigInt(r);for(let e=0;e<i;e++){const t=e*o;let r=Number(s&l);s>>=h,r>o&&(r-=u,s+=yr);const i=t,d=t+Math.abs(r)-1,p=e%2!=0,f=r<0;0===r?c=c.add(wr(p,n[i])):a=a.add(wr(f,n[d]))}return{p:a,f:c}},wNAFUnsafe(r,n,s,i=e.ZERO){const{windows:o,windowSize:a}=vr(r,t),c=BigInt(2**r-1),l=2**r,u=BigInt(r);for(let e=0;e<o;e++){const t=e*a;if(s===mr)break;let r=Number(s&c);if(s>>=u,r>a&&(r-=l,s+=yr),0===r)continue;let o=n[t+Math.abs(r)-1];r<0&&(o=o.negate()),i=i.add(o)}return i},getPrecomputes(e,t,r){let n=Sr.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&Sr.set(t,r(n))),n},wNAFCached(e,t,r){const n=kr(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)},wNAFCachedUnsafe(e,t,r,n){const s=kr(e);return 1===s?this.unsafeLadder(e,t,n):this.wNAFUnsafe(s,this.getPrecomputes(s,e,r),t,n)},setWindowSize(e,r){br(r,t),Er.set(e,r),Sr.delete(e)}}}function Ir(e,t,r,n){if(function(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach(((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)}))}(r,e),function(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach(((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)}))}(n,t),r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");const s=e.ZERO,i=Wt(BigInt(r.length)),o=i>12?i-3:i>4?i-2:i?2:1,a=(1<<o)-1,c=new Array(a+1).fill(s);let l=s;for(let e=Math.floor((t.BITS-1)/o)*o;e>=0;e-=o){c.fill(s);for(let t=0;t<n.length;t++){const s=n[t],i=Number(s>>BigInt(e)&BigInt(a));c[i]=c[i].add(r[t])}let t=s;for(let e=c.length-1,r=s;e>0;e--)r=r.add(c[e]),t=t.add(r);if(l=l.add(t),0!==e)for(let e=0;e<o;e++)l=l.double()}return l}function _r(e){return function(e){const t=hr.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});Zt(e,t)}(e.Fp),Zt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...dr(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const Cr=BigInt(0),xr=BigInt(1),Tr=BigInt(2),Mr=BigInt(8),Pr={zip215:!0};const Dr=BigInt(0),Nr=BigInt(1);const Rr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Br=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Lr=(BigInt(0),BigInt(1)),Or=BigInt(2),Ur=BigInt(3),Fr=BigInt(5),Vr=BigInt(8);function $r(e){const t=BigInt(10),r=BigInt(20),n=BigInt(40),s=BigInt(80),i=Rr,o=e*e%i*e%i,a=lr(o,Or,i)*o%i,c=lr(a,Lr,i)*e%i,l=lr(c,Fr,i)*c%i,u=lr(l,t,i)*l%i,h=lr(u,r,i)*u%i,d=lr(h,n,i)*h%i,p=lr(d,s,i)*d%i,f=lr(p,s,i)*d%i,g=lr(f,t,i)*l%i;return{pow_p_5_8:lr(g,Or,i)*e%i,b2:o}}function Hr(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function zr(e,t){const r=Rr,n=ar(t*t*t,r),s=ar(n*n*t,r);let i=ar(e*n*$r(e*s).pow_p_5_8,r);const o=ar(t*i*i,r),a=i,c=ar(i*Br,r),l=o===e,u=o===ar(-e,r),h=o===ar(-e*Br,r);return l&&(i=a),(u||h)&&(i=c),(ar(i,r)&tr)===tr&&(i=ar(-i,r)),{isValid:l||u,value:i}}const qr=(()=>pr(Rr,void 0,!0))(),jr=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:qr,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Vr,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:kt,randomBytes:ut,adjustScalarBytes:Hr,uvRatio:zr}))(),Wr=(()=>function(e){const t=function(e){const t=_r(e);return Zt(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}(e),{Fp:r,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=t,l=Tr<<BigInt(8*a)-xr,u=r.create,h=pr(t.n,t.nBitLength),d=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:r.sqrt(e*r.inv(t))}}catch(e){return{isValid:!1,value:Cr}}}),p=t.adjustScalarBytes||(e=>e),f=t.domain||((e,t,r)=>{if(Tt("phflag",r),t.length||r)throw new Error("Contexts/pre-hash are not supported");return e});function g(e,t){jt("coordinate "+e,t,Cr,l)}function m(e){if(!(e instanceof b))throw new Error("ExtendedPoint expected")}const y=Xt(((e,t)=>{const{ex:n,ey:s,ez:i}=e,o=e.is0();null==t&&(t=o?Mr:r.inv(i));const a=u(n*t),c=u(s*t),l=u(i*t);if(o)return{x:Cr,y:xr};if(l!==xr)throw new Error("invZ was invalid");return{x:a,y:c}})),w=Xt((e=>{const{a:r,d:n}=t;if(e.is0())throw new Error("bad point: ZERO");const{ex:s,ey:i,ez:o,et:a}=e,c=u(s*s),l=u(i*i),h=u(o*o),d=u(h*h),p=u(c*r);if(u(h*u(p+l))!==u(d+u(n*u(c*l))))throw new Error("bad point: equation left != right (1)");if(u(s*i)!==u(o*a))throw new Error("bad point: equation left != right (2)");return!0}));class b{constructor(e,t,r,n){this.ex=e,this.ey=t,this.ez=r,this.et=n,g("x",e),g("y",t),g("z",r),g("t",n),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(e){if(e instanceof b)throw new Error("extended point not allowed");const{x:t,y:r}=e||{};return g("x",t),g("y",r),new b(t,r,xr,u(t*r))}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.ez)));return e.map(((e,r)=>e.toAffine(t[r]))).map(b.fromAffine)}static msm(e,t){return Ir(b,h,e,t)}_setWindowSize(e){E.setWindowSize(this,e)}assertValidity(){w(this)}equals(e){m(e);const{ex:t,ey:r,ez:n}=this,{ex:s,ey:i,ez:o}=e,a=u(t*o),c=u(s*n),l=u(r*o),h=u(i*n);return a===c&&l===h}is0(){return this.equals(b.ZERO)}negate(){return new b(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:e}=t,{ex:r,ey:n,ez:s}=this,i=u(r*r),o=u(n*n),a=u(Tr*u(s*s)),c=u(e*i),l=r+n,h=u(u(l*l)-i-o),d=c+o,p=d-a,f=c-o,g=u(h*p),m=u(d*f),y=u(h*f),w=u(p*d);return new b(g,m,w,y)}add(e){m(e);const{a:r,d:n}=t,{ex:s,ey:i,ez:o,et:a}=this,{ex:c,ey:l,ez:h,et:d}=e;if(r===BigInt(-1)){const e=u((i-s)*(l+c)),t=u((i+s)*(l-c)),r=u(t-e);if(r===Cr)return this.double();const n=u(o*Tr*d),p=u(a*Tr*h),f=p+n,g=t+e,m=p-n,y=u(f*r),w=u(g*m),v=u(f*m),S=u(r*g);return new b(y,w,S,v)}const p=u(s*c),f=u(i*l),g=u(a*n*d),y=u(o*h),w=u((s+i)*(c+l)-p-f),v=y-g,S=y+g,E=u(f-r*p),k=u(w*v),A=u(S*E),I=u(w*E),_=u(v*S);return new b(k,A,_,I)}subtract(e){return this.add(e.negate())}wNAF(e){return E.wNAFCached(this,e,b.normalizeZ)}multiply(e){const t=e;jt("scalar",t,xr,n);const{p:r,f:s}=this.wNAF(t);return b.normalizeZ([r,s])[0]}multiplyUnsafe(e,t=b.ZERO){const r=e;return jt("scalar",r,Cr,n),r===Cr?S:this.is0()||r===xr?this:E.wNAFCachedUnsafe(this,r,b.normalizeZ,t)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return E.unsafeLadder(this,n).is0()}toAffine(e){return y(this,e)}clearCofactor(){const{h:e}=t;return e===xr?this:this.multiplyUnsafe(e)}static fromHex(e,n=!1){const{d:s,a:i}=t,o=r.BYTES;e=$t("pointHex",e,o),Tt("zip215",n);const a=e.slice(),c=e[o-1];a[o-1]=-129&c;const h=Ut(a),p=n?l:r.ORDER;jt("pointHex.y",h,Cr,p);const f=u(h*h),g=u(f-xr),m=u(s*f-i);let{isValid:y,value:w}=d(g,m);if(!y)throw new Error("Point.fromHex: invalid y coordinate");const v=(w&xr)===xr,S=!!(128&c);if(!n&&w===Cr&&S)throw new Error("Point.fromHex: x=0 and x_0=1");return S!==v&&(w=u(-w)),b.fromAffine({x:w,y:h})}static fromPrivateKey(e){return I(e).point}toRawBytes(){const{x:e,y:t}=this.toAffine(),n=Vt(t,r.BYTES);return n[n.length-1]|=e&xr?128:0,n}toHex(){return Pt(this.toRawBytes())}}b.BASE=new b(t.Gx,t.Gy,xr,u(t.Gx*t.Gy)),b.ZERO=new b(Cr,xr,xr,Cr);const{BASE:v,ZERO:S}=b,E=Ar(b,8*a);function k(e){return ar(e,n)}function A(e){return k(Ut(e))}function I(e){const t=r.BYTES;e=$t("private key",e,t);const n=$t("hashed private key",i(e),2*t),s=p(n.slice(0,t)),o=n.slice(t,2*t),a=A(s),c=v.multiply(a),l=c.toRawBytes();return{head:s,prefix:o,scalar:a,point:c,pointBytes:l}}function _(e=new Uint8Array,...t){const r=Ht(...t);return A(i(f(r,$t("context",e),!!s)))}const C=Pr;return v._setWindowSize(8),{CURVE:t,getPublicKey:function(e){return I(e).pointBytes},sign:function(e,t,i={}){e=$t("message",e),s&&(e=s(e));const{prefix:o,scalar:a,pointBytes:c}=I(t),l=_(i.context,o,e),u=v.multiply(l).toRawBytes(),h=k(l+_(i.context,u,c,e)*a);return jt("signature.s",h,Cr,n),$t("result",Ht(u,Vt(h,r.BYTES)),2*r.BYTES)},verify:function(e,t,n,i=C){const{context:o,zip215:a}=i,c=r.BYTES;e=$t("signature",e,2*c),t=$t("message",t),n=$t("publicKey",n,c),void 0!==a&&Tt("zip215",a),s&&(t=s(t));const l=Ut(e.slice(c,2*c));let u,h,d;try{u=b.fromHex(n,a),h=b.fromHex(e.slice(0,c),a),d=v.multiplyUnsafe(l)}catch(e){return!1}if(!a&&u.isSmallOrder())return!1;const p=_(o,h.toRawBytes(),u.toRawBytes(),t);return h.add(u.multiplyUnsafe(p)).subtract(d).clearCofactor().equals(b.ZERO)},ExtendedPoint:b,utils:{getExtendedPublicKey:I,randomPrivateKey:()=>o(r.BYTES),precompute:(e=8,t=b.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)}}}(jr))(),Kr=(()=>function(e){const t=(Zt(r=e,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...r}));var r;const{P:n}=t,s=e=>ar(e,n),i=t.montgomeryBits,o=Math.ceil(i/8),a=t.nByteLength,c=t.adjustScalarBytes||(e=>e),l=t.powPminus2||(e=>cr(e,n-BigInt(2),n));function u(e,t,r){const n=s(e*(t-r));return[t=s(t-n),r=s(r+n)]}const h=(t.a-BigInt(2))/BigInt(4);function d(e){return Vt(s(e),o)}function p(e,t){const r=function(e){const t=$t("u coordinate",e,o);return 32===a&&(t[31]&=127),Ut(t)}(t),p=function(e){const t=$t("scalar",e),r=t.length;if(r!==o&&r!==a)throw new Error("invalid scalar, expected "+o+" or "+a+" bytes, got "+r);return Ut(c(t))}(e),f=function(e,t){jt("u",e,Dr,n),jt("scalar",t,Dr,n);const r=t,o=e;let a,c=Nr,d=Dr,p=e,f=Nr,g=Dr;for(let e=BigInt(i-1);e>=Dr;e--){const t=r>>e&Nr;g^=t,a=u(g,c,p),c=a[0],p=a[1],a=u(g,d,f),d=a[0],f=a[1],g=t;const n=c+d,i=s(n*n),l=c-d,m=s(l*l),y=i-m,w=p+f,b=s((p-f)*n),v=s(w*l),S=b+v,E=b-v;p=s(S*S),f=s(o*s(E*E)),c=s(i*m),d=s(y*(i+s(h*y)))}a=u(g,c,p),c=a[0],p=a[1],a=u(g,d,f),d=a[0],f=a[1];const m=l(d);return s(c*m)}(r,p);if(f===Dr)throw new Error("invalid private or public key received");return d(f)}const f=d(t.Gu);function g(e){return p(e,f)}return{scalarMult:p,scalarMultBase:g,getSharedSecret:(e,t)=>p(e,t),getPublicKey:e=>g(e),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:f}}({P:Rr,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:e=>{const t=Rr,{pow_p_5_8:r,b2:n}=$r(e);return ar(lr(r,Ur,t)*n,t)},adjustScalarBytes:Hr,randomBytes:ut}))();function Gr(e,t){const r=new Uint8Array(64);for(let n=0;n<32;n++)r[n]=e[n],r[32+n]=t[n];return r}class Yr{type="Ed25519";raw;constructor(e){this.raw=Zr(e,32)}toMultihash(){return Xe.digest(ja(this))}toCID(){return Ke.createV1(114,this.toMultihash())}toString(){return ue.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&et(this.raw,e.raw)}verify(e,t){return function(e,t,r){return Wr.verify(t,r instanceof Uint8Array?r:r.subarray(),e)}(this.raw,t,e)}}class Jr{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Zr(e,64),this.publicKey=new Yr(t)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&et(this.raw,e.raw)}sign(e){return function(e,t){const r=e.subarray(0,32);return Wr.sign(t instanceof Uint8Array?t:t.subarray(),r)}(this.raw,e)}}function Qr(e){return e=Zr(e,32),new Yr(e)}function Zr(e,t){if((e=Uint8Array.from(e??[])).length!==t)throw new M(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}function Xr(e=0){return new Uint8Array(e)}function en(e=0){return new Uint8Array(e)}const tn=Math.pow(2,7),rn=Math.pow(2,14),nn=Math.pow(2,21),sn=Math.pow(2,28),on=Math.pow(2,35),an=Math.pow(2,42),cn=Math.pow(2,49),ln=128,un=127;function hn(e){if(e<tn)return 1;if(e<rn)return 2;if(e<nn)return 3;if(e<sn)return 4;if(e<on)return 5;if(e<an)return 6;if(e<cn)return 7;if(null!=Number.MAX_SAFE_INTEGER&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function dn(e,t,r=0){switch(hn(e)){case 8:t[r++]=255&e|ln,e/=128;case 7:t[r++]=255&e|ln,e/=128;case 6:t[r++]=255&e|ln,e/=128;case 5:t[r++]=255&e|ln,e/=128;case 4:t[r++]=255&e|ln,e>>>=7;case 3:t[r++]=255&e|ln,e>>>=7;case 2:t[r++]=255&e|ln,e>>>=7;case 1:t[r++]=255&e,e>>>=7;break;default:throw new Error("unreachable")}return t}function pn(e,t){let r=e[t],n=0;if(n+=r&un,r<ln)return n;if(r=e[t+1],n+=(r&un)<<7,r<ln)return n;if(r=e[t+2],n+=(r&un)<<14,r<ln)return n;if(r=e[t+3],n+=(r&un)<<21,r<ln)return n;if(r=e[t+4],n+=(r&un)*sn,r<ln)return n;if(r=e[t+5],n+=(r&un)*on,r<ln)return n;if(r=e[t+6],n+=(r&un)*an,r<ln)return n;if(r=e[t+7],n+=(r&un)*cn,r<ln)return n;throw new RangeError("Could not decode varint")}function fn(e,t,r=0){return null==t&&(t=en(hn(e))),t instanceof Uint8Array?dn(e,t,r):function(e,t,r=0){switch(hn(e)){case 8:t.set(r++,255&e|ln),e/=128;case 7:t.set(r++,255&e|ln),e/=128;case 6:t.set(r++,255&e|ln),e/=128;case 5:t.set(r++,255&e|ln),e/=128;case 4:t.set(r++,255&e|ln),e>>>=7;case 3:t.set(r++,255&e|ln),e>>>=7;case 2:t.set(r++,255&e|ln),e>>>=7;case 1:t.set(r++,255&e),e>>>=7;break;default:throw new Error("unreachable")}return t}(e,t,r)}function gn(e,t=0){return e instanceof Uint8Array?pn(e,t):function(e,t){let r=e.get(t),n=0;if(n+=r&un,r<ln)return n;if(r=e.get(t+1),n+=(r&un)<<7,r<ln)return n;if(r=e.get(t+2),n+=(r&un)<<14,r<ln)return n;if(r=e.get(t+3),n+=(r&un)<<21,r<ln)return n;if(r=e.get(t+4),n+=(r&un)*sn,r<ln)return n;if(r=e.get(t+5),n+=(r&un)*on,r<ln)return n;if(r=e.get(t+6),n+=(r&un)*an,r<ln)return n;if(r=e.get(t+7),n+=(r&un)*cn,r<ln)return n;throw new RangeError("Could not decode varint")}(e,t)}const mn=new Float32Array([-0]),yn=new Uint8Array(mn.buffer);function wn(e,t,r){mn[0]=e,t[r]=yn[0],t[r+1]=yn[1],t[r+2]=yn[2],t[r+3]=yn[3]}const bn=new Float64Array([-0]),vn=new Uint8Array(bn.buffer);function Sn(e,t,r){bn[0]=e,t[r]=vn[0],t[r+1]=vn[1],t[r+2]=vn[2],t[r+3]=vn[3],t[r+4]=vn[4],t[r+5]=vn[5],t[r+6]=vn[6],t[r+7]=vn[7]}const En=BigInt(Number.MAX_SAFE_INTEGER),kn=BigInt(Number.MIN_SAFE_INTEGER);class An{lo;hi;constructor(e,t){this.lo=0|e,this.hi=0|t}toNumber(e=!1){if(!e&&this.hi>>>31>0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(e+4294967296*t)}return this.lo+4294967296*this.hi}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31!=0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(BigInt(e)+(BigInt(t)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return 0===r?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(0n===e)return In;if(e<En&&e>kn)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,n=e-(r<<32n);return t&&(r=0n|~r,n=0n|~n,++n>_n&&(n=0n,++r>_n&&(r=0n))),new An(Number(n),Number(r))}static fromNumber(e){if(0===e)return In;const t=e<0;t&&(e=-e);let r=e>>>0,n=(e-r)/4294967296>>>0;return t&&(n=~n>>>0,r=~r>>>0,++r>4294967295&&(r=0,++n>4294967295&&(n=0))),new An(r,n)}static from(e){return"number"==typeof e?An.fromNumber(e):"bigint"==typeof e?An.fromBigInt(e):"string"==typeof e?An.fromBigInt(BigInt(e)):null!=e.low||null!=e.high?new An(e.low>>>0,e.high>>>0):In}}const In=new An(0,0);In.toBigInt=function(){return 0n},In.zzEncode=In.zzDecode=function(){return this},In.length=function(){return 1};const _n=4294967296n;function Cn(e,t,r){const n=r;let s,i;for(let n=0;n<e.length;++n)s=e.charCodeAt(n),s<128?t[r++]=s:s<2048?(t[r++]=s>>6|192,t[r++]=63&s|128):55296==(64512&s)&&56320==(64512&(i=e.charCodeAt(n+1)))?(s=65536+((1023&s)<<10)+(1023&i),++n,t[r++]=s>>18|240,t[r++]=s>>12&63|128,t[r++]=s>>6&63|128,t[r++]=63&s|128):(t[r++]=s>>12|224,t[r++]=s>>6&63|128,t[r++]=63&s|128);return r-n}function xn(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function Tn(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class Mn{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return e;if((this.pos+=5)>this.len)throw this.pos=this.len,xn(this,10);return e}int32(){return 0|this.uint32()}sint32(){const e=this.uint32();return e>>>1^-(1&e)}bool(){return 0!==this.uint32()}fixed32(){if(this.pos+4>this.len)throw xn(this,4);return Tn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw xn(this,4);return 0|Tn(this.buf,this.pos+=4)}float(){if(this.pos+4>this.len)throw xn(this,4);const e=function(e,t){return yn[0]=e[t],yn[1]=e[t+1],yn[2]=e[t+2],yn[3]=e[t+3],mn[0]}(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw xn(this,4);const e=function(e,t){return vn[0]=e[t],vn[1]=e[t+1],vn[2]=e[t+2],vn[3]=e[t+3],vn[4]=e[t+4],vn[5]=e[t+5],vn[6]=e[t+6],vn[7]=e[t+7],bn[0]}(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw xn(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return function(e,t,r){if(r-t<1)return"";let n;const s=[];let i,o=0;for(;t<r;)i=e[t++],i<128?s[o++]=i:i>191&&i<224?s[o++]=(31&i)<<6|63&e[t++]:i>239&&i<365?(i=((7&i)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,s[o++]=55296+(i>>10),s[o++]=56320+(1023&i)):s[o++]=(15&i)<<12|(63&e[t++])<<6|63&e[t++],o>8191&&((n??(n=[])).push(String.fromCharCode.apply(String,s)),o=0);return null!=n?(o>0&&n.push(String.fromCharCode.apply(String,s.slice(0,o))),n.join("")):String.fromCharCode.apply(String,s.slice(0,o))}(e,0,e.length)}skip(e){if("number"==typeof e){if(this.pos+e>this.len)throw xn(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw xn(this)}while(128&this.buf[this.pos++]);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new An(0,0);let t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw xn(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw xn(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw xn(this,8);const e=Tn(this.buf,this.pos+=4),t=Tn(this.buf,this.pos+=4);return new An(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=pn(this.buf,this.pos);return this.pos+=hn(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Pn(e,t,r){const n=function(e){return new Mn(e instanceof Uint8Array?e:e.subarray())}(e);return t.decode(n,void 0,r)}const Dn=ce({prefix:"9",name:"base10",alphabet:"0123456789"}),Nn=le({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Rn=le({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Bn=le({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Ln=Array.from(""),On=Ln.reduce(((e,t,r)=>(e[r]=t,e)),[]),Un=Ln.reduce(((e,t,r)=>{const n=t.codePointAt(0);if(null==n)throw new Error(`Invalid character: ${t}`);return e[n]=r,e}),[]),Fn=ae({prefix:"",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+On[t]),"")},decode:function(e){const t=[];for(const r of e){const e=r.codePointAt(0);if(null==e)throw new Error(`Invalid character: ${r}`);const n=Un[e];if(null==n)throw new Error(`Non-base256emoji character: ${r}`);t.push(n)}return new Uint8Array(t)}}),Vn=le({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),$n=le({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Hn=le({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),zn=le({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),qn=le({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),jn=ae({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>function(e){return(new TextEncoder).encode(e)}(e)}),Wn=new TextEncoder,Kn=new TextDecoder,Gn="json",Yn=512;function Jn(e){return Wn.encode(JSON.stringify(e))}function Qn(e){return JSON.parse(Kn.decode(e))}const Zn="raw",Xn=85;function es(e){return ee(e)}function ts(e){return ee(e)}function rs({name:e,code:t,encode:r}){return new ns(e,t,r)}class ns{name;code;encode;constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?$e(this.code,t):t.then((e=>$e(this.code,e)))}throw Error("Unknown type, must be binary type")}}function ss(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}const is=rs({name:"sha2-256",code:18,encode:ss("SHA-256")}),os=rs({name:"sha2-512",code:19,encode:ss("SHA-512")}),as={...f,...u,...p,...c,...l,...s,...i,...n,...d,...h};function cs(e,t,r,n){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:r},decoder:{decode:n}}}const ls=cs("utf8","u",(e=>"u"+new TextDecoder("utf8").decode(e)),(e=>(new TextEncoder).encode(e.substring(1)))),us=cs("ascii","a",(e=>{let t="a";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t}),(e=>{const t=en((e=e.substring(1)).length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t})),hs={utf8:ls,"utf-8":ls,hex:as.base16,latin1:us,ascii:us,binary:us,...as};function ds(e,t="utf8"){const r=hs[t];if(null==r)throw new Error(`Unsupported encoding "${t}"`);return r.decoder.decode(`${r.prefix}${e}`)}class ps{fn;len;next;val;constructor(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}}function fs(){}class gs{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const ms=function(){const e=8192;let t,r=e;return function(n){if(n<1||n>4096)return en(n);r+n>e&&(t=en(e),r=0);const s=t.subarray(r,r+=n);return 7&r&&(r=1+(7|r)),s}}();class ys{len;head;tail;states;constructor(){this.len=0,this.head=new ps(fs,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new ps(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new vs((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Ss,10,An.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=An.fromBigInt(e);return this._push(Ss,t.length(),t)}uint64Number(e){return this._push(dn,hn(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=An.fromBigInt(e).zzEncode();return this._push(Ss,t.length(),t)}sint64Number(e){const t=An.fromNumber(e).zzEncode();return this._push(Ss,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(ws,1,e?1:0)}fixed32(e){return this._push(Es,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=An.fromBigInt(e);return this._push(Es,4,t.lo)._push(Es,4,t.hi)}fixed64Number(e){const t=An.fromNumber(e);return this._push(Es,4,t.lo)._push(Es,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(wn,4,e)}double(e){return this._push(Sn,8,e)}bytes(e){const t=e.length>>>0;return 0===t?this._push(ws,1,0):this.uint32(t)._push(ks,t,e)}string(e){const t=function(e){let t=0,r=0;for(let n=0;n<e.length;++n)r=e.charCodeAt(n),r<128?t+=1:r<2048?t+=2:55296==(64512&r)&&56320==(64512&e.charCodeAt(n+1))?(++n,t+=4):t+=3;return t}(e);return 0!==t?this.uint32(t)._push(Cn,t,e):this._push(ws,1,0)}fork(){return this.states=new gs(this),this.head=this.tail=new ps(fs,0,0),this.len=0,this}reset(){return null!=this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ps(fs,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),0!==r&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const t=(r=this.len,null!=globalThis.Buffer?en(r):ms(r));var r;let n=0;for(;null!=e;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function ws(e,t,r){t[r]=255&e}function bs(e,t,r){for(;e>127;)t[r++]=127&e|128,e>>>=7;t[r]=e}class vs extends ps{next;constructor(e,t){super(bs,e,t),this.next=void 0}}function Ss(e,t,r){for(;0!==e.hi;)t[r++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[r++]=127&e.lo|128,e.lo=e.lo>>>7;t[r++]=e.lo}function Es(e,t,r){t[r]=255&e,t[r+1]=e>>>8&255,t[r+2]=e>>>16&255,t[r+3]=e>>>24}function ks(e,t,r){t.set(e,r)}function As(e,t,r){t.set(e,r)}function Is(e,t,r){e.length<40?Cn(e,t,r):null!=t.utf8Write?t.utf8Write(e,r):t.set(ds(e),r)}function _s(e,t){const r=new ys;return t.encode(e,r,{lengthDelimited:!1}),r.finish()}var Cs,xs,Ts,Ms,Ps;function Ds(e,t,r,n){return{name:e,type:t,encode:r,decode:n}}function Ns(e){function t(t){if(null==e[t.toString()])throw new Error("Invalid enum value");return e[t]}return Ds("enum",Cs.VARINT,(function(e,r){const n=t(e);r.int32(n)}),(function(e){return t(e.int32())}))}function Rs(e,t){return Ds("message",Cs.LENGTH_DELIMITED,e,t)}null!=globalThis.Buffer&&(ys.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(As,t,e),this},ys.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(Is,t,e),this}),function(e){e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"}(Cs||(Cs={})),Error;class Bs extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Ls extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}function Os(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Us(e,...t){if(!((r=e)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Fs(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");Os(e.outputLen),Os(e.blockLen)}function Vs(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}!function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1"}(xs||(xs={})),function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1"}(Ts||(Ts={})),function(e){e.codec=()=>Ns(Ts)}(xs||(xs={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),xs.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.Type=xs.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Ms||(Ms={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),xs.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.Type=xs.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Ps||(Ps={}));const $s="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,Hs=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),zs=(e,t)=>e<<32-t|e>>>t;function qs(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),Us(e),e}class js{clone(){return this._cloneInto()}}function Ws(e){const t=t=>e().update(qs(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}const Ks=(e,t,r)=>e&t^e&r^t&r;class Gs extends js{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Hs(this.buffer)}update(e){Vs(this);const{view:t,buffer:r,blockLen:n}=this,s=(e=qs(e)).length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o!==n)r.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=Hs(e);for(;n<=s-i;i+=n)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){Vs(this),function(e,t){Us(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:s}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i),c=n?4:0,l=n?0:4;e.setUint32(t+c,o,n),e.setUint32(t+l,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const o=Hs(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,l=this.get();if(c>l.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)o.setUint32(4*e,l[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:s,destroyed:i,pos:o}=this;return e.length=n,e.pos=o,e.finished=s,e.destroyed=i,n%t&&e.buffer.set(r),e}}const Ys=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Js=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Qs=new Uint32Array(64);class Zs extends Gs{constructor(){super(64,32,8,!1),this.A=0|Js[0],this.B=0|Js[1],this.C=0|Js[2],this.D=0|Js[3],this.E=0|Js[4],this.F=0|Js[5],this.G=0|Js[6],this.H=0|Js[7]}get(){const{A:e,B:t,C:r,D:n,E:s,F:i,G:o,H:a}=this;return[e,t,r,n,s,i,o,a]}set(e,t,r,n,s,i,o,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|i,this.G=0|o,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)Qs[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=Qs[e-15],r=Qs[e-2],n=zs(t,7)^zs(t,18)^t>>>3,s=zs(r,17)^zs(r,19)^r>>>10;Qs[e]=s+Qs[e-7]+n+Qs[e-16]|0}let{A:r,B:n,C:s,D:i,E:o,F:a,G:c,H:l}=this;for(let e=0;e<64;e++){const t=l+(zs(o,6)^zs(o,11)^zs(o,25))+((u=o)&a^~u&c)+Ys[e]+Qs[e]|0,h=(zs(r,2)^zs(r,13)^zs(r,22))+Ks(r,n,s)|0;l=c,c=a,a=o,o=i+t|0,i=s,s=n,n=r,r=t+h|0}var u;r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,l=l+this.H|0,this.set(r,n,s,i,o,a,c,l)}roundClean(){Qs.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Xs=Ws((()=>new Zs));var ei=r(152);function ti(e,t){let r=0;if(1===e.length)return e[0];for(let n=e.length-1;n>=0;n--)r+=e[e.length-1-n]*Math.pow(2,t*n);return r}function ri(e,t,r=-1){const n=r;let s=e,i=0,o=Math.pow(2,t);for(let r=1;r<8;r++){if(e<o){let e;if(n<0)e=new ArrayBuffer(r),i=r;else{if(n<r)return new ArrayBuffer(0);e=new ArrayBuffer(n),i=n}const o=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);o[i-e-1]=Math.floor(s/r),s-=o[i-e-1]*r}return e}o*=Math.pow(2,t)}return new ArrayBuffer(0)}function ni(...e){let t=0,r=0;for(const r of e)t+=r.length;const n=new ArrayBuffer(t),s=new Uint8Array(n);for(const t of e)s.set(t,r),r+=t.length;return s}function si(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&!(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const n=ti(r,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];return i[0]&=127,ti(i,8)-n}function ii(e,t){const r=e.toString(10);if(t<r.length)return"";const n=t-r.length,s=new Array(n);for(let e=0;e<n;e++)s[e]="0";return s.join("").concat(r)}function oi(){if("undefined"==typeof BigInt)throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function ai(e){let t=0,r=0;for(let r=0;r<e.length;r++)t+=e[r].byteLength;const n=new Uint8Array(t);for(let t=0;t<e.length;t++){const s=e[t];n.set(new Uint8Array(s),r),r+=s.byteLength}return n.buffer}function ci(e,t,r,n){return t instanceof Uint8Array?t.byteLength?r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):n<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-n<0&&(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1)):(e.error="Wrong parameter: inputBuffer has zero length",!1):(e.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}Math.log(2);class li{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return ai(this.items)}}const ui=[new Uint8Array([1])],hi="0123456789",di=new ArrayBuffer(0),pi=new Uint8Array(0),fi="EndOfContent",gi="OCTET STRING",mi="BIT STRING";function yi(e){var t;return(t=class extends e{constructor(...e){var t;super(...e);const r=e[0]||{};this.isHexOnly=null!==(t=r.isHexOnly)&&void 0!==t&&t,this.valueHexView=r.valueHex?ei._H.toUint8Array(r.valueHex):pi}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(e){this.valueHexView=new Uint8Array(e)}fromBER(e,t,r){const n=e instanceof ArrayBuffer?new Uint8Array(e):e;if(!ci(this,n,t,r))return-1;const s=t+r;return this.valueHexView=n.subarray(t,s),this.valueHexView.length?(this.blockLength=r,s):(this.warnings.push("Zero buffer length"),t)}toBER(e=!1){return this.isHexOnly?e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",di)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:ei.U$.ToHex(this.valueHexView)}}}).NAME="hexBlock",t}class wi{constructor({blockLength:e=0,error:t="",warnings:r=[],valueBeforeDecode:n=pi}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=ei._H.toUint8Array(n)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:ei.U$.ToHex(this.valueBeforeDecodeView)}}}wi.NAME="baseBlock";class bi extends wi{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}bi.NAME="valueBlock";class vi extends(yi(wi)){constructor({idBlock:e={}}={}){var t,r,n,s;super(),e?(this.isHexOnly=null!==(t=e.isHexOnly)&&void 0!==t&&t,this.valueHexView=e.valueHex?ei._H.toUint8Array(e.valueHex):pi,this.tagClass=null!==(r=e.tagClass)&&void 0!==r?r:-1,this.tagNumber=null!==(n=e.tagNumber)&&void 0!==n?n:-1,this.isConstructed=null!==(s=e.isConstructed)&&void 0!==s&&s):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",di}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const r=new Uint8Array(1);if(!e){let e=this.tagNumber;e&=31,t|=e,r[0]=t}return r.buffer}if(!this.isHexOnly){const r=ri(this.tagNumber,7),n=new Uint8Array(r),s=r.byteLength,i=new Uint8Array(s+1);if(i[0]=31|t,!e){for(let e=0;e<s-1;e++)i[e+1]=128|n[e];i[s]=n[s-1]}return i.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=31|t,!e){const e=this.valueHexView;for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHexView.byteLength]=e[e.length-1]}return r.buffer}fromBER(e,t,r){const n=ei._H.toUint8Array(e);if(!ci(this,n,t,r))return-1;const s=n.subarray(t,t+r);if(0===s.length)return this.error="Zero buffer length",-1;switch(192&s[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=!(32&~s[0]),this.isHexOnly=!1;const i=31&s[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let e=1,t=this.valueHexView=new Uint8Array(255),r=255;for(;128&s[e];){if(t[e-1]=127&s[e],e++,e>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(e===r){r+=255;const e=new Uint8Array(r);for(let r=0;r<t.length;r++)e[r]=t[r];t=this.valueHexView=new Uint8Array(r)}}this.blockLength=e+1,t[e-1]=127&s[e];const n=new Uint8Array(e);for(let r=0;r<e;r++)n[r]=t[r];t=this.valueHexView=new Uint8Array(e),t.set(n),this.blockLength<=9?this.tagNumber=ti(t,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}vi.NAME="identificationBlock";class Si extends wi{constructor({lenBlock:e={}}={}){var t,r,n;super(),this.isIndefiniteForm=null!==(t=e.isIndefiniteForm)&&void 0!==t&&t,this.longFormUsed=null!==(r=e.longFormUsed)&&void 0!==r&&r,this.length=null!==(n=e.length)&&void 0!==n?n:0}fromBER(e,t,r){const n=ei._H.toUint8Array(e);if(!ci(this,n,t,r))return-1;const s=n.subarray(t,t+r);if(0===s.length)return this.error="Zero buffer length",-1;if(255===s[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===s[0],this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&s[0]),!1===this.longFormUsed)return this.length=s[0],this.blockLength=1,t+this.blockLength;const i=127&s[0];if(i>8)return this.error="Too big integer",-1;if(i+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const o=t+1,a=n.subarray(o,o+i);return 0===a[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=ti(a,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const n=ri(this.length,8);if(n.byteLength>127)return this.error="Too big length",di;if(t=new ArrayBuffer(n.byteLength+1),e)return t;const s=new Uint8Array(n);r=new Uint8Array(t),r[0]=128|n.byteLength;for(let e=0;e<n.byteLength;e++)r[e+1]=s[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}Si.NAME="lengthBlock";const Ei={};class ki extends wi{constructor({name:e="",optional:t=!1,primitiveSchema:r,...n}={},s){super(n),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new vi(n),this.lenBlock=new Si(n),this.valueBlock=s?new s(n):new bi(n)}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}toBER(e,t){const r=t||new li;t||Ai(this);const n=this.idBlock.toBER(e);if(r.write(n),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const t=this.valueBlock.toBER(e);this.lenBlock.length=t.byteLength;const n=this.lenBlock.toBER(e);r.write(n),r.write(t)}return t?di:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return"ascii"===e?this.onAsciiEncoding():ei.U$.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${ei.U$.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){return this===e||e instanceof this.constructor&&function(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),n=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==n[e])return!1;return!0}(this.toBER(),e.toBER())}}function Ai(e){if(e instanceof Ei.Constructed)for(const t of e.valueBlock.value)Ai(t)&&(e.lenBlock.isIndefiniteForm=!0);return!!e.lenBlock.isIndefiniteForm}ki.NAME="BaseBlock";class Ii extends ki{constructor({value:e="",...t}={},r){super(t,r),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,r){const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}Ii.NAME="BaseStringBlock";class _i extends(yi(bi)){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}var Ci,xi,Ti,Mi,Pi,Di,Ni,Ri,Bi,Li,Oi,Ui,Fi,Vi,$i,Hi,zi,qi,ji,Wi,Ki,Gi,Yi,Ji,Qi,Zi,Xi,eo,to,ro,no,so,io;_i.NAME="PrimitiveValueBlock";class oo extends ki{constructor(e={}){super(e,_i),this.idBlock.isConstructed=!1}}function ao(e,t=0,r=e.length){const n=t;let s=new ki({},bi);const i=new wi;if(!ci(i,e,t,r))return s.error=i.error,{offset:-1,result:s};if(!e.subarray(t,t+r).length)return s.error="Zero buffer length",{offset:-1,result:s};let o=s.idBlock.fromBER(e,t,r);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),-1===o)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=o,r-=s.idBlock.blockLength,o=s.lenBlock.fromBER(e,t,r),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),-1===o)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=o,r-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let a=ki;if(1===s.idBlock.tagClass){if(s.idBlock.tagNumber>=37&&!1===s.idBlock.isHexOnly)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};a=Ei.EndOfContent;break;case 1:a=Ei.Boolean;break;case 2:a=Ei.Integer;break;case 3:a=Ei.BitString;break;case 4:a=Ei.OctetString;break;case 5:a=Ei.Null;break;case 6:a=Ei.ObjectIdentifier;break;case 10:a=Ei.Enumerated;break;case 12:a=Ei.Utf8String;break;case 13:a=Ei.RelativeObjectIdentifier;break;case 14:a=Ei.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:a=Ei.Sequence;break;case 17:a=Ei.Set;break;case 18:a=Ei.NumericString;break;case 19:a=Ei.PrintableString;break;case 20:a=Ei.TeletexString;break;case 21:a=Ei.VideotexString;break;case 22:a=Ei.IA5String;break;case 23:a=Ei.UTCTime;break;case 24:a=Ei.GeneralizedTime;break;case 25:a=Ei.GraphicString;break;case 26:a=Ei.VisibleString;break;case 27:a=Ei.GeneralString;break;case 28:a=Ei.UniversalString;break;case 29:a=Ei.CharacterString;break;case 30:a=Ei.BmpString;break;case 31:a=Ei.DATE;break;case 32:a=Ei.TimeOfDay;break;case 33:a=Ei.DateTime;break;case 34:a=Ei.Duration;break;default:{const e=s.idBlock.isConstructed?new Ei.Constructed:new Ei.Primitive;e.idBlock=s.idBlock,e.lenBlock=s.lenBlock,e.warnings=s.warnings,s=e}}}else a=s.idBlock.isConstructed?Ei.Constructed:Ei.Primitive;return s=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecodeView=e.valueBeforeDecodeView,r}(s,a),o=s.fromBER(e,t,s.lenBlock.isIndefiniteForm?r:s.lenBlock.length),s.valueBeforeDecodeView=e.subarray(n,n+s.blockLength),{offset:o,result:s}}Ci=oo,Ei.Primitive=Ci,oo.NAME="PRIMITIVE";class co extends bi{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const n=ei._H.toUint8Array(e);if(!ci(this,n,t,r))return-1;if(this.valueBeforeDecodeView=n.subarray(t,t+r),0===this.valueBeforeDecodeView.length)return this.warnings.push("Zero buffer length"),t;let s=t;for(;(this.isIndefiniteForm?1:r)>0;){const e=ao(n,s,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(s=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),this.isIndefiniteForm&&e.result.constructor.NAME===fi)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===fi?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){const r=t||new li;for(let t=0;t<this.value.length;t++)this.value[t].toBER(e,r);return t?di:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}co.NAME="ConstructedValueBlock";class lo extends ki{constructor(e={}){super(e,co),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){const e=[];for(const t of this.valueBlock.value)e.push(t.toString("ascii").split("\n").map((e=>`  ${e}`)).join("\n"));const t=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :\n${e.join("\n")}`:`${t} :`}}xi=lo,Ei.Constructed=xi,lo.NAME="CONSTRUCTED";class uo extends bi{fromBER(e,t,r){return t}toBER(e){return di}}uo.override="EndOfContentValueBlock";class ho extends ki{constructor(e={}){super(e,uo),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}Ti=ho,Ei.EndOfContent=Ti,ho.NAME=fi;class po extends ki{constructor(e={}){super(e,bi),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const e=new Uint8Array(r);e[0]=5,e[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}Mi=po,Ei.Null=Mi,po.NAME="NULL";class fo extends(yi(bi)){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=ei._H.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,r){const n=ei._H.toUint8Array(e);return ci(this,n,t,r)?(this.valueHexView=n.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,si.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}fo.NAME="BooleanValueBlock";class go extends ki{constructor(e={}){super(e,fo),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}Pi=go,Ei.Boolean=Pi,go.NAME="BOOLEAN";class mo extends(yi(co)){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let n=0;if(this.isConstructed){if(this.isHexOnly=!1,n=co.prototype.fromBER.call(this,e,t,r),-1===n)return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.NAME;if(t===fi){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==gi)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(e,t,r),this.blockLength=r;return n}toBER(e,t){return this.isConstructed?co.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}mo.NAME="OctetStringValueBlock";class yo extends ki{constructor({idBlock:e={},lenBlock:t={},...r}={}){var n,s;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(s=r.value)||void 0===s?void 0:s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},mo),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const n=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(n.byteLength){const e=ao(n,0,n.byteLength);-1!==e.offset&&e.offset===r&&(this.valueBlock.value=[e.result])}}catch(e){}}return super.fromBER(e,t,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?lo.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${ei.U$.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof yo&&e.push(t.valueBlock.valueHexView);return ei._H.concat(e)}}Di=yo,Ei.OctetString=Di,yo.NAME=gi;class wo extends(yi(co)){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let n=-1;if(this.isConstructed){if(n=co.prototype.fromBER.call(this,e,t,r),-1===n)return n;for(const e of this.value){const t=e.constructor.NAME;if(t===fi){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==mi)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const r=e.valueBlock;if(this.unusedBits>0&&r.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=r.unusedBits}return n}const s=ei._H.toUint8Array(e);if(!ci(this,s,t,r))return-1;const i=s.subarray(t,t+r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const e=i.subarray(1);try{if(e.byteLength){const t=ao(e,0,e.byteLength);-1!==t.offset&&t.offset===r-1&&(this.value=[t.result])}}catch(e){}}return this.valueHexView=i.subarray(1),this.blockLength=i.length,t+r}toBER(e,t){if(this.isConstructed)return co.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return di;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}wo.NAME="BitStringValueBlock";class bo extends ki{constructor({idBlock:e={},lenBlock:t={},...r}={}){var n,s;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(s=r.value)||void 0===s?void 0:s.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},wo),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return lo.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const r of t)e.push(r.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}}function vo(e,t){const r=new Uint8Array([0]),n=new Uint8Array(e),s=new Uint8Array(t);let i=n.slice(0);const o=i.length-1,a=s.slice(0),c=a.length-1;let l=0,u=0;for(let e=c<o?o:c;e>=0;e--,u++)l=1==u<a.length?i[o-u]+a[c-u]+r[0]:i[o-u]+r[0],r[0]=l/10,1==u>=i.length?i=ni(new Uint8Array([l%10]),i):i[o-u]=l%10;return r[0]>0&&(i=ni(r,i)),i}function So(e){if(e>=ui.length)for(let t=ui.length;t<=e;t++){const e=new Uint8Array([0]);let r=ui[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const n=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=n[0]/10,r[t]=n[0]%10}e[0]>0&&(r=ni(e,r)),ui.push(r)}return ui[e]}function Eo(e,t){let r=0;const n=new Uint8Array(e),s=new Uint8Array(t),i=n.slice(0),o=i.length-1,a=s.slice(0),c=a.length-1;let l,u=0;for(let e=c;e>=0;e--,u++)l=i[o-u]-a[c-u]-r,1==l<0?(r=1,i[o-u]=l+10):(r=0,i[o-u]=l);if(r>0)for(let e=o-c+1;e>=0;e--,u++){if(l=i[o-u]-r,!(l<0)){r=0,i[o-u]=l;break}r=1,i[o-u]=l+10}return i.slice()}Ni=bo,Ei.BitString=Ni,bo.NAME=mi;class ko extends(yi(bi)){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),void 0!==e&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=si.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(function(e){const t=e<0?-1*e:e;let r=128;for(let n=1;n<8;n++){if(t<=r){if(e<0){const e=ri(r-t,8,n);return new Uint8Array(e)[0]|=128,e}let s=ri(t,8,n),i=new Uint8Array(s);if(128&i[0]){const e=s.slice(0),t=new Uint8Array(e);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return s}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,n=0){const s=this.fromBER(e,t,r);if(-1===s)return s;const i=this.valueHexView;return 0===i[0]&&128&i[1]?this.valueHexView=i.subarray(1):0!==n&&i.length<n&&(n-i.length>1&&(n=i.length+1),this.valueHexView=i.subarray(n-i.length)),s}toDER(e=!1){const t=this.valueHexView;switch(!0){case!!(128&t[0]):{const e=new Uint8Array(this.valueHexView.length+1);e[0]=0,e.set(t,1),this.valueHexView=e}break;case 0===t[0]&&!(128&t[1]):this.valueHexView=this.valueHexView.subarray(1)}return this.toBER(e)}fromBER(e,t,r){const n=super.fromBER(e,t,r);return-1===n||this.setValueHex(),n}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=8*this.valueHexView.length-1;let t,r=new Uint8Array(8*this.valueHexView.length/3),n=0;const s=this.valueHexView;let i="",o=!1;for(let o=s.byteLength-1;o>=0;o--){t=s[o];for(let s=0;s<8;s++)1&~t||(n===e?(r=Eo(So(n),r),i="-"):r=vo(r,So(n))),n++,t>>=1}for(let e=0;e<r.length;e++)r[e]&&(o=!0),o&&(i+=hi.charAt(r[e]));return!1===o&&(i+=hi.charAt(0)),i}}Ri=ko,ko.NAME="IntegerValueBlock",Object.defineProperty(Ri.prototype,"valueHex",{set:function(e){this.valueHexView=new Uint8Array(e),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});class Ao extends ki{constructor(e={}){super(e,ko),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return oi(),BigInt(this.valueBlock.toString())}static fromBigInt(e){oi();const t=BigInt(e),r=new li,n=t.toString(16).replace(/^-/,""),s=new Uint8Array(ei.U$.FromHex(n));if(t<0){const e=new Uint8Array(s.length+(128&s[0]?1:0));e[0]|=128;const n=BigInt(`0x${ei.U$.ToHex(e)}`)+t,i=ei._H.toUint8Array(ei.U$.FromHex(n.toString(16)));i[0]|=128,r.write(i)}else 128&s[0]&&r.write(new Uint8Array([0])),r.write(s);return new Ao({valueHex:r.final()})}convertToDER(){const e=new Ao({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new Ao({valueHex:0===this.valueBlock.valueHexView[0]?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}Bi=Ao,Ei.Integer=Bi,Ao.NAME="INTEGER";class Io extends Ao{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}Li=Io,Ei.Enumerated=Li,Io.NAME="ENUMERATED";class _o extends(yi(bi)){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const n=ei._H.toUint8Array(e);if(!ci(this,n,t,r))return-1;const s=n.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&s[e],this.blockLength++,128&s[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&s[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=ti(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){oi();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let e=0;e<r.length;e++)r[e]=parseInt(t.slice(7*e,7*e+7),2)+(e+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=ri(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",di;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),n=t.byteLength-1;for(let t=0;t<n;t++)r[t]=128|e[t];r[n]=e[n]}return r}toString(){let e="";if(this.isHexOnly)e=ei.U$.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}_o.NAME="sidBlock";class Co extends bi{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let n=t;for(;r>0;){const t=new _o;if(n=t.fromBER(e,n,r),-1===n)return this.blockLength=0,this.error=t.error,n;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);if(0===n.byteLength)return this.error=this.value[r].error,di;t.push(n)}return ai(t)}fromString(e){this.value=[];let t=0,r=0,n="",s=!1;do{if(r=e.indexOf(".",t),n=-1===r?e.substring(t):e.substring(t,r),t=r+1,s){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return void(this.value=[])}const r=parseInt(n,10);if(isNaN(r))return;e.valueDec=r+t,s=!1}else{const e=new _o;if(n>Number.MAX_SAFE_INTEGER){oi();const t=BigInt(n);e.valueBigInt=t}else if(e.valueDec=parseInt(n,10),isNaN(e.valueDec))return;this.value.length||(e.isFirstSid=!0,s=!0),this.value.push(e)}}while(-1!==r)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,this.value[r].isFirstSid?e=`2.{${n} - 80}`:e+=n):e+=n}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}Co.NAME="ObjectIdentifierValueBlock";class xo extends ki{constructor(e={}){super(e,Co),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Oi=xo,Ei.ObjectIdentifier=Oi,xo.NAME="OBJECT IDENTIFIER";class To extends(yi(wi)){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(0===r)return t;const n=ei._H.toUint8Array(e);if(!ci(this,n,t,r))return-1;const s=n.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&s[e],this.blockLength++,128&s[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&s[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=ti(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=ri(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",di;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),n=t.byteLength-1;for(let t=0;t<n;t++)r[t]=128|e[t];r[n]=e[n]}return r.buffer}toString(){let e="";return e=this.isHexOnly?ei.U$.ToHex(this.valueHexView):this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}To.NAME="relativeSidBlock";class Mo extends bi{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let n=t;for(;r>0;){const t=new To;if(n=t.fromBER(e,n,r),-1===n)return this.blockLength=0,this.error=t.error,n;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return n}toBER(e,t){const r=[];for(let t=0;t<this.value.length;t++){const n=this.value[t].toBER(e);if(0===n.byteLength)return this.error=this.value[t].error,di;r.push(n)}return ai(r)}fromString(e){this.value=[];let t=0,r=0,n="";do{r=e.indexOf(".",t),n=-1===r?e.substring(t):e.substring(t,r),t=r+1;const s=new To;if(s.valueDec=parseInt(n,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(e=`${e}.`),t?(n=`{${n}}`,e+=n):e+=n}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}Mo.NAME="RelativeObjectIdentifierValueBlock";class Po extends ki{constructor(e={}){super(e,Mo),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Ui=Po,Ei.RelativeObjectIdentifier=Ui,Po.NAME="RelativeObjectIdentifier";class Do extends lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}Fi=Do,Ei.Sequence=Fi,Do.NAME="SEQUENCE";class No extends lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}Vi=No,Ei.Set=Vi,No.NAME="SET";class Ro extends(yi(bi)){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=""}toJSON(){return{...super.toJSON(),value:this.value}}}Ro.NAME="StringValueBlock";class Bo extends Ro{}Bo.NAME="SimpleStringValueBlock";class Lo extends Ii{constructor({...e}={}){super(e,Bo)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,ei._H.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);this.valueBlock.value=e}}Lo.NAME="SIMPLE STRING";class Oo extends Lo{fromBuffer(e){this.valueBlock.valueHexView=ei._H.toUint8Array(e);try{this.valueBlock.value=ei.U$.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=ei.U$.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(ei.U$.FromUtf8String(e)),this.valueBlock.value=e}}Oo.NAME="Utf8StringValueBlock";class Uo extends Oo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}$i=Uo,Ei.Utf8String=$i,Uo.NAME="UTF8String";class Fo extends Lo{fromBuffer(e){this.valueBlock.value=ei.U$.ToUtf16String(e),this.valueBlock.valueHexView=ei._H.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(ei.U$.FromUtf16String(e))}}Fo.NAME="BmpStringValueBlock";class Vo extends Fo{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}Hi=Vo,Ei.BmpString=Hi,Vo.NAME="BMPString";class $o extends Lo{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(4*t);for(let n=0;n<t;n++){const t=ri(e.charCodeAt(n),8),s=new Uint8Array(t);if(s.length>4)continue;const i=4-s.length;for(let e=s.length-1;e>=0;e--)r[4*n+e+i]=s[e]}this.valueBlock.value=e}}$o.NAME="UniversalStringValueBlock";class Ho extends $o{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}zi=Ho,Ei.UniversalString=zi,Ho.NAME="UniversalString";class zo extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}qi=zo,Ei.NumericString=qi,zo.NAME="NumericString";class qo extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}ji=qo,Ei.PrintableString=ji,qo.NAME="PrintableString";class jo extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}Wi=jo,Ei.TeletexString=Wi,jo.NAME="TeletexString";class Wo extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}Ki=Wo,Ei.VideotexString=Ki,Wo.NAME="VideotexString";class Ko extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}Gi=Ko,Ei.IA5String=Gi,Ko.NAME="IA5String";class Go extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}Yi=Go,Ei.GraphicString=Yi,Go.NAME="GraphicString";class Yo extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}Ji=Yo,Ei.VisibleString=Ji,Yo.NAME="VisibleString";class Jo extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}Qi=Jo,Ei.GeneralString=Qi,Jo.NAME="GeneralString";class Qo extends Lo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}Zi=Qo,Ei.CharacterString=Zi,Qo.NAME="CharacterString";class Zo extends Yo{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let t=0;t<e.length;t++)this.valueBlock.valueHexView[t]=e.charCodeAt(t)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,ei._H.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for conversion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(e="iso"){if("iso"===e){const e=new Array(7);return e[0]=ii(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=ii(this.month,2),e[2]=ii(this.day,2),e[3]=ii(this.hour,2),e[4]=ii(this.minute,2),e[5]=ii(this.second,2),e[6]="Z",e.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}Xi=Zo,Ei.UTCTime=Xi,Zo.NAME="UTCTime";class Xo extends Zo{constructor(e={}){var t;super(e),null!==(t=this.millisecond)&&void 0!==t||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,n="",s="",i=0,o=0,a=0;if("Z"===e[e.length-1])n=e.substring(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for conversion");n=e}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for conversion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for conversion")}else{let e=1,t=n.indexOf("+"),r="";if(-1===t&&(t=n.indexOf("-"),e=-1),-1!==t){if(r=n.substring(t+1),n=n.substring(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for conversion");let s=parseInt(r.substring(0,2),10);if(isNaN(s.valueOf()))throw new Error("Wrong input string for conversion");if(o=e*s,4===r.length){if(s=parseInt(r.substring(2,4),10),isNaN(s.valueOf()))throw new Error("Wrong input string for conversion");a=e*s}}}let c=n.indexOf(".");if(-1===c&&(c=n.indexOf(",")),-1!==c){const e=new Number(`0${n.substring(c)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for conversion");i=e.valueOf(),s=n.substring(0,c)}else s=n;switch(!0){case 8===s.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for conversion");break;case 10===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for conversion")}const l=t.exec(s);if(null===l)throw new Error("Wrong input string for conversion");for(let e=1;e<l.length;e++)switch(e){case 1:this.year=parseInt(l[e],10);break;case 2:this.month=parseInt(l[e],10);break;case 3:this.day=parseInt(l[e],10);break;case 4:this.hour=parseInt(l[e],10)+o;break;case 5:this.minute=parseInt(l[e],10)+a;break;case 6:this.second=parseInt(l[e],10);break;default:throw new Error("Wrong input string for conversion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(e="iso"){if("iso"===e){const e=[];return e.push(ii(this.year,4)),e.push(ii(this.month,2)),e.push(ii(this.day,2)),e.push(ii(this.hour,2)),e.push(ii(this.minute,2)),e.push(ii(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(ii(this.millisecond,3))),e.push("Z"),e.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}eo=Xo,Ei.GeneralizedTime=eo,Xo.NAME="GeneralizedTime";class ea extends Uo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}to=ea,Ei.DATE=to,ea.NAME="DATE";class ta extends Uo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}ro=ta,Ei.TimeOfDay=ro,ta.NAME="TimeOfDay";class ra extends Uo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}no=ra,Ei.DateTime=no,ra.NAME="DateTime";class na extends Uo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}so=na,Ei.Duration=so,na.NAME="Duration";class sa extends Uo{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}function ia(e,t="utf8"){const r=hs[t];if(null==r)throw new Error(`Unsupported encoding "${t}"`);return r.encoder.encode(e).substring(1)}io=sa,Ei.TIME=io,sa.NAME="TIME";class oa extends Error{constructor(e="An error occurred while signing a message"){super(e),this.name="SigningError"}}class aa extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class ca extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const la={get(e=globalThis){const t=e.crypto;if(null==t?.subtle)throw new ca("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};class ua{type="RSA";_key;_raw;_multihash;constructor(e,t){this._key=e,this._multihash=t}get raw(){return null==this._raw&&(this._raw=da(this._key)),this._raw}toMultihash(){return this._multihash}toCID(){return Ke.createV1(114,this._multihash)}toString(){return ue.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&et(this.raw,e.raw)}verify(e,t){return async function(e,t,r){const n=await la.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return la.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},n,t,r instanceof Uint8Array?r:r.subarray())}(this._key,t,e)}}class ha{type="RSA";_key;_raw;publicKey;constructor(e,t){this._key=e,this.publicKey=t}get raw(){return null==this._raw&&(this._raw=function(e){if(null==e.n||null==e.e||null==e.d||null==e.p||null==e.q||null==e.dp||null==e.dq||null==e.qi)throw new M("JWK was missing components");const t=new Do({value:[new Ao({value:0}),Ao.fromBigInt(fa(ds(e.n,"base64url"))),Ao.fromBigInt(fa(ds(e.e,"base64url"))),Ao.fromBigInt(fa(ds(e.d,"base64url"))),Ao.fromBigInt(fa(ds(e.p,"base64url"))),Ao.fromBigInt(fa(ds(e.q,"base64url"))),Ao.fromBigInt(fa(ds(e.dp,"base64url"))),Ao.fromBigInt(fa(ds(e.dq,"base64url"))),Ao.fromBigInt(fa(ds(e.qi,"base64url")))]}).toBER();return new Uint8Array(t,0,t.byteLength)}(this._key)),this._raw}equals(e){return null!=e&&e.raw instanceof Uint8Array&&et(this.raw,e.raw)}sign(e){return async function(e,t){const r=await la.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),n=await la.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},r,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(n,0,n.byteLength)}(this._key,e)}}function da(e){if(null==e.n||null==e.e)throw new M("JWK was missing components");const t=new Do({value:[new Do({value:[new xo({value:"1.2.840.113549.1.1.1"}),new po]}),new bo({valueHex:new Do({value:[Ao.fromBigInt(fa(ds(e.n,"base64url"))),Ao.fromBigInt(fa(ds(e.e,"base64url")))]}).toBER()})]}).toBER();return new Uint8Array(t,0,t.byteLength)}function pa(e){let t=e.valueBlock.valueHexView;for(;0===t[0];)t=t.subarray(1);return ia(t,"base64url")}function fa(e){const t=[];return e.forEach((function(e){let r=e.toString(16);r.length%2>0&&(r=`0${r}`),t.push(r)})),BigInt("0x"+t.join(""))}function ga(e){const t=function(e){const{result:t}=function(e){if(!e.byteLength){const e=new ki({},bi);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ao(ei._H.toUint8Array(e).slice(),0,e.byteLength)}(e),r=t.valueBlock.value[1].valueBlock.value[0].valueBlock.value;return{kty:"RSA",n:pa(r[0]),e:pa(r[1])}}(e);if(function(e){if("RSA"!==e.kty)throw new M("invalid key type");if(null==e.n)throw new M("invalid key modulus");return 8*ds(e.n,"base64url").length}(t)>8192)throw new P("Key size is too large");const r=$e(18,Xs(Ms.encode({Type:xs.RSA,Data:e})));return new ua(t,r)}const ma=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ya=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),wa=new Uint32Array(64);class ba extends dt{constructor(){super(64,32,8,!1),this.A=0|ya[0],this.B=0|ya[1],this.C=0|ya[2],this.D=0|ya[3],this.E=0|ya[4],this.F=0|ya[5],this.G=0|ya[6],this.H=0|ya[7]}get(){const{A:e,B:t,C:r,D:n,E:s,F:i,G:o,H:a}=this;return[e,t,r,n,s,i,o,a]}set(e,t,r,n,s,i,o,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|i,this.G=0|o,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)wa[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=wa[e-15],r=wa[e-2],n=ot(t,7)^ot(t,18)^t>>>3,s=ot(r,17)^ot(r,19)^r>>>10;wa[e]=s+wa[e-7]+n+wa[e-16]|0}let{A:r,B:n,C:s,D:i,E:o,F:a,G:c,H:l}=this;for(let e=0;e<64;e++){const t=l+(ot(o,6)^ot(o,11)^ot(o,25))+((u=o)&a^~u&c)+ma[e]+wa[e]|0,h=(ot(r,2)^ot(r,13)^ot(r,22))+ht(r,n,s)|0;l=c,c=a,a=o,o=i+t|0,i=s,s=n,n=r,r=t+h|0}var u;r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,l=l+this.H|0,this.set(r,n,s,i,o,a,c,l)}roundClean(){wa.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const va=lt((()=>new ba));class Sa extends ct{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,function(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");tt(e.outputLen),tt(e.blockLen)}(e);const r=at(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),s.fill(0)}update(e){return nt(this),this.iHash.update(e),this}digestInto(e){nt(this),rt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:s,blockLen:i,outputLen:o}=this;return e.finished=n,e.destroyed=s,e.blockLen=i,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ea=(e,t,r)=>new Sa(e,t).update(r).digest();function ka(e){void 0!==e.lowS&&Tt("lowS",e.lowS),void 0!==e.prehash&&Tt("prehash",e.prehash)}Ea.create=(e,t)=>new Sa(e,t);const{Ph:Aa,aT:Ia}=a,_a={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(e,t)=>{const{Err:r}=_a;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(1&t.length)throw new r("tlv.encode: unpadded data");const n=t.length/2,s=Dt(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const i=n>127?Dt(s.length/2|128):"";return Dt(e)+i+s+t},decode(e,t){const{Err:r}=_a;let n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");const s=t[n++];let i=0;if(128&s){const e=127&s;if(!e)throw new r("tlv.decode(long): indefinite length not supported");if(e>4)throw new r("tlv.decode(long): byte length is too big");const o=t.subarray(n,n+e);if(o.length!==e)throw new r("tlv.decode: length bytes not complete");if(0===o[0])throw new r("tlv.decode(long): zero leftmost byte");for(const e of o)i=i<<8|e;if(n+=e,i<128)throw new r("tlv.decode(long): not minimal encoding")}else i=s;const o=t.subarray(n,n+i);if(o.length!==i)throw new r("tlv.decode: wrong value length");return{v:o,l:t.subarray(n+i)}}},_int:{encode(e){const{Err:t}=_a;if(e<Ca)throw new t("integer: negative integers are not allowed");let r=Dt(e);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:t}=_a;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return Aa(e)}},toSig(e){const{Err:t,_int:r,_tlv:n}=_a,s="string"==typeof e?Ia(e):e;xt(s);const{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:u}=n.decode(2,c);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(l)}},hexFromSig(e){const{_tlv:t,_int:r}=_a,n=t.encode(2,r.encode(e.r))+t.encode(2,r.encode(e.s));return t.encode(48,n)}},Ca=BigInt(0),xa=BigInt(1),Ta=(BigInt(2),BigInt(3));function Ma(e){const t=function(e){const t=_r(e);return Zt(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,s=r.BYTES+1,i=2*r.BYTES+1;function o(e){return ar(e,n)}function a(e){return ur(e,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:u,isWithinCurveOrder:h}=function(e){const t=function(e){const t=_r(e);Zt(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:s}=t;if(r){if(!n.eql(s,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=pr(t.n,t.nBitLength),s=t.toBytes||((e,t,n)=>{const s=t.toAffine();return Ht(Uint8Array.from([4]),r.toBytes(s.x),r.toBytes(s.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function o(e){const{a:n,b:s}=t,i=r.sqr(e),o=r.mul(i,e);return r.add(r.add(o,r.mul(e,n)),s)}if(!r.eql(r.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function a(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:s,n:i}=t;if(r&&"bigint"!=typeof e){if(Ct(e)&&(e=Pt(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("invalid private key");e=e.padStart(2*n,"0")}let o;try{o="bigint"==typeof e?e:Ot($t("private key",e,n))}catch(t){throw new Error("invalid private key, expected hex or "+n+" bytes, got "+typeof e)}return s&&(o=ar(o,i)),jt("private key",o,xa,i),o}function c(e){if(!(e instanceof h))throw new Error("ProjectivePoint expected")}const l=Xt(((e,t)=>{const{px:n,py:s,pz:i}=e;if(r.eql(i,r.ONE))return{x:n,y:s};const o=e.is0();null==t&&(t=o?r.ONE:r.inv(i));const a=r.mul(n,t),c=r.mul(s,t),l=r.mul(i,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(l,r.ONE))throw new Error("invZ was invalid");return{x:a,y:c}})),u=Xt((e=>{if(e.is0()){if(t.allowInfinityPoint&&!r.is0(e.py))return;throw new Error("bad point: ZERO")}const{x:n,y:s}=e.toAffine();if(!r.isValid(n)||!r.isValid(s))throw new Error("bad point: x or y not FE");const i=r.sqr(s),a=o(n);if(!r.eql(i,a))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class h{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required");Object.freeze(this)}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof h)throw new Error("projective point not allowed");const s=e=>r.eql(e,r.ZERO);return s(t)&&s(n)?h.ZERO:new h(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}static fromHex(e){const t=h.fromAffine(i($t("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return h.BASE.multiply(a(e))}static msm(e,t){return Ir(h,n,e,t)}_setWindowSize(e){p.setWindowSize(this,e)}assertValidity(){u(this)}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){c(e);const{px:t,py:n,pz:s}=this,{px:i,py:o,pz:a}=e,l=r.eql(r.mul(t,a),r.mul(i,s)),u=r.eql(r.mul(n,a),r.mul(o,s));return l&&u}negate(){return new h(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,s=r.mul(n,Ta),{px:i,py:o,pz:a}=this;let c=r.ZERO,l=r.ZERO,u=r.ZERO,d=r.mul(i,i),p=r.mul(o,o),f=r.mul(a,a),g=r.mul(i,o);return g=r.add(g,g),u=r.mul(i,a),u=r.add(u,u),c=r.mul(e,u),l=r.mul(s,f),l=r.add(c,l),c=r.sub(p,l),l=r.add(p,l),l=r.mul(c,l),c=r.mul(g,c),u=r.mul(s,u),f=r.mul(e,f),g=r.sub(d,f),g=r.mul(e,g),g=r.add(g,u),u=r.add(d,d),d=r.add(u,d),d=r.add(d,f),d=r.mul(d,g),l=r.add(l,d),f=r.mul(o,a),f=r.add(f,f),d=r.mul(f,g),c=r.sub(c,d),u=r.mul(f,p),u=r.add(u,u),u=r.add(u,u),new h(c,l,u)}add(e){c(e);const{px:n,py:s,pz:i}=this,{px:o,py:a,pz:l}=e;let u=r.ZERO,d=r.ZERO,p=r.ZERO;const f=t.a,g=r.mul(t.b,Ta);let m=r.mul(n,o),y=r.mul(s,a),w=r.mul(i,l),b=r.add(n,s),v=r.add(o,a);b=r.mul(b,v),v=r.add(m,y),b=r.sub(b,v),v=r.add(n,i);let S=r.add(o,l);return v=r.mul(v,S),S=r.add(m,w),v=r.sub(v,S),S=r.add(s,i),u=r.add(a,l),S=r.mul(S,u),u=r.add(y,w),S=r.sub(S,u),p=r.mul(f,v),u=r.mul(g,w),p=r.add(u,p),u=r.sub(y,p),p=r.add(y,p),d=r.mul(u,p),y=r.add(m,m),y=r.add(y,m),w=r.mul(f,w),v=r.mul(g,v),y=r.add(y,w),w=r.sub(m,w),w=r.mul(f,w),v=r.add(v,w),m=r.mul(y,v),d=r.add(d,m),m=r.mul(S,v),u=r.mul(b,u),u=r.sub(u,m),m=r.mul(b,y),p=r.mul(S,p),p=r.add(p,m),new h(u,d,p)}subtract(e){return this.add(e.negate())}is0(){return this.equals(h.ZERO)}wNAF(e){return p.wNAFCached(this,e,h.normalizeZ)}multiplyUnsafe(e){const{endo:n,n:s}=t;jt("scalar",e,Ca,s);const i=h.ZERO;if(e===Ca)return i;if(this.is0()||e===xa)return this;if(!n||p.hasPrecomputes(this))return p.wNAFCachedUnsafe(this,e,h.normalizeZ);let{k1neg:o,k1:a,k2neg:c,k2:l}=n.splitScalar(e),u=i,d=i,f=this;for(;a>Ca||l>Ca;)a&xa&&(u=u.add(f)),l&xa&&(d=d.add(f)),f=f.double(),a>>=xa,l>>=xa;return o&&(u=u.negate()),c&&(d=d.negate()),d=new h(r.mul(d.px,n.beta),d.py,d.pz),u.add(d)}multiply(e){const{endo:n,n:s}=t;let i,o;if(jt("scalar",e,xa,s),n){const{k1neg:t,k1:s,k2neg:a,k2:c}=n.splitScalar(e);let{p:l,f:u}=this.wNAF(s),{p:d,f}=this.wNAF(c);l=p.constTimeNegate(t,l),d=p.constTimeNegate(a,d),d=new h(r.mul(d.px,n.beta),d.py,d.pz),i=l.add(d),o=u.add(f)}else{const{p:t,f:r}=this.wNAF(e);i=t,o=r}return h.normalizeZ([i,o])[0]}multiplyAndAddUnsafe(e,t,r){const n=h.BASE,s=(e,t)=>t!==Ca&&t!==xa&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),i=s(this,t).add(s(e,r));return i.is0()?void 0:i}toAffine(e){return l(this,e)}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===xa)return!0;if(r)return r(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===xa?this:r?r(h,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return Tt("isCompressed",e),this.assertValidity(),s(h,this,e)}toHex(e=!0){return Tt("isCompressed",e),Pt(this.toRawBytes(e))}}h.BASE=new h(t.Gx,t.Gy,r.ONE),h.ZERO=new h(r.ZERO,r.ONE,r.ZERO);const d=t.nBitLength,p=Ar(h,t.endo?Math.ceil(d/2):d);return{CURVE:t,ProjectivePoint:h,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:function(e){return qt(e,xa,t.n)}}}({...t,toBytes(e,t,n){const s=t.toAffine(),i=r.toBytes(s.x),o=Ht;return Tt("isCompressed",n),n?o(Uint8Array.from([t.hasEvenY()?2:3]),i):o(Uint8Array.from([4]),i,r.toBytes(s.y))},fromBytes(e){const t=e.length,n=e[0],o=e.subarray(1);if(t!==s||2!==n&&3!==n){if(t===i&&4===n)return{x:r.fromBytes(o.subarray(0,r.BYTES)),y:r.fromBytes(o.subarray(r.BYTES,2*r.BYTES))};throw new Error("invalid Point, expected length of "+s+", or uncompressed "+i+", got "+t)}{const e=Ot(o);if(!qt(e,xa,r.ORDER))throw new Error("Point is not on curve");const t=u(e);let s;try{s=r.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~n)!=((s&xa)===xa)&&(s=r.neg(s)),{x:e,y:s}}}}),d=e=>Pt(Ft(e,t.nByteLength));function p(e){return e>n>>xa}const f=(e,t,r)=>Ot(e.slice(t,r));class g{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=$t("compactSignature",e,2*r),new g(f(e,0,r),f(e,r,2*r))}static fromDER(e){const{r:t,s:r}=_a.toSig($t("DER",e));return new g(t,r)}assertValidity(){jt("r",this.r,xa,n),jt("s",this.s,xa,n)}addRecoveryBit(e){return new g(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s,recovery:i}=this,l=b($t("msgHash",e));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?n+t.n:n;if(u>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=1&i?"03":"02",p=c.fromHex(h+d(u)),f=a(u),g=o(-l*f),m=o(s*f),y=c.BASE.multiplyAndAddUnsafe(p,g,m);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Lt(this.toDERHex())}toDERHex(){return _a.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Lt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const m={isValidPrivateKey(e){try{return l(e),!0}catch(e){return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const e=gr(t.n);return function(e,t,r=!1){const n=e.length,s=fr(t),i=gr(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=ar(r?Ot(e):Ut(e),t-tr)+tr;return r?Vt(o,s):Ft(o,s)}(t.randomBytes(e),t.n)},precompute:(e=8,t=c.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function y(e){const t=Ct(e),r="string"==typeof e,n=(t||r)&&e.length;return t?n===s||n===i:r?n===2*s||n===2*i:e instanceof c}const w=t.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const r=Ot(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},b=t.bits2int_modN||function(e){return o(w(e))},v=Kt(t.nBitLength);function S(e){return jt("num < 2^"+t.nBitLength,e,Ca,v),Ft(e,t.nByteLength)}const E={lowS:t.lowS,prehash:!1},k={lowS:t.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return c.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,r=!0){if(y(e))throw new Error("first arg must be private key");if(!y(t))throw new Error("second arg must be public key");return c.fromHex(t).multiply(l(e)).toRawBytes(r)},sign:function(e,n,s=E){const{seed:i,k2sig:u}=function(e,n,s=E){if(["recovered","canonical"].some((e=>e in s)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=t;let{lowS:d,prehash:f,extraEntropy:m}=s;null==d&&(d=!0),e=$t("msgHash",e),ka(s),f&&(e=$t("prehashed msgHash",i(e)));const y=b(e),v=l(n),k=[S(v),S(y)];if(null!=m&&!1!==m){const e=!0===m?u(r.BYTES):m;k.push($t("extraEntropy",e))}const A=Ht(...k),I=y;return{seed:A,k2sig:function(e){const t=w(e);if(!h(t))return;const r=a(t),n=c.BASE.multiply(t).toAffine(),s=o(n.x);if(s===Ca)return;const i=o(r*o(I+s*v));if(i===Ca)return;let l=(n.x===s?0:2)|Number(n.y&xa),u=i;return d&&p(i)&&(u=function(e){return p(e)?o(-e):e}(i),l^=1),new g(s,u,l)}}}(e,n,s),d=t;return Jt(d.hash.outputLen,d.nByteLength,d.hmac)(i,u)},verify:function(e,r,n,s=k){const i=e;r=$t("msgHash",r),n=$t("publicKey",n);const{lowS:l,prehash:u,format:h}=s;if(ka(s),"strict"in s)throw new Error("options.strict was renamed to lowS");if(void 0!==h&&"compact"!==h&&"der"!==h)throw new Error("format must be compact or der");const d="string"==typeof i||Ct(i),p=!d&&!h&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!d&&!p)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let f,m;try{if(p&&(f=new g(i.r,i.s)),d){try{"compact"!==h&&(f=g.fromDER(i))}catch(e){if(!(e instanceof _a.Err))throw e}f||"der"===h||(f=g.fromCompact(i))}m=c.fromHex(n)}catch(e){return!1}if(!f)return!1;if(l&&f.hasHighS())return!1;u&&(r=t.hash(r));const{r:y,s:w}=f,v=b(r),S=a(w),E=o(v*S),A=o(y*S),I=c.BASE.multiplyAndAddUnsafe(m,E,A)?.toAffine();return!!I&&o(I.x)===y},ProjectivePoint:c,Signature:g,utils:m}}function Pa(e){return{hash:e,hmac:(t,...r)=>Ea(e,t,function(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];rt(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}(...r)),randomBytes:ut}}BigInt(4);const Da=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Na=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ra=BigInt(1),Ba=BigInt(2),La=(e,t)=>(e+t/Ba)/t;const Oa=pr(Da,void 0,void 0,{sqrt:function(e){const t=Da,r=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=e*e*e%t,u=l*l*e%t,h=lr(u,r,t)*u%t,d=lr(h,r,t)*u%t,p=lr(d,Ba,t)*l%t,f=lr(p,s,t)*p%t,g=lr(f,i,t)*f%t,m=lr(g,a,t)*g%t,y=lr(m,c,t)*m%t,w=lr(y,a,t)*g%t,b=lr(w,r,t)*u%t,v=lr(b,o,t)*f%t,S=lr(v,n,t)*l%t,E=lr(S,Ba,t);if(!Oa.eql(Oa.sqr(E),e))throw new Error("Cannot find square root");return E}}),Ua=function(e,t){const r=t=>Ma({...e,...Pa(t)});return Object.freeze({...r(t),create:r})}({a:BigInt(0),b:BigInt(7),Fp:Oa,n:Na,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Na,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Ra*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,o=BigInt("0x100000000000000000000000000000000"),a=La(i*e,t),c=La(-n*e,t);let l=ar(e-a*r-c*s,t),u=ar(-a*n-c*i,t);const h=l>o,d=u>o;if(h&&(l=t-l),d&&(u=t-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:h,k1:l,k2neg:d,k2:u}}}},va);function Fa(e){return null!=e&&"function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally}BigInt(0),Ua.ProjectivePoint;class Va{type="secp256k1";raw;_key;constructor(e){this._key=function(e){try{return Ua.ProjectivePoint.fromHex(e),e}catch(e){throw new P(String(e))}}(e),this.raw=function(e){return Ua.ProjectivePoint.fromHex(e).toRawBytes(!0)}(this._key)}toMultihash(){return Xe.digest(ja(this))}toCID(){return Ke.createV1(114,this.toMultihash())}toString(){return ue.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&et(this.raw,e.raw)}verify(e,t){return function(e,t,r){const n=is.digest(r instanceof Uint8Array?r:r.subarray());if(Fa(n))return n.then((({digest:r})=>Ua.verify(t,r,e))).catch((e=>{throw new aa(String(e))}));try{return Ua.verify(t,n.digest,e)}catch(e){throw new aa(String(e))}}(this._key,t,e)}}class $a{type="secp256k1";raw;publicKey;constructor(e,t){this.raw=function(e){try{return Ua.getPublicKey(e,!0),e}catch(e){throw new D(String(e))}}(e),this.publicKey=new Va(t??function(e){try{return Ua.getPublicKey(e,!0)}catch(e){throw new D(String(e))}}(e))}equals(e){return null!=e&&e.raw instanceof Uint8Array&&et(this.raw,e.raw)}sign(e){return function(e,t){const r=is.digest(t instanceof Uint8Array?t:t.subarray());if(Fa(r))return r.then((({digest:t})=>Ua.sign(t,e).toDERRawBytes())).catch((e=>{throw new oa(String(e))}));try{return Ua.sign(r.digest,e).toDERRawBytes()}catch(e){throw new oa(String(e))}}(this.raw,e)}}function Ha(e){return new Va(e)}async function za(e,t){if("Ed25519"===e)return async function(){const{privateKey:e,publicKey:t}=function(){const e=Wr.utils.randomPrivateKey(),t=Wr.getPublicKey(e);return{privateKey:Gr(e,t),publicKey:t}}();return new Jr(e,t)}();if("secp256k1"===e)return async function(){const e=Ua.utils.randomPrivateKey();return new $a(e)}();if("RSA"===e)return async function(e){if(e>8192)throw new M("Key size is too large");const t=await async function(e){const t=await la.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),r=await async function(e){if(null==e.privateKey||null==e.publicKey)throw new M("Private and public key are required");return Promise.all([la.get().subtle.exportKey("jwk",e.privateKey),la.get().subtle.exportKey("jwk",e.publicKey)])}(t);return{privateKey:r[0],publicKey:r[1]}}(e),r=$e(18,Xs(Ms.encode({Type:xs.RSA,Data:da(t.publicKey)})));return new ha(t.privateKey,new ua(t.publicKey,r))}(t??2048);throw new X}function qa(e){const{Type:t,Data:r}=Ms.decode(e),n=r??new Uint8Array;switch(t){case xs.RSA:return ga(n);case xs.Ed25519:return Qr(n);case xs.secp256k1:return Ha(n);default:throw new X}}function ja(e){return Ms.encode({Type:xs[e.type],Data:e.raw})}const Wa=Symbol.for("@libp2p/peer-id");function Ka(e){return Boolean(e?.[Wa])}const Ga=Symbol.for("nodejs.util.inspect.custom");class Ya{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Wa]=!0;toString(){return null==this.string&&(this.string=ue.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Ke.createV1(114,this.multihash)}toJSON(){return this.toString()}equals(e){if(null==e)return!1;if(e instanceof Uint8Array)return et(this.multihash.bytes,e);if("string"==typeof e)return this.toString()===e;if(null!=e?.toMultihash()?.bytes)return et(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[Ga](){return`PeerId(${this.toString()})`}}class Ja extends Ya{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class Qa extends Ya{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class Za extends Ya{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}class Xa{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=Xe.digest(ds(this.url))}[Ga](){return`PeerId(${this.url})`}[Wa]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Ke.createV1(2336,this.toMultihash())}toJSON(){return this.toString()}equals(e){return null!=e&&(e instanceof Uint8Array&&(e=ia(e)),e.toString()===this.toString())}}function ec(e,t){let r;if("1"===e.charAt(0)||"Q"===e.charAt(0))r=He(ue.decode(`z${e}`));else{if(null==t)throw new M('Please pass a multibase decoder for strings that do not start with "1" or "Q"');r=He(t.decode(e))}return rc(r)}function tc(e){if("Ed25519"===e.type)return new Qa({multihash:e.toCID().multihash,publicKey:e});if("secp256k1"===e.type)return new Za({multihash:e.toCID().multihash,publicKey:e});if("RSA"===e.type)return new Ja({multihash:e.toCID().multihash,publicKey:e});throw new X}function rc(e){if(function(e){return e.code===is.code}(e))return new Ja({multihash:e});if(function(e){return e.code===Xe.code}(e))try{const t=function(e){const{Type:t,Data:r}=Ms.decode(e.digest),n=r??new Uint8Array;switch(t){case xs.Ed25519:return Qr(n);case xs.secp256k1:return Ha(n);default:throw new X}}(e);if("Ed25519"===t.type)return new Qa({multihash:e,publicKey:t});if("secp256k1"===t.type)return new Za({multihash:e,publicKey:t})}catch(t){const r=ia(e.digest);return new Xa(new URL(r))}throw new z("Supplied PeerID Multihash is invalid")}function nc(e){if(null==e?.multihash||null==e.version||1===e.version&&114!==e.code&&2336!==e.code)throw new H("Supplied PeerID CID is invalid");if(2336===e.code){const t=ia(e.multihash.digest);return new Xa(new URL(t))}return rc(e.multihash)}function sc(e,t){null==t&&(t=e.reduce(((e,t)=>e+t.length),0));const r=en(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}const ic=Symbol.for("@achingbrain/uint8arraylist");function oc(e,t){if(null==t||t<0)throw new RangeError("index is out of bounds");let r=0;for(const n of e){const e=r+n.byteLength;if(t<e)return{buf:n,index:t-r};r=e}throw new RangeError("index is out of bounds")}function ac(e){return Boolean(e?.[ic])}class cc{bufs;length;[ic]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else{if(!ac(r))throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");t+=r.byteLength,this.bufs.push(...r.bufs)}this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else{if(!ac(r))throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");t+=r.byteLength,this.bufs.unshift(...r.bufs)}this.length+=t}get(e){const t=oc(this.bufs,e);return t.buf[t.index]}set(e,t){const r=oc(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else{if(!ac(e))throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");for(let r=0;r<e.length;r++)this.set(t+r,e.get(r))}}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength)return this.bufs=[],void(this.length=0);for(;this.bufs.length>0;){if(!(e>=this.bufs[0].byteLength)){this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift()}}}slice(e,t){const{bufs:r,length:n}=this._subList(e,t);return sc(r,n)}subarray(e,t){const{bufs:r,length:n}=this._subList(e,t);return 1===r.length?r[0]:sc(r,n)}sublist(e,t){const{bufs:r,length:n}=this._subList(e,t),s=new cc;return s.length=n,s.bufs=[...r],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(0===e&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let n=0;for(let s=0;s<this.bufs.length;s++){const i=this.bufs[s],o=n,a=o+i.byteLength;if(n=a,e>=a)continue;const c=e>=o&&e<a,l=t>o&&t<=a;if(c&&l){if(e===o&&t===a){r.push(i);break}const n=e-o;r.push(i.subarray(n,n+(t-e)));break}if(c){if(0===e){r.push(i);continue}r.push(i.subarray(e-o))}else{if(l){if(t===a){r.push(i);break}r.push(i.subarray(0,t-o));break}r.push(i)}}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!(ac(e)||e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),0===e.length)return t>this.length?this.length:t;const n=r.byteLength;if(0===n)throw new TypeError("search must be at least 1 byte long");const s=new Int32Array(256);for(let e=0;e<256;e++)s[e]=-1;for(let e=0;e<n;e++)s[r[e]]=e;const i=s,o=this.byteLength-r.byteLength,a=r.byteLength-1;let c;for(let e=t;e<=o;e+=c){c=0;for(let t=a;t>=0;t--){const n=this.get(e+t);if(r[t]!==n){c=Math.max(1,t-i[n]);break}}if(0===c)return e}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const r=en(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){const n=Xr(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,t,r),this.write(n,e)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){const n=Xr(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,t,r),this.write(n,e)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){const n=Xr(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,t,r),this.write(n,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const r=en(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){const n=Xr(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,t,r),this.write(n,e)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){const n=Xr(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,t,r),this.write(n,e)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){const n=Xr(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,t,r),this.write(n,e)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){const n=Xr(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,t,r),this.write(n,e)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){const n=Xr(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,t,r),this.write(n,e)}equals(e){if(null==e)return!1;if(!(e instanceof cc))return!1;if(e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!et(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new cc;return r.bufs=e,null==t&&(t=e.reduce(((e,t)=>e+t.byteLength),0)),r.length=t,r}}function lc(e){return null!=e[Symbol.asyncIterator]}const uc=e=>{const t=hn(e),r=en(t);return fn(e,r),uc.bytes=t,r};function hc(e,t){const r=(t=t??{}).lengthEncoder??uc;function*n(e){const t=r(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return lc(e)?async function*(){for await(const t of e)yield*n(t)}():function*(){for(const t of e)yield*n(t)}()}uc.bytes=0,hc.single=(e,t)=>{const r=(t=t??{}).lengthEncoder??uc;return new cc(r(e.byteLength),e)};class dc extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class pc extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class fc extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}class gc extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}var mc;!function(e){e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"}(mc||(mc={}));const yc=e=>{const t=gn(e);return yc.bytes=hn(t),t};function wc(e,t){const r=new cc;let n=mc.LENGTH,s=-1;const i=t?.lengthDecoder??yc,o=t?.maxLengthLength??8,a=t?.maxDataLength??4194304;function*c(){for(;r.byteLength>0;){if(n===mc.LENGTH)try{if(s=i(r),s<0)throw new dc("Invalid message length");if(s>a)throw new pc("Message length too long");const e=i.bytes;r.consume(e),null!=t?.onLength&&t.onLength(s),n=mc.DATA}catch(e){if(e instanceof RangeError){if(r.byteLength>o)throw new fc("Message length length too long");break}throw e}if(n===mc.DATA){if(r.byteLength<s)break;const e=r.sublist(0,s);r.consume(s),null!=t?.onData&&t.onData(e),yield e,n=mc.LENGTH}}}return lc(e)?async function*(){for await(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new gc("Unexpected end of input")}():function*(){for(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new gc("Unexpected end of input")}()}function bc(){const e={};return e.promise=new Promise(((t,r)=>{e.resolve=t,e.reject=r})),e}yc.bytes=0,wc.fromReader=(e,t)=>{let r=1;return wc(async function*(){for(;;)try{const{done:t,value:n}=await e.next(r);if(!0===t)return;null!=n&&(yield n)}catch(e){if("ERR_UNDER_READ"===e.code)return{done:!0,value:null};throw e}finally{r=1}}(),{...t??{},onLength:e=>{r=e}})};class vc{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(void 0!==e)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return void 0===this.buffer[this.btm]}}class Sc{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new vc(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return null!=e?.byteLength?e.byteLength:1}push(e){if(null!=e?.value&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new vc(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(void 0===e&&null!=this.tail.next){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return null!=e?.value&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}class Ec extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}}function kc(e={}){return function(e,t){let r,n,s,i=(t=t??{}).onEnd,o=new Sc,a=bc();const c=e=>null!=n?n(e):(o.push(e),r),l=e=>{if(s)return r;if(!0!==t?.objectMode&&null==e?.byteLength)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return c({done:!1,value:e})},u=e=>s?r:(s=!0,null!=e?(e=>(o=new Sc,null!=n?n({error:e}):(o.push({error:e}),r)))(e):c({done:!0}));if(r={[Symbol.asyncIterator](){return this},next:async()=>{try{return o.isEmpty()?s?{done:!0}:await new Promise(((t,s)=>{n=i=>{n=null,o.push(i);try{t(e(o))}catch(e){s(e)}return r}})):e(o)}finally{o.isEmpty()&&queueMicrotask((()=>{a.resolve(),a=bc()}))}},return:()=>(o=new Sc,u(),{done:!0}),throw:e=>(u(e),{done:!0}),push:l,end:u,get readableLength(){return o.size},onEmpty:async e=>{const t=e?.signal;if(t?.throwIfAborted(),o.isEmpty())return;let r,n;null!=t&&(r=new Promise(((e,r)=>{n=()=>{r(new Ec)},t.addEventListener("abort",n)})));try{await Promise.race([a.promise,r])}finally{null!=n&&null!=t&&t?.removeEventListener("abort",n)}}},null==i)return r;const h=r;return r={[Symbol.asyncIterator](){return this},next:()=>h.next(),throw:e=>(h.throw(e),null!=i&&(i(e),i=void 0),{done:!0}),return:()=>(h.return(),null!=i&&(i(),i=void 0),{done:!0}),push:l,end:e=>(h.end(e),null!=i&&(i(e),i=void 0),r),get readableLength(){return h.readableLength},onEmpty:e=>h.onEmpty(e)},r}((e=>{const t=e.shift();if(null==t)return{done:!0};if(null!=t.error)throw t.error;return{done:!0===t.done,value:t.value}}),e)}const Ac=function(...e){const t=[];for(const r of e)null==r[Symbol.asyncIterator]&&t.push(r);return t.length===e.length?function*(){for(const e of t)yield*e}():async function*(){const t=kc({objectMode:!0});Promise.resolve().then((async()=>{try{await Promise.all(e.map((async e=>{for await(const r of e)t.push(r)}))),t.end()}catch(e){t.end(e)}})),yield*t}()};function Ic(e,...t){if(null==e)throw new Error("Empty pipeline");if(Tc(e)){const t=e;e=()=>t.source}else if(xc(e)||Cc(e)){const t=e;e=()=>t}const r=[e,...t];if(r.length>1&&Tc(r[r.length-1])&&(r[r.length-1]=r[r.length-1].sink),r.length>2)for(let e=1;e<r.length-1;e++)Tc(r[e])&&(r[e]=Mc(r[e]));return _c(...r)}const _c=(...e)=>{let t;for(;e.length>0;)t=e.shift()(t);return t},Cc=e=>null!=e?.[Symbol.asyncIterator],xc=e=>null!=e?.[Symbol.iterator],Tc=e=>null!=e&&null!=e.sink&&null!=e.source,Mc=e=>t=>{const r=e.sink(t);if(null!=r?.then){const t=kc({objectMode:!0});let n;r.then((()=>{t.end()}),(e=>{t.end(e)}));const s=e.source;if(Cc(s))n=async function*(){yield*s,t.end()};else{if(!xc(s))throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");n=function*(){yield*s,t.end()}}return Ac(t,n())}return e.source},Pc="/floodsub/1.0.0",Dc="/meshsub/1.0.0",Nc="/meshsub/1.2.0",Rc=5e3,Bc={maxSubscriptions:1/0,maxMessages:1/0,maxIhaveMessageIDs:1/0,maxIwantMessageIDs:1/0,maxIdontwantMessageIDs:1/0,maxControlMessages:1/0,maxPeerInfos:1/0};var Lc,Oc,Uc,Fc,Vc,$c,Hc,zc,qc,jc,Wc,Kc;!function(e){let t,r,n,s,i,o,a,c,l,u;!function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.subscribe&&(t.uint32(8),t.bool(e.subscribe)),null!=e.topic&&(t.uint32(18),t.string(e.topic)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.subscribe=e.bool();break;case 2:n.topic=e.string();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(t=e.SubOpts||(e.SubOpts={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.from&&(t.uint32(10),t.bytes(e.from)),null!=e.data&&(t.uint32(18),t.bytes(e.data)),null!=e.seqno&&(t.uint32(26),t.bytes(e.seqno)),null!=e.topic&&""!==e.topic&&(t.uint32(34),t.string(e.topic)),null!=e.signature&&(t.uint32(42),t.bytes(e.signature)),null!=e.key&&(t.uint32(50),t.bytes(e.key)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={topic:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.from=e.bytes();break;case 2:n.data=e.bytes();break;case 3:n.seqno=e.bytes();break;case 4:n.topic=e.string();break;case 5:n.signature=e.bytes();break;case 6:n.key=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(r=e.Message||(e.Message={})),function(t){let r;t.codec=()=>(null==r&&(r=Rs(((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.ihave)for(const n of t.ihave)r.uint32(10),e.ControlIHave.codec().encode(n,r);if(null!=t.iwant)for(const n of t.iwant)r.uint32(18),e.ControlIWant.codec().encode(n,r);if(null!=t.graft)for(const n of t.graft)r.uint32(26),e.ControlGraft.codec().encode(n,r);if(null!=t.prune)for(const n of t.prune)r.uint32(34),e.ControlPrune.codec().encode(n,r);if(null!=t.idontwant)for(const n of t.idontwant)r.uint32(42),e.ControlIDontWant.codec().encode(n,r);!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={ihave:[],iwant:[],graft:[],prune:[],idontwant:[]},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:if(null!=n.limits?.ihave&&s.ihave.length===n.limits.ihave)throw new Bs('Decode error - map field "ihave" had too many elements');s.ihave.push(e.ControlIHave.codec().decode(t,t.uint32(),{limits:n.limits?.ihave$}));break;case 2:if(null!=n.limits?.iwant&&s.iwant.length===n.limits.iwant)throw new Bs('Decode error - map field "iwant" had too many elements');s.iwant.push(e.ControlIWant.codec().decode(t,t.uint32(),{limits:n.limits?.iwant$}));break;case 3:if(null!=n.limits?.graft&&s.graft.length===n.limits.graft)throw new Bs('Decode error - map field "graft" had too many elements');s.graft.push(e.ControlGraft.codec().decode(t,t.uint32(),{limits:n.limits?.graft$}));break;case 4:if(null!=n.limits?.prune&&s.prune.length===n.limits.prune)throw new Bs('Decode error - map field "prune" had too many elements');s.prune.push(e.ControlPrune.codec().decode(t,t.uint32(),{limits:n.limits?.prune$}));break;case 5:if(null!=n.limits?.idontwant&&s.idontwant.length===n.limits.idontwant)throw new Bs('Decode error - map field "idontwant" had too many elements');s.idontwant.push(e.ControlIDontWant.codec().decode(t,t.uint32(),{limits:n.limits?.idontwant$}));break;default:t.skipType(7&r)}}return s}))),r),t.encode=e=>_s(e,t.codec()),t.decode=(e,r)=>Pn(e,t.codec(),r)}(n=e.ControlMessage||(e.ControlMessage={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.topicID&&(t.uint32(10),t.string(e.topicID)),null!=e.messageIDs)for(const r of e.messageIDs)t.uint32(18),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={messageIDs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.topicID=e.string();break;case 2:if(null!=r.limits?.messageIDs&&n.messageIDs.length===r.limits.messageIDs)throw new Bs('Decode error - map field "messageIDs" had too many elements');n.messageIDs.push(e.bytes());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(s=e.ControlIHave||(e.ControlIHave={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.messageIDs)for(const r of e.messageIDs)t.uint32(10),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={messageIDs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();if(t>>>3==1){if(null!=r.limits?.messageIDs&&n.messageIDs.length===r.limits.messageIDs)throw new Bs('Decode error - map field "messageIDs" had too many elements');n.messageIDs.push(e.bytes())}else e.skipType(7&t)}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(i=e.ControlIWant||(e.ControlIWant={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.topicID&&(t.uint32(10),t.string(e.topicID)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();t>>>3==1?n.topicID=e.string():e.skipType(7&t)}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(o=e.ControlGraft||(e.ControlGraft={})),function(t){let r;t.codec=()=>(null==r&&(r=Rs(((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.topicID&&(r.uint32(10),r.string(t.topicID)),null!=t.peers)for(const n of t.peers)r.uint32(18),e.PeerInfo.codec().encode(n,r);null!=t.backoff&&(r.uint32(24),r.uint64Number(t.backoff)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={peers:[]},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.topicID=t.string();break;case 2:if(null!=n.limits?.peers&&s.peers.length===n.limits.peers)throw new Bs('Decode error - map field "peers" had too many elements');s.peers.push(e.PeerInfo.codec().decode(t,t.uint32(),{limits:n.limits?.peers$}));break;case 3:s.backoff=t.uint64Number();break;default:t.skipType(7&r)}}return s}))),r),t.encode=e=>_s(e,t.codec()),t.decode=(e,r)=>Pn(e,t.codec(),r)}(a=e.ControlPrune||(e.ControlPrune={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.peerID&&(t.uint32(10),t.bytes(e.peerID)),null!=e.signedPeerRecord&&(t.uint32(18),t.bytes(e.signedPeerRecord)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.peerID=e.bytes();break;case 2:n.signedPeerRecord=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(c=e.PeerInfo||(e.PeerInfo={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.messageIDs)for(const r of e.messageIDs)t.uint32(10),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={messageIDs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();if(t>>>3==1){if(null!=r.limits?.messageIDs&&n.messageIDs.length===r.limits.messageIDs)throw new Bs('Decode error - map field "messageIDs" had too many elements');n.messageIDs.push(e.bytes())}else e.skipType(7&t)}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(l=e.ControlIDontWant||(e.ControlIDontWant={})),e.codec=()=>(null==u&&(u=Rs(((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.subscriptions)for(const n of t.subscriptions)r.uint32(10),e.SubOpts.codec().encode(n,r);if(null!=t.messages)for(const n of t.messages)r.uint32(18),e.Message.codec().encode(n,r);null!=t.control&&(r.uint32(26),e.ControlMessage.codec().encode(t.control,r)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={subscriptions:[],messages:[]},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:if(null!=n.limits?.subscriptions&&s.subscriptions.length===n.limits.subscriptions)throw new Bs('Decode error - map field "subscriptions" had too many elements');s.subscriptions.push(e.SubOpts.codec().decode(t,t.uint32(),{limits:n.limits?.subscriptions$}));break;case 2:if(null!=n.limits?.messages&&s.messages.length===n.limits.messages)throw new Bs('Decode error - map field "messages" had too many elements');s.messages.push(e.Message.codec().decode(t,t.uint32(),{limits:n.limits?.messages$}));break;case 3:s.control=e.ControlMessage.codec().decode(t,t.uint32(),{limits:n.limits?.control});break;default:t.skipType(7&r)}}return s}))),u),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Lc||(Lc={}));class Gc{gossip;msgs=new Map;msgIdToStrFn;history=[];notValidatedCount=0;constructor(e,t,r){this.gossip=e,this.msgIdToStrFn=r;for(let e=0;e<t;e++)this.history[e]=[]}get size(){return this.msgs.size}put(e,t,r=!1){const{msgIdStr:n}=e;return!this.msgs.has(n)&&(this.msgs.set(n,{message:t,validated:r,originatingPeers:new Set,iwantCounts:new Map}),this.history[0].push({...e,topic:t.topic}),r||this.notValidatedCount++,!0)}observeDuplicate(e,t){const r=this.msgs.get(e);null==r||r.validated||r.originatingPeers.add(t)}get(e){return this.msgs.get(this.msgIdToStrFn(e))?.message}getWithIWantCount(e,t){const r=this.msgs.get(e);if(null==r)return null;const n=(r.iwantCounts.get(t)??0)+1;return r.iwantCounts.set(t,n),{msg:r.message,count:n}}getGossipIDs(e){const t=new Map;for(let r=0;r<this.gossip;r++)this.history[r].forEach((r=>{const n=this.msgs.get(r.msgIdStr);if(n?.validated&&e.has(r.topic)){let e=t.get(r.topic);null==e&&(e=[],t.set(r.topic,e)),e.push(r.msgId)}}));return t}validate(e){const t=this.msgs.get(e);if(null==t)return null;t.validated||this.notValidatedCount--;const{message:r,originatingPeers:n}=t;return t.validated=!0,t.originatingPeers=new Set,{message:r,originatingPeers:n}}shift(){this.history[this.history.length-1].forEach((e=>{const t=this.msgs.get(e.msgIdStr);null!=t&&(this.msgs.delete(e.msgIdStr),t.validated||this.notValidatedCount--)})),this.history.pop(),this.history.unshift([])}remove(e){const t=this.msgs.get(e);return null==t?null:(this.msgs.delete(e),t)}}function Yc(e){switch(e){case E.Ignore:return Fc.Ignore;case E.Reject:return Fc.Reject;default:throw new Error("Unreachable")}}!function(e){e.StrictSign="StrictSign",e.StrictNoSign="StrictNoSign"}(Oc||(Oc={})),function(e){e[e.Signing=0]="Signing",e[e.Anonymous=1]="Anonymous"}(Uc||(Uc={})),function(e){e.Error="error",e.Ignore="ignore",e.Reject="reject",e.Blacklisted="blacklisted"}(Fc||(Fc={})),function(e){e.InvalidSignature="invalid_signature",e.InvalidSeqno="invalid_seqno",e.InvalidPeerId="invalid_peerid",e.SignaturePresent="signature_present",e.SeqnoPresent="seqno_present",e.FromPresent="from_present",e.TransformFailed="transform_failed"}(Vc||(Vc={})),function(e){e.duplicate="duplicate",e.invalid="invalid",e.valid="valid"}($c||($c={})),function(e){e.forward="forward",e.publish="publish"}(Hc||(Hc={})),function(e){e.Fanout="fanout",e.Random="random",e.Subscribed="subscribed",e.Outbound="outbound",e.NotEnough="not_enough",e.Opportunistic="opportunistic"}(zc||(zc={})),function(e){e.Dc="disconnected",e.BadScore="bad_score",e.Prune="prune",e.Excess="excess"}(qc||(qc={})),function(e){e.GraftBackoff="graft_backoff",e.BrokenPromise="broken_promise",e.MessageDeficit="message_deficit",e.IPColocation="IP_colocation"}(jc||(jc={})),function(e){e.LowScore="low_score",e.MaxIhave="max_ihave",e.MaxIasked="max_iasked"}(Wc||(Wc={})),function(e){e.graylist="graylist",e.publish="publish",e.gossip="gossip",e.mesh="mesh"}(Kc||(Kc={}));class Jc extends Error{static name="InvalidPeerScoreParamsError";constructor(e="Invalid peer score params"){super(e),this.name="InvalidPeerScoreParamsError"}}Error;const Qc={topics:{},topicScoreCap:10,appSpecificScore:()=>0,appSpecificWeight:10,IPColocationFactorWeight:-5,IPColocationFactorThreshold:10,IPColocationFactorWhitelist:new Set,behaviourPenaltyWeight:-10,behaviourPenaltyThreshold:0,behaviourPenaltyDecay:.2,decayInterval:1e3,decayToZero:.1,retainScore:36e5},Zc={topicWeight:.5,timeInMeshWeight:1,timeInMeshQuantum:1,timeInMeshCap:3600,firstMessageDeliveriesWeight:1,firstMessageDeliveriesDecay:.5,firstMessageDeliveriesCap:2e3,meshMessageDeliveriesWeight:-1,meshMessageDeliveriesDecay:.5,meshMessageDeliveriesCap:100,meshMessageDeliveriesThreshold:20,meshMessageDeliveriesWindow:10,meshMessageDeliveriesActivation:5e3,meshFailurePenaltyWeight:-1,meshFailurePenaltyDecay:.5,invalidMessageDeliveriesWeight:-1,invalidMessageDeliveriesDecay:.3};function Xc(e={}){return{...Qc,...e,topics:null!=e.topics?Object.entries(e.topics).reduce(((e,[t,r])=>(e[t]=function(e={}){return{...Zc,...e}}(r),e)),{}):{}}}function el(e){if(e.topicWeight<0)throw new Jc("invalid topic weight; must be >= 0");if(0===e.timeInMeshQuantum)throw new Jc("invalid TimeInMeshQuantum; must be non zero");if(e.timeInMeshWeight<0)throw new Jc("invalid TimeInMeshWeight; must be positive (or 0 to disable)");if(0!==e.timeInMeshWeight&&e.timeInMeshQuantum<=0)throw new Jc("invalid TimeInMeshQuantum; must be positive");if(0!==e.timeInMeshWeight&&e.timeInMeshCap<=0)throw new Jc("invalid TimeInMeshCap; must be positive");if(e.firstMessageDeliveriesWeight<0)throw new Jc("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)");if(0!==e.firstMessageDeliveriesWeight&&(e.firstMessageDeliveriesDecay<=0||e.firstMessageDeliveriesDecay>=1))throw new Jc("invalid FirstMessageDeliveriesDecay; must be between 0 and 1");if(0!==e.firstMessageDeliveriesWeight&&e.firstMessageDeliveriesCap<=0)throw new Jc("invalid FirstMessageDeliveriesCap; must be positive");if(e.meshMessageDeliveriesWeight>0)throw new Jc("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)");if(0!==e.meshMessageDeliveriesWeight&&(e.meshMessageDeliveriesDecay<=0||e.meshMessageDeliveriesDecay>=1))throw new Jc("invalid MeshMessageDeliveriesDecay; must be between 0 and 1");if(0!==e.meshMessageDeliveriesWeight&&e.meshMessageDeliveriesCap<=0)throw new Jc("invalid MeshMessageDeliveriesCap; must be positive");if(0!==e.meshMessageDeliveriesWeight&&e.meshMessageDeliveriesThreshold<=0)throw new Jc("invalid MeshMessageDeliveriesThreshold; must be positive");if(e.meshMessageDeliveriesWindow<0)throw new Jc("invalid MeshMessageDeliveriesWindow; must be non-negative");if(0!==e.meshMessageDeliveriesWeight&&e.meshMessageDeliveriesActivation<1e3)throw new Jc("invalid MeshMessageDeliveriesActivation; must be at least 1s");if(e.meshFailurePenaltyWeight>0)throw new Jc("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)");if(0!==e.meshFailurePenaltyWeight&&(e.meshFailurePenaltyDecay<=0||e.meshFailurePenaltyDecay>=1))throw new Jc("invalid MeshFailurePenaltyDecay; must be between 0 and 1");if(e.invalidMessageDeliveriesWeight>0)throw new Jc("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)");if(e.invalidMessageDeliveriesDecay<=0||e.invalidMessageDeliveriesDecay>=1)throw new Jc("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1")}const tl={gossipThreshold:-10,publishThreshold:-50,graylistThreshold:-80,acceptPXThreshold:10,opportunisticGraftThreshold:20};function rl(e={}){return{...tl,...e}}function nl(e,t,r=()=>!0){const n=new Set;if(t<=0)return n;for(const s of e){if(n.size>=t)break;r(s)&&(n.add(s),e.delete(s))}return n}class sl extends Map{getDefault;constructor(e){super(),this.getDefault=e}getOrDefault(e){let t=super.get(e);return void 0===t&&(t=this.getDefault(),this.set(e,t)),t}}function il(e,t,r,n){let s=0;Object.entries(t.topics).forEach((([e,t])=>{const n=r.topics[e];if(void 0===n)return;let i=0;if(t.inMesh){let e=t.meshTime/n.timeInMeshQuantum;e>n.timeInMeshCap&&(e=n.timeInMeshCap),i+=e*n.timeInMeshWeight}let o=t.firstMessageDeliveries;if(o>n.firstMessageDeliveriesCap&&(o=n.firstMessageDeliveriesCap),i+=o*n.firstMessageDeliveriesWeight,t.meshMessageDeliveriesActive&&t.meshMessageDeliveries<n.meshMessageDeliveriesThreshold){const e=n.meshMessageDeliveriesThreshold-t.meshMessageDeliveries;i+=e*e*n.meshMessageDeliveriesWeight}i+=t.meshFailurePenalty*n.meshFailurePenaltyWeight,i+=t.invalidMessageDeliveries*t.invalidMessageDeliveries*n.invalidMessageDeliveriesWeight,s+=i*n.topicWeight})),r.topicScoreCap>0&&s>r.topicScoreCap&&(s=r.topicScoreCap);const i=r.appSpecificScore(e);if(s+=i*r.appSpecificWeight,t.knownIPs.forEach((e=>{if(r.IPColocationFactorWhitelist.has(e))return;const t=n.get(e),i=null!=t?t.size:0;if(i>r.IPColocationFactorThreshold){const e=i-r.IPColocationFactorThreshold;s+=e*e*r.IPColocationFactorWeight}})),t.behaviourPenalty>r.behaviourPenaltyThreshold){const e=t.behaviourPenalty-r.behaviourPenaltyThreshold;s+=e*e*r.behaviourPenaltyWeight}return s}var ol,al=r(2153);!function(e){e[e.unknown=0]="unknown",e[e.valid=1]="valid",e[e.invalid=2]="invalid",e[e.ignored=3]="ignored"}(ol||(ol={}));class cl{records;queue;constructor(){this.records=new Map,this.queue=new al}getRecord(e){return this.records.get(e)}ensureRecord(e){let t=this.records.get(e);if(null!=t)return t;t={status:ol.unknown,firstSeenTsMs:Date.now(),validated:0,peers:new Set},this.records.set(e,t);const r={msgId:e,expire:Date.now()+12e4};return this.queue.push(r),t}gc(){const e=Date.now();let t=this.queue.peekFront();for(;null!=t&&t.expire<e;)this.records.delete(t.msgId),this.queue.shift(),t=this.queue.peekFront()}clear(){this.records.clear(),this.queue.clear()}}class ll{params;metrics;peerStats=new Map;peerIPs=new sl((()=>new Set));scoreCache=new Map;deliveryRecords=new cl;_backgroundInterval;scoreCacheValidityMs;computeScore;log;constructor(e,t,r,n){this.params=e,this.metrics=t,function(e){for(const[t,r]of Object.entries(e.topics))try{el(r)}catch(e){throw new Jc(`invalid score parameters for topic ${t}: ${e.message}`)}if(e.topicScoreCap<0)throw new Jc("invalid topic score cap; must be positive (or 0 for no cap)");if(null===e.appSpecificScore||void 0===e.appSpecificScore)throw new Jc("missing application specific score function");if(e.IPColocationFactorWeight>0)throw new Jc("invalid IPColocationFactorWeight; must be negative (or 0 to disable)");if(0!==e.IPColocationFactorWeight&&e.IPColocationFactorThreshold<1)throw new Jc("invalid IPColocationFactorThreshold; must be at least 1");if(e.behaviourPenaltyWeight>0)throw new Jc("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)");if(0!==e.behaviourPenaltyWeight&&(e.behaviourPenaltyDecay<=0||e.behaviourPenaltyDecay>=1))throw new Jc("invalid BehaviourPenaltyDecay; must be between 0 and 1");if(e.decayInterval<1e3)throw new Jc("invalid DecayInterval; must be at least 1s");if(e.decayToZero<=0||e.decayToZero>=1)throw new Jc("invalid DecayToZero; must be between 0 and 1")}(e),this.scoreCacheValidityMs=n.scoreCacheValidityMs,this.computeScore=n.computeScore??il,this.log=r.forComponent("libp2p:gossipsub:score")}get size(){return this.peerStats.size}start(){null==this._backgroundInterval?(this._backgroundInterval=setInterval((()=>{this.background()}),this.params.decayInterval),this.log("started")):this.log("Peer score already running")}stop(){null!=this._backgroundInterval?(clearInterval(this._backgroundInterval),delete this._backgroundInterval,this.peerIPs.clear(),this.peerStats.clear(),this.deliveryRecords.clear(),this.log("stopped")):this.log("Peer score already stopped")}background(){this.refreshScores(),this.deliveryRecords.gc()}dumpPeerScoreStats(){return Object.fromEntries(Array.from(this.peerStats.entries()).map((([e,t])=>[e,t])))}messageFirstSeenTimestampMs(e){const t=this.deliveryRecords.getRecord(e);return null!=t?t.firstSeenTsMs:null}refreshScores(){const e=Date.now(),t=this.params.decayToZero;this.peerStats.forEach(((r,n)=>{r.connected?(Object.entries(r.topics).forEach((([r,n])=>{const s=this.params.topics[r];void 0!==s&&(n.firstMessageDeliveries*=s.firstMessageDeliveriesDecay,n.firstMessageDeliveries<t&&(n.firstMessageDeliveries=0),n.meshMessageDeliveries*=s.meshMessageDeliveriesDecay,n.meshMessageDeliveries<t&&(n.meshMessageDeliveries=0),n.meshFailurePenalty*=s.meshFailurePenaltyDecay,n.meshFailurePenalty<t&&(n.meshFailurePenalty=0),n.invalidMessageDeliveries*=s.invalidMessageDeliveriesDecay,n.invalidMessageDeliveries<t&&(n.invalidMessageDeliveries=0),n.inMesh&&(n.meshTime=e-n.graftTime,n.meshTime>s.meshMessageDeliveriesActivation&&(n.meshMessageDeliveriesActive=!0)))})),r.behaviourPenalty*=this.params.behaviourPenaltyDecay,r.behaviourPenalty<t&&(r.behaviourPenalty=0)):e>r.expire&&(this.removeIPsForPeer(n,r.knownIPs),this.peerStats.delete(n),this.scoreCache.delete(n))}))}score(e){this.metrics?.scoreFnCalls.inc();const t=this.peerStats.get(e);if(null==t)return 0;const r=Date.now(),n=this.scoreCache.get(e);if(null!=n&&n.cacheUntil>r)return n.score;this.metrics?.scoreFnRuns.inc();const s=this.computeScore(e,t,this.params,this.peerIPs),i=r+this.scoreCacheValidityMs;return null!=n?(this.metrics?.scoreCachedDelta.observe(Math.abs(s-n.score)),n.score=s,n.cacheUntil=i):this.scoreCache.set(e,{score:s,cacheUntil:i}),s}addPenalty(e,t,r){const n=this.peerStats.get(e);null!=n&&(n.behaviourPenalty+=t,this.metrics?.onScorePenalty(r))}addPeer(e){const t={connected:!0,expire:0,topics:{},knownIPs:new Set,behaviourPenalty:0};this.peerStats.set(e,t)}addIP(e,t){const r=this.peerStats.get(e);null!=r&&r.knownIPs.add(t),this.peerIPs.getOrDefault(t).add(e)}removeIP(e,t){const r=this.peerStats.get(e);null!=r&&r.knownIPs.delete(t);const n=this.peerIPs.get(t);null!=n&&(n.delete(e),0===n.size&&this.peerIPs.delete(t))}removePeer(e){const t=this.peerStats.get(e);if(null!=t){if(this.score(e)>0)return this.removeIPsForPeer(e,t.knownIPs),void this.peerStats.delete(e);Object.entries(t.topics).forEach((([e,t])=>{t.firstMessageDeliveries=0;const r=this.params.topics[e].meshMessageDeliveriesThreshold;if(t.inMesh&&t.meshMessageDeliveriesActive&&t.meshMessageDeliveries<r){const e=r-t.meshMessageDeliveries;t.meshFailurePenalty+=e*e}t.inMesh=!1,t.meshMessageDeliveriesActive=!1})),t.connected=!1,t.expire=Date.now()+this.params.retainScore}}graft(e,t){const r=this.peerStats.get(e);if(null!=r){const e=this.getPtopicStats(r,t);null!=e&&(e.inMesh=!0,e.graftTime=Date.now(),e.meshTime=0,e.meshMessageDeliveriesActive=!1)}}prune(e,t){const r=this.peerStats.get(e);if(null!=r){const e=this.getPtopicStats(r,t);if(null!=e){const r=this.params.topics[t].meshMessageDeliveriesThreshold;if(e.meshMessageDeliveriesActive&&e.meshMessageDeliveries<r){const t=r-e.meshMessageDeliveries;e.meshFailurePenalty+=t*t}e.meshMessageDeliveriesActive=!1,e.inMesh=!1}}}validateMessage(e){this.deliveryRecords.ensureRecord(e)}deliverMessage(e,t,r){this.markFirstMessageDelivery(e,r);const n=this.deliveryRecords.ensureRecord(t),s=Date.now();n.status===ol.unknown?(n.status=ol.valid,n.validated=s,n.peers.forEach((t=>{t!==e.toString()&&this.markDuplicateMessageDelivery(t,r)}))):this.log("unexpected delivery: message from %s was first seen %s ago and has delivery status %s",e,s-n.firstSeenTsMs,ol[n.status])}rejectInvalidMessage(e,t){this.markInvalidMessageDelivery(e,t)}rejectMessage(e,t,r,n){switch(n){case Fc.Error:return void this.markInvalidMessageDelivery(e,r);case Fc.Blacklisted:return}const s=this.deliveryRecords.ensureRecord(t);if(s.status===ol.unknown){if(n===Fc.Ignore)return s.status=ol.ignored,void s.peers.clear();s.status=ol.invalid,this.markInvalidMessageDelivery(e,r),s.peers.forEach((e=>{this.markInvalidMessageDelivery(e,r)})),s.peers.clear()}else this.log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d",e,Date.now()-s.firstSeenTsMs,ol[s.status])}duplicateMessage(e,t,r){const n=this.deliveryRecords.ensureRecord(t);if(!n.peers.has(e))switch(n.status){case ol.unknown:n.peers.add(e);break;case ol.valid:n.peers.add(e),this.markDuplicateMessageDelivery(e,r,n.validated);break;case ol.invalid:this.markInvalidMessageDelivery(e,r);case ol.ignored:}}markInvalidMessageDelivery(e,t){const r=this.peerStats.get(e);if(null!=r){const e=this.getPtopicStats(r,t);null!=e&&(e.invalidMessageDeliveries+=1)}}markFirstMessageDelivery(e,t){const r=this.peerStats.get(e);if(null!=r){const e=this.getPtopicStats(r,t);if(null!=e){let r=this.params.topics[t].firstMessageDeliveriesCap;e.firstMessageDeliveries=Math.min(r,e.firstMessageDeliveries+1),e.inMesh&&(r=this.params.topics[t].meshMessageDeliveriesCap,e.meshMessageDeliveries=Math.min(r,e.meshMessageDeliveries+1))}}}markDuplicateMessageDelivery(e,t,r){const n=this.peerStats.get(e);if(null!=n){const e=void 0!==r?Date.now():0,s=this.getPtopicStats(n,t);if(null!=s&&s.inMesh){const n=this.params.topics[t];if(void 0!==r){const s=e-r,i=s>n.meshMessageDeliveriesWindow;if(this.metrics?.onDuplicateMsgDelivery(t,s,i),i)return}const i=n.meshMessageDeliveriesCap;s.meshMessageDeliveries=Math.min(i,s.meshMessageDeliveries+1)}}}removeIPsForPeer(e,t){for(const r of t){const t=this.peerIPs.get(r);null!=t&&(t.delete(e),0===t.size&&this.peerIPs.delete(r))}}getPtopicStats(e,t){let r=e.topics[t];return void 0!==r?r:void 0!==this.params.topics[t]?(r={inMesh:!1,graftTime:0,meshTime:0,firstMessageDeliveries:0,meshMessageDeliveries:0,meshMessageDeliveriesActive:!1,meshFailurePenalty:0,invalidMessageDeliveries:0},e.topics[t]=r,r):null}}function ul(e,t,r,n,s){let i=0;const o=new Map;if(Object.entries(t.topics).forEach((([e,t])=>{const n=s.get(e)??"unknown",a=r.topics[e];if(void 0===a)return;let c=o.get(n);null==c&&(c={p1w:0,p2w:0,p3w:0,p3bw:0,p4w:0},o.set(n,c));let l=0,u=0,h=0,d=0,p=0;t.inMesh&&(l+=Math.max(t.meshTime/a.timeInMeshQuantum,a.timeInMeshCap)*a.timeInMeshWeight);let f=t.firstMessageDeliveries;if(f>a.firstMessageDeliveriesCap&&(f=a.firstMessageDeliveriesCap),u+=f*a.firstMessageDeliveriesWeight,t.meshMessageDeliveriesActive&&t.meshMessageDeliveries<a.meshMessageDeliveriesThreshold){const e=a.meshMessageDeliveriesThreshold-t.meshMessageDeliveries;h+=e*e*a.meshMessageDeliveriesWeight}d+=t.meshFailurePenalty*a.meshFailurePenaltyWeight,p+=t.invalidMessageDeliveries*t.invalidMessageDeliveries*a.invalidMessageDeliveriesWeight,i+=(l+u+h+d+p)*a.topicWeight,c.p1w+=l,c.p2w+=u,c.p3w+=h,c.p3bw+=d,c.p4w+=p})),r.topicScoreCap>0&&i>r.topicScoreCap){i=r.topicScoreCap;const e=r.topicScoreCap/i;for(const t of o.values())t.p1w*=e,t.p2w*=e,t.p3w*=e,t.p3bw*=e,t.p4w*=e}let a=0,c=0,l=0;return a+=r.appSpecificScore(e)*r.appSpecificWeight,t.knownIPs.forEach((e=>{if(r.IPColocationFactorWhitelist.has(e))return;const t=n.get(e),s=null!=t?t.size:0;if(s>r.IPColocationFactorThreshold){const e=s-r.IPColocationFactorThreshold;c+=e*e*r.IPColocationFactorWeight}})),l+=t.behaviourPenalty*t.behaviourPenalty*r.behaviourPenaltyWeight,i+=a+c+l,{byTopic:o,p5w:a,p6w:c,p7w:l,score:i}}class hl{rawStream;pushable;closeController;maxBufferSize;constructor(e,t,r){this.rawStream=e,this.pushable=kc(),this.closeController=new AbortController,this.maxBufferSize=r.maxBufferSize??1/0,this.closeController.signal.addEventListener("abort",(()=>{e.close().catch((t=>{e.abort(t)}))})),Ic(this.pushable,this.rawStream).catch(t)}get protocol(){return this.rawStream.protocol}push(e){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(hc.single(e))}pushPrefixed(e){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(e)}async close(){this.closeController.abort(),await this.pushable.return()}}class dl{source;rawStream;closeController;constructor(e,t={}){this.rawStream=e,this.closeController=new AbortController,this.closeController.signal.addEventListener("abort",(()=>{e.close().catch((t=>{e.abort(t)}))})),this.source=Ic(this.rawStream,(e=>wc(e,t)))}async close(){this.closeController.abort()}}class pl{gossipsubIWantFollowupMs;msgIdToStrFn;metrics;promises=new Map;requestMsByMsg=new Map;requestMsByMsgExpire;constructor(e,t,r){this.gossipsubIWantFollowupMs=e,this.msgIdToStrFn=t,this.metrics=r,this.requestMsByMsgExpire=10*e}get size(){return this.promises.size}get requestMsByMsgSize(){return this.requestMsByMsg.size}addPromise(e,t){const r=t[Math.floor(Math.random()*t.length)],n=this.msgIdToStrFn(r);let s=this.promises.get(n);null==s&&(s=new Map,this.promises.set(n,s));const i=Date.now();s.has(e)||(s.set(e,i+this.gossipsubIWantFollowupMs),null!=this.metrics&&(this.metrics.iwantPromiseStarted.inc(1),this.requestMsByMsg.has(n)||this.requestMsByMsg.set(n,i)))}getBrokenPromises(){const e=Date.now(),t=new Map;let r=0;return this.promises.forEach(((n,s)=>{n.forEach(((s,i)=>{s<e&&(t.set(i,(t.get(i)??0)+1),n.delete(i),r++)})),0===n.size&&this.promises.delete(s)})),this.metrics?.iwantPromiseBroken.inc(r),t}deliverMessage(e,t=!1){this.trackMessage(e);const r=this.promises.get(e);null!=r&&(this.promises.delete(e),null!=this.metrics&&(this.metrics.iwantPromiseResolved.inc(1),t&&this.metrics.iwantPromiseResolvedFromDuplicate.inc(1),this.metrics.iwantPromiseResolvedPeers.inc(r.size)))}rejectMessage(e,t){this.trackMessage(e),t!==Fc.Error&&this.promises.delete(e)}clear(){this.promises.clear()}prune(){const e=Date.now()-this.requestMsByMsgExpire;let t=0;for(const[r,n]of this.requestMsByMsg.entries()){if(!(n<e))break;this.requestMsByMsg.delete(r),t++}this.metrics?.iwantMessagePruned.inc(t)}trackMessage(e){if(null!=this.metrics){const t=this.requestMsByMsg.get(e);void 0!==t&&(this.metrics.iwantPromiseDeliveryTime.observe((Date.now()-t)/1e3),this.requestMsByMsg.delete(e))}}}function fl(e){if(isNaN(e)||e<=0)throw new M("random bytes length must be a Number bigger than 0");return function(e=32){if($s&&"function"==typeof $s.getRandomValues)return $s.getRandomValues(new Uint8Array(e));if($s&&"function"==typeof $s.randomBytes)return $s.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}(e)}const gl=ds("libp2p-pubsub:");function ml(e=[],t){return{subscriptions:[],messages:e,control:void 0!==t?{graft:t.graft??[],prune:t.prune??[],ihave:t.ihave??[],iwant:t.iwant??[],idontwant:t.idontwant??[]}:void 0}}function yl(e){return void 0===e.control&&(e.control={graft:[],prune:[],ihave:[],iwant:[],idontwant:[]}),e}function wl(e){return ia(e,"base64")}function bl(e){if(e.length<=1)return e;for(let t=0;t<e.length;t++){const r=Math.floor(Math.random()*Math.floor(e.length)),n=e[t];e[t]=e[r],e[r]=n}return e}function vl(e){if("signed"!==e.type)throw new Error("expected signed message type");if(null==e.sequenceNumber)throw Error("missing seqno field");return((e,t)=>{const r=ds(t.toString(16).padStart(16,"0"),"base16"),n=ja(e),s=new Uint8Array(n.byteLength+r.length);return s.set(n,0),s.set(r,n.byteLength),s})(e.from.publicKey??e.key,e.sequenceNumber)}async function Sl(e){return is.encode(e.data)}const El=new class{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return void 0===r&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically((()=>{const t=this.readChar();if(t===e)return t}))}readSeparator(e,t,r){return this.readAtomically((()=>{if(!(t>0&&void 0===this.readGivenChar(e)))return r()}))}readNumber(e,t,r,n){return this.readAtomically((()=>{let s=0,i=0;const o=this.peekChar();if(void 0===o)return;const a="0"===o,c=2**(8*n)-1;for(;;){const r=this.readAtomically((()=>{const t=this.readChar();if(void 0===t)return;const r=Number.parseInt(t,e);return Number.isNaN(r)?void 0:r}));if(void 0===r)break;if(s*=e,s+=r,s>c)return;if(i+=1,void 0!==t&&i>t)return}return 0===i||!r&&a&&i>1?void 0:s}))}readIPv4Addr(){return this.readAtomically((()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,(()=>this.readNumber(10,3,!1,1)));if(void 0===r)return;e[t]=r}return e}))}readIPv6Addr(){const e=e=>{for(let t=0;t<e.length/2;t++){const r=2*t;if(t<e.length-3){const n=this.readSeparator(":",t,(()=>this.readIPv4Addr()));if(void 0!==n)return e[r]=n[0],e[r+1]=n[1],e[r+2]=n[2],e[r+3]=n[3],[r+4,!0]}const n=this.readSeparator(":",t,(()=>this.readNumber(16,4,!0,2)));if(void 0===n)return[r,!1];e[r]=n>>8,e[r+1]=255&n}return[e.length,!1]};return this.readAtomically((()=>{const t=new Uint8Array(16),[r,n]=e(t);if(16===r)return t;if(n)return;if(void 0===this.readGivenChar(":"))return;if(void 0===this.readGivenChar(":"))return;const s=new Uint8Array(14),i=16-(r+2),[o]=e(s.subarray(0,i));return t.set(s.subarray(0,o),16-o),t}))}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};function kl(e){if(!(e.length>15))return El.new(e).parseWith((()=>El.readIPv4Addr()))}function Al(e){if(e.includes("%")&&(e=e.split("%")[0]),!(e.length>45))return El.new(e).parseWith((()=>El.readIPv6Addr()))}function Il(e){if(e.includes("%")&&(e=e.split("%")[0]),!(e.length>45))return El.new(e).parseWith((()=>El.readIPAddr()))}const _l=(parseInt("0xFFFF",16),new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]));function Cl(e,t){16===t.length&&4===e.length&&function(e){let t=0;for(const r of e)if(!(t<0)){if(t>11)break;if(255!==r)return!1;t++}return!0}(t)&&(t=t.slice(12)),4===t.length&&16===e.length&&function(e,t){let r=0;for(const n of e)if(!(r<0)){if(r>11)break;if(n!==t[r])return!1;r++}return!0}(e,_l)&&(e=e.slice(12));const r=e.length;if(r!=t.length)throw new Error("Failed to mask ip");const n=new Uint8Array(r);for(let s=0;s<r;s++)n[s]=e[s]&t[s];return n}function xl(e,t){if(32!==t&&128!==t)throw new Error("Invalid CIDR mask");if(e<0||e>t)throw new Error("Invalid CIDR mask");const r=t/8,n=new Uint8Array(r);for(let t=0;t<r;t++)e>=8?(n[t]=255,e-=8):(n[t]=255-(255>>e),e=0);return n}class Tl{constructor(e,t){if(null==t)({network:this.network,mask:this.mask}=function(e){const[t,r]=e.split("/");if(!t||!r)throw new Error("Failed to parse given CIDR: "+e);let n=4,s=kl(t);if(null==s&&(n=16,s=Al(t),null==s))throw new Error("Failed to parse given CIDR: "+e);const i=parseInt(r,10);if(Number.isNaN(i)||String(i).length!==r.length||i<0||i>8*n)throw new Error("Failed to parse given CIDR: "+e);const o=xl(i,8*n);return{network:Cl(s,o),mask:o}}(e));else{const r=Il(e);if(null==r)throw new Error("Failed to parse network");t=String(t);const n=parseInt(t,10);if(Number.isNaN(n)||String(n).length!==t.length||n<0||n>8*r.length){const e=Il(t);if(null==e)throw new Error("Failed to parse mask");this.mask=e}else this.mask=xl(n,8*r.length);this.network=Cl(r,this.mask)}}contains(e){return function(e,t){if("string"==typeof t&&(t=Il(t)),null==t)throw new Error("Invalid ip");if(t.length!==e.network.length)return!1;for(let r=0;r<t.length;r++)if((e.network[r]&e.mask[r])!=(t[r]&e.mask[r]))return!1;return!0}({network:this.network,mask:this.mask},e)}toString(){const e=function(e){let t=0;for(let[r,n]of e.entries()){if(255!==n){for(;128&n;)t++,n<<=1;if(128&n)return-1;for(let t=r+1;t<e.length;t++)if(0!=e[t])return-1;break}t+=8}return t}(this.mask),t=-1!==e?String(e):function(e){let t="0x";for(const r of e)t+=(r>>4).toString(16)+(15&r).toString(16);return t}(this.mask);return function(e){switch(e.length){case 4:return e.join(".");case 16:{const t=[];for(let r=0;r<e.length;r++)r%2==0&&t.push(e[r].toString(16).padStart(2,"0")+e[r+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw new Error("Invalid ip length")}}(this.network)+"/"+t}}function Ml(e){return Boolean(kl(e))}function Pl(e){return Boolean(Al(e))}function Dl(e){return Boolean(Il(e))}const Nl=Ml,Rl=Pl,Bl=function(e){let t=0;if(e=e.toString().trim(),Nl(e)){const r=new Uint8Array(t+4);return e.split(/\./g).forEach((e=>{r[t++]=255&parseInt(e,10)})),r}if(Rl(e)){const r=e.split(":",8);let n;for(n=0;n<r.length;n++){let e;Nl(r[n])&&(e=Bl(r[n]),r[n]=ia(e.slice(0,2),"base16")),null!=e&&++n<8&&r.splice(n,0,ia(e.slice(2,4),"base16"))}if(""===r[0])for(;r.length<8;)r.unshift("0");else if(""===r[r.length-1])for(;r.length<8;)r.push("0");else if(r.length<8){for(n=0;n<r.length&&""!==r[n];n++);const e=[n,1];for(n=9-r.length;n>0;n--)e.push("0");r.splice.apply(r,e)}const s=new Uint8Array(t+16);for(n=0;n<r.length;n++){const e=parseInt(r[n],16);s[t++]=e>>8&255,s[t++]=255&e}return s}throw new Error("invalid ip address")},Ll=-1,Ol={},Ul={};function Fl(e){if("number"==typeof e){if(null!=Ul[e])return Ul[e];throw new Error(`no protocol with code: ${e}`)}if("string"==typeof e){if(null!=Ol[e])return Ol[e];throw new Error(`no protocol with name: ${e}`)}throw new Error("invalid protocol id type: "+typeof e)}[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Ll,"ip6zone"],[43,8,"ipcidr"],[53,Ll,"dns",!0],[54,Ll,"dns4",!0],[55,Ll,"dns6",!0],[56,Ll,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Ll,"unix",!1,!0],[421,Ll,"ipfs"],[421,Ll,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Ll,"garlic64"],[448,0,"tls"],[449,Ll,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Ll,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Ll,"http-path"],[777,Ll,"memory"]].forEach((e=>{const t=function(e,t,r,n,s){return{code:e,size:t,name:r,resolvable:Boolean(n),path:Boolean(s)}}(...e);Ul[t.code]=t,Ol[t.name]=t}));const Vl=Fl("ip4"),$l=Fl("ip6"),Hl=Fl("ipcidr");function zl(e,t){switch(Fl(e).code){case 4:case 41:return function(e){const t=function(e,t=0,r){t=~~t,r=r??e.length-t;const n=new DataView(e.buffer);if(4===r){const n=[];for(let s=0;s<r;s++)n.push(e[t+s]);return n.join(".")}if(16===r){const e=[];for(let s=0;s<r;s+=2)e.push(n.getUint16(t+s).toString(16));return e.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""}(e,0,e.length);if(null==t)throw new Error("ipBuff is required");if(!Dl(t))throw new Error("invalid ip address");return t}(t);case 42:case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Jl(t);case 43:return ia(t,"base10");case 6:case 273:case 33:case 132:return Gl(t).toString();case 421:return function(e){const t=gn(e),r=e.slice(hn(t));if(r.length!==t)throw new Error("inconsistent lengths");return ia(r,"base58btc")}(t);case 444:case 445:return function(e){const t=e.slice(0,e.length-2),r=e.slice(e.length-2);return`${ia(t,"base32")}:${Gl(r)}`}(t);case 466:return function(e){const t=gn(e),r=e.slice(hn(t));if(r.length!==t)throw new Error("inconsistent lengths");return"u"+ia(r,"base64url")}(t);case 481:return globalThis.encodeURIComponent(Jl(t));default:return ia(t,"base16")}}function ql(e,t){switch(Fl(e).code){case 4:case 41:return function(e){if(!Dl(e))throw new Error("invalid ip address");return Bl(e)}(t);case 42:case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Yl(t);case 43:return ds(t,"base10");case 6:case 273:case 33:case 132:return Kl(parseInt(t,10));case 421:return function(e){let t;t="Q"===e[0]||"1"===e[0]?He(ue.decode(`z${e}`)).bytes:Ke.parse(e).multihash.bytes;const r=Uint8Array.from(fn(t.length));return sc([r,t],r.length+t.length)}(t);case 444:return function(e){const t=e.split(":");if(2!==t.length)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(16!==t[0].length)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const r=de.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Kl(n);return sc([r,s],r.length+s.length)}(t);case 445:return function(e){const t=e.split(":");if(2!==t.length)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(56!==t[0].length)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const r=de.decode(`b${t[0]}`),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Kl(n);return sc([r,s],r.length+s.length)}(t);case 466:return function(e){const t=Wl.decode(e),r=Uint8Array.from(fn(t.length));return sc([r,t],r.length+t.length)}(t);case 481:return Yl(globalThis.decodeURIComponent(t));default:return ds(t,"base16")}}const jl=Object.values(as).map((e=>e.decoder)),Wl=function(){let e=jl[0].or(jl[1]);return jl.slice(2).forEach((t=>e=e.or(t))),e}();function Kl(e){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,e),new Uint8Array(t)}function Gl(e){return new DataView(e.buffer).getUint16(e.byteOffset)}function Yl(e){const t=ds(e),r=Uint8Array.from(fn(t.length));return sc([r,t],r.length+t.length)}function Jl(e){const t=gn(e);if((e=e.slice(hn(t))).length!==t)throw new Error("inconsistent lengths");return ia(e)}var Ql,Zl;!function(e){e[e.ip4=4]="ip4",e[e.ip6=41]="ip6"}(Ql||(Ql={}));class Xl{entries=new Map;validityMs;constructor(e){this.validityMs=e.validityMs}get size(){return this.entries.size}put(e,t){return!!this.entries.has(e)||(this.entries.set(e,{value:t,validUntilMs:Date.now()+this.validityMs}),!1)}prune(){const e=Date.now();for(const[t,r]of this.entries.entries()){if(!(r.validUntilMs<e))break;this.entries.delete(t)}}has(e){return this.entries.has(e)}get(e){const t=this.entries.get(e);return null!=t&&t.validUntilMs>=Date.now()?t.value:void 0}clear(){this.entries.clear()}}!function(e){e[e.started=0]="started",e[e.stopped=1]="stopped"}(Zl||(Zl={}));class eu extends b{globalSignaturePolicy;multicodecs=[Nc,"/meshsub/1.1.0",Dc];publishConfig;dataTransform;peers=new Set;streamsInbound=new Map;streamsOutbound=new Map;outboundInflightQueue=kc({objectMode:!0});direct=new Set;floodsubPeers=new Set;seenCache;acceptFromWhitelist=new Map;topics=new Map;subscriptions=new Set;mesh=new Map;fanout=new Map;fanoutLastpub=new Map;gossip=new Map;control=new Map;peerhave=new Map;iasked=new Map;backoff=new Map;outbound=new Map;msgIdFn;fastMsgIdFn;msgIdToStrFn;fastMsgIdCache;publishedMessageIds;mcache;score;topicValidators=new Map;log;heartbeatTicks=0;gossipTracer;idontwantCounts=new Map;idontwants=new Map;components;directPeerInitial=null;static multicodec=Nc;opts;decodeRpcLimits;metrics;status={code:Zl.stopped};maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;allowedTopics;heartbeatTimer=null;constructor(e,t={}){super();const r={fallbackToFloodsub:!0,floodPublish:!0,batchPublish:!1,tagMeshPeers:!0,doPX:!1,directPeers:[],D:6,Dlo:4,Dhi:12,Dscore:4,Dout:2,Dlazy:6,heartbeatInterval:1e3,fanoutTTL:6e4,mcacheLength:5,mcacheGossip:3,seenTTL:12e4,gossipsubIWantFollowupMs:3e3,prunePeers:16,pruneBackoff:6e4,unsubcribeBackoff:1e4,graftFloodThreshold:1e4,opportunisticGraftPeers:2,opportunisticGraftTicks:60,directConnectTicks:300,gossipFactor:.25,idontwantMinDataSize:512,idontwantMaxMessages:512,...t,scoreParams:Xc(t.scoreParams),scoreThresholds:rl(t.scoreThresholds)};if(this.components=e,this.decodeRpcLimits=r.decodeRpcLimits??Bc,this.globalSignaturePolicy=r.globalSignaturePolicy??v,r.fallbackToFloodsub&&this.multicodecs.push(Pc),this.log=e.logger.forComponent(r.debugName??"libp2p:gossipsub"),this.opts=r,this.direct=new Set(r.directPeers.map((e=>e.id.toString()))),this.seenCache=new Xl({validityMs:r.seenTTL}),this.publishedMessageIds=new Xl({validityMs:r.seenTTL}),null!=t.msgIdFn)this.msgIdFn=t.msgIdFn;else switch(this.globalSignaturePolicy){case v:this.msgIdFn=vl;break;case S:this.msgIdFn=Sl;break;default:throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`)}if(null!=t.fastMsgIdFn&&(this.fastMsgIdFn=t.fastMsgIdFn,this.fastMsgIdCache=new Xl({validityMs:r.seenTTL})),this.msgIdToStrFn=t.msgIdToStrFn??wl,this.mcache=t.messageCache??new Gc(r.mcacheGossip,r.mcacheLength,this.msgIdToStrFn),null!=t.dataTransform&&(this.dataTransform=t.dataTransform),null!=t.metricsRegister){if(null==t.metricsTopicStrToLabel)throw Error("Must set metricsTopicStrToLabel with metrics");const e=Math.max(...Object.values(r.scoreParams.topics).map((e=>e.meshMessageDeliveriesWindow)),1e3),n=function(e,t,r){return{protocolsEnabled:e.gauge({name:"gossipsub_protocol",help:"Status of enabled protocols",labelNames:["protocol"]}),topicSubscriptionStatus:e.gauge({name:"gossipsub_topic_subscription_status",help:"Status of our subscription to this topic",labelNames:["topicStr"]}),topicPeersCount:e.gauge({name:"gossipsub_topic_peer_count",help:"Number of peers subscribed to each topic",labelNames:["topicStr"]}),meshPeerCounts:e.gauge({name:"gossipsub_mesh_peer_count",help:"Number of peers in our mesh",labelNames:["topicStr"]}),meshPeerInclusionEventsFanout:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_fanout_total",help:"Number of times we include peers in a topic mesh for fanout reasons",labelNames:["topic"]}),meshPeerInclusionEventsRandom:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_random_total",help:"Number of times we include peers in a topic mesh for random reasons",labelNames:["topic"]}),meshPeerInclusionEventsSubscribed:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_subscribed_total",help:"Number of times we include peers in a topic mesh for subscribed reasons",labelNames:["topic"]}),meshPeerInclusionEventsOutbound:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_outbound_total",help:"Number of times we include peers in a topic mesh for outbound reasons",labelNames:["topic"]}),meshPeerInclusionEventsNotEnough:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_not_enough_total",help:"Number of times we include peers in a topic mesh for not_enough reasons",labelNames:["topic"]}),meshPeerInclusionEventsOpportunistic:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_opportunistic_total",help:"Number of times we include peers in a topic mesh for opportunistic reasons",labelNames:["topic"]}),meshPeerInclusionEventsUnknown:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_unknown_total",help:"Number of times we include peers in a topic mesh for unknown reasons",labelNames:["topic"]}),meshPeerChurnEventsDisconnected:e.gauge({name:"gossipsub_peer_churn_events_disconnected_total",help:"Number of times we remove peers in a topic mesh for disconnected reasons",labelNames:["topic"]}),meshPeerChurnEventsBadScore:e.gauge({name:"gossipsub_peer_churn_events_bad_score_total",help:"Number of times we remove peers in a topic mesh for bad_score reasons",labelNames:["topic"]}),meshPeerChurnEventsPrune:e.gauge({name:"gossipsub_peer_churn_events_prune_total",help:"Number of times we remove peers in a topic mesh for prune reasons",labelNames:["topic"]}),meshPeerChurnEventsExcess:e.gauge({name:"gossipsub_peer_churn_events_excess_total",help:"Number of times we remove peers in a topic mesh for excess reasons",labelNames:["topic"]}),meshPeerChurnEventsUnknown:e.gauge({name:"gossipsub_peer_churn_events_unknown_total",help:"Number of times we remove peers in a topic mesh for unknown reasons",labelNames:["topic"]}),peersPerProtocol:e.gauge({name:"gossipsub_peers_per_protocol_count",help:"Peers connected for each topic",labelNames:["protocol"]}),heartbeatDuration:e.histogram({name:"gossipsub_heartbeat_duration_seconds",help:"The time it takes to complete one iteration of the heartbeat",buckets:[.01,.1,1]}),heartbeatSkipped:e.gauge({name:"gossipsub_heartbeat_skipped",help:"Heartbeat run took longer than heartbeat interval so next is skipped"}),acceptedMessagesTotal:e.gauge({name:"gossipsub_accepted_messages_total",help:"Total accepted messages for each topic",labelNames:["topic"]}),ignoredMessagesTotal:e.gauge({name:"gossipsub_ignored_messages_total",help:"Total ignored messages for each topic",labelNames:["topic"]}),rejectedMessagesTotal:e.gauge({name:"gossipsub_rejected_messages_total",help:"Total rejected messages for each topic",labelNames:["topic"]}),unknownValidationResultsTotal:e.gauge({name:"gossipsub_unknown_validation_results_total",help:"Total unknown validation results for each topic",labelNames:["topic"]}),asyncValidationMcacheHit:e.gauge({name:"gossipsub_async_validation_mcache_hit_total",help:"Async validation result reported by the user layer",labelNames:["hit"]}),asyncValidationDelayFromFirstSeenSec:e.histogram({name:"gossipsub_async_validation_delay_from_first_seen",help:"Async validation report delay from first seen in second",buckets:[.01,.03,.1,.3,1,3,10]}),asyncValidationUnknownFirstSeen:e.gauge({name:"gossipsub_async_validation_unknown_first_seen_count_total",help:"Async validation report unknown first seen value for message"}),peerReadStreamError:e.gauge({name:"gossipsub_peer_read_stream_err_count_total",help:"Peer read stream error"}),rpcRecvBytes:e.gauge({name:"gossipsub_rpc_recv_bytes_total",help:"RPC recv"}),rpcRecvCount:e.gauge({name:"gossipsub_rpc_recv_count_total",help:"RPC recv"}),rpcRecvSubscription:e.gauge({name:"gossipsub_rpc_recv_subscription_total",help:"RPC recv"}),rpcRecvMessage:e.gauge({name:"gossipsub_rpc_recv_message_total",help:"RPC recv"}),rpcRecvControl:e.gauge({name:"gossipsub_rpc_recv_control_total",help:"RPC recv"}),rpcRecvIHave:e.gauge({name:"gossipsub_rpc_recv_ihave_total",help:"RPC recv"}),rpcRecvIWant:e.gauge({name:"gossipsub_rpc_recv_iwant_total",help:"RPC recv"}),rpcRecvGraft:e.gauge({name:"gossipsub_rpc_recv_graft_total",help:"RPC recv"}),rpcRecvPrune:e.gauge({name:"gossipsub_rpc_recv_prune_total",help:"RPC recv"}),rpcDataError:e.gauge({name:"gossipsub_rpc_data_err_count_total",help:"RPC data error"}),rpcRecvError:e.gauge({name:"gossipsub_rpc_recv_err_count_total",help:"RPC recv error"}),rpcRecvNotAccepted:e.gauge({name:"gossipsub_rpc_rcv_not_accepted_total",help:"Total count of RPC dropped because acceptFrom() == false"}),rpcSentBytes:e.gauge({name:"gossipsub_rpc_sent_bytes_total",help:"RPC sent"}),rpcSentCount:e.gauge({name:"gossipsub_rpc_sent_count_total",help:"RPC sent"}),rpcSentSubscription:e.gauge({name:"gossipsub_rpc_sent_subscription_total",help:"RPC sent"}),rpcSentMessage:e.gauge({name:"gossipsub_rpc_sent_message_total",help:"RPC sent"}),rpcSentControl:e.gauge({name:"gossipsub_rpc_sent_control_total",help:"RPC sent"}),rpcSentIHave:e.gauge({name:"gossipsub_rpc_sent_ihave_total",help:"RPC sent"}),rpcSentIWant:e.gauge({name:"gossipsub_rpc_sent_iwant_total",help:"RPC sent"}),rpcSentGraft:e.gauge({name:"gossipsub_rpc_sent_graft_total",help:"RPC sent"}),rpcSentPrune:e.gauge({name:"gossipsub_rpc_sent_prune_total",help:"RPC sent"}),rpcSentIDontWant:e.gauge({name:"gossipsub_rpc_sent_idontwant_total",help:"RPC sent"}),msgPublishCount:e.gauge({name:"gossipsub_msg_publish_count_total",help:"Total count of msg published by topic",labelNames:["topic"]}),msgPublishPeersByTopic:e.gauge({name:"gossipsub_msg_publish_peers_total",help:"Total count of peers that we publish a msg to",labelNames:["topic"]}),directPeersPublishedTotal:e.gauge({name:"gossipsub_direct_peers_published_total",help:"Total direct peers that we publish a msg to",labelNames:["topic"]}),floodsubPeersPublishedTotal:e.gauge({name:"gossipsub_floodsub_peers_published_total",help:"Total floodsub peers that we publish a msg to",labelNames:["topic"]}),meshPeersPublishedTotal:e.gauge({name:"gossipsub_mesh_peers_published_total",help:"Total mesh peers that we publish a msg to",labelNames:["topic"]}),fanoutPeersPublishedTotal:e.gauge({name:"gossipsub_fanout_peers_published_total",help:"Total fanout peers that we publish a msg to",labelNames:["topic"]}),msgPublishBytes:e.gauge({name:"gossipsub_msg_publish_bytes_total",help:"Total count of msg publish data.length bytes",labelNames:["topic"]}),msgPublishTime:e.histogram({name:"gossipsub_msg_publish_seconds",help:"Total time in seconds to publish a message",buckets:[.001,.002,.005,.01,.1,.5,1],labelNames:["topic"]}),msgForwardCount:e.gauge({name:"gossipsub_msg_forward_count_total",help:"Total count of msg forwarded by topic",labelNames:["topic"]}),msgForwardPeers:e.gauge({name:"gossipsub_msg_forward_peers_total",help:"Total count of peers that we forward a msg to",labelNames:["topic"]}),msgReceivedPreValidation:e.gauge({name:"gossipsub_msg_received_prevalidation_total",help:"Total count of recv msgs before any validation",labelNames:["topic"]}),msgReceivedError:e.gauge({name:"gossipsub_msg_received_error_total",help:"Total count of recv msgs error",labelNames:["topic"]}),prevalidationInvalidTotal:e.gauge({name:"gossipsub_pre_validation_invalid_total",help:"Total count of invalid messages received",labelNames:["topic"]}),prevalidationValidTotal:e.gauge({name:"gossipsub_pre_validation_valid_total",help:"Total count of valid messages received",labelNames:["topic"]}),prevalidationDuplicateTotal:e.gauge({name:"gossipsub_pre_validation_duplicate_total",help:"Total count of duplicate messages received",labelNames:["topic"]}),prevalidationUnknownTotal:e.gauge({name:"gossipsub_pre_validation_unknown_status_total",help:"Total count of unknown_status messages received",labelNames:["topic"]}),msgReceivedInvalid:e.gauge({name:"gossipsub_msg_received_invalid_total",help:"Tracks specific reason of invalid",labelNames:["error"]}),msgReceivedInvalidByTopic:e.gauge({name:"gossipsub_msg_received_invalid_by_topic_total",help:"Tracks specific invalid message by topic",labelNames:["topic"]}),duplicateMsgDeliveryDelay:e.histogram({name:"gossisub_duplicate_msg_delivery_delay_seconds",help:"Time since the 1st duplicated message validated",labelNames:["topic"],buckets:[.25*r.maxMeshMessageDeliveriesWindowSec,.5*r.maxMeshMessageDeliveriesWindowSec,Number(r.maxMeshMessageDeliveriesWindowSec),2*r.maxMeshMessageDeliveriesWindowSec,4*r.maxMeshMessageDeliveriesWindowSec]}),duplicateMsgLateDelivery:e.gauge({name:"gossisub_duplicate_msg_late_delivery_total",help:"Total count of late duplicate message delivery by topic, which triggers P3 penalty",labelNames:["topic"]}),duplicateMsgIgnored:e.gauge({name:"gossisub_ignored_published_duplicate_msgs_total",help:"Total count of published duplicate message ignored by topic",labelNames:["topic"]}),scoreFnCalls:e.gauge({name:"gossipsub_score_fn_calls_total",help:"Total times score() is called"}),scoreFnRuns:e.gauge({name:"gossipsub_score_fn_runs_total",help:"Total times score() call actually computed computeScore(), no cache"}),scoreCachedDelta:e.histogram({name:"gossipsub_score_cache_delta",help:"Delta of score between cached values that expired",buckets:[10,100,1e3]}),peersByScoreThreshold:e.gauge({name:"gossipsub_peers_by_score_threshold_count",help:"Current count of peers by score threshold",labelNames:["threshold"]}),score:e.avgMinMax({name:"gossipsub_score",help:"Avg min max of gossip scores"}),scoreWeights:e.avgMinMax({name:"gossipsub_score_weights",help:"Separate score weights",labelNames:["topic","p"]}),scorePerMesh:e.avgMinMax({name:"gossipsub_score_per_mesh",help:"Histogram of the scores for each mesh topic",labelNames:["topic"]}),scoringPenalties:e.gauge({name:"gossipsub_scoring_penalties_total",help:"A counter of the kind of penalties being applied to peers",labelNames:["penalty"]}),behaviourPenalty:e.histogram({name:"gossipsub_peer_stat_behaviour_penalty",help:"Current peer stat behaviour_penalty at each scrape",buckets:[.25*r.behaviourPenaltyThreshold,.5*r.behaviourPenaltyThreshold,Number(r.behaviourPenaltyThreshold),2*r.behaviourPenaltyThreshold,4*r.behaviourPenaltyThreshold]}),ihaveRcvIgnored:e.gauge({name:"gossipsub_ihave_rcv_ignored_total",help:"Total received IHAVE messages that we ignore for some reason",labelNames:["reason"]}),ihaveRcvMsgids:e.gauge({name:"gossipsub_ihave_rcv_msgids_total",help:"Total received IHAVE messages by topic",labelNames:["topic"]}),ihaveRcvNotSeenMsgids:e.gauge({name:"gossipsub_ihave_rcv_not_seen_msgids_total",help:"Total messages per topic we do not have, not actual requests",labelNames:["topic"]}),iwantRcvMsgids:e.gauge({name:"gossipsub_iwant_rcv_msgids_total",help:"Total received IWANT messages by topic",labelNames:["topic"]}),iwantRcvDonthaveMsgids:e.gauge({name:"gossipsub_iwant_rcv_dont_have_msgids_total",help:"Total requested messageIDs that we do not have"}),idontwantRcvMsgids:e.gauge({name:"gossipsub_idontwant_rcv_msgids_total",help:"Total received IDONTWANT messages"}),idontwantRcvDonthaveMsgids:e.gauge({name:"gossipsub_idontwant_rcv_dont_have_msgids_total",help:"Total received IDONTWANT messageIDs that we do not have in mcache"}),iwantPromiseStarted:e.gauge({name:"gossipsub_iwant_promise_sent_total",help:"Total count of started IWANT promises"}),iwantPromiseResolved:e.gauge({name:"gossipsub_iwant_promise_resolved_total",help:"Total count of resolved IWANT promises"}),iwantPromiseResolvedFromDuplicate:e.gauge({name:"gossipsub_iwant_promise_resolved_from_duplicate_total",help:"Total count of resolved IWANT promises from duplicate messages"}),iwantPromiseResolvedPeers:e.gauge({name:"gossipsub_iwant_promise_resolved_peers",help:"Total count of peers we have asked IWANT promises that are resolved"}),iwantPromiseBroken:e.gauge({name:"gossipsub_iwant_promise_broken",help:"Total count of broken IWANT promises"}),iwantMessagePruned:e.gauge({name:"gossipsub_iwant_message_pruned",help:"Total count of pruned IWANT messages"}),iwantPromiseDeliveryTime:e.histogram({name:"gossipsub_iwant_promise_delivery_seconds",help:"Histogram of delivery time of resolved IWANT promises",buckets:[.5*r.gossipPromiseExpireSec,Number(r.gossipPromiseExpireSec),2*r.gossipPromiseExpireSec,4*r.gossipPromiseExpireSec]}),iwantPromiseUntracked:e.gauge({name:"gossip_iwant_promise_untracked",help:"Total count of untracked IWANT promise"}),connectedPeersBackoffSec:e.histogram({name:"gossipsub_connected_peers_backoff_seconds",help:"Backoff time in seconds",buckets:[1,2,4,10,20,60,120]}),cacheSize:e.gauge({name:"gossipsub_cache_size",help:"Unbounded cache sizes",labelNames:["cache"]}),mcacheSize:e.gauge({name:"gossipsub_mcache_size",help:"Current mcache msg count"}),mcacheNotValidatedCount:e.gauge({name:"gossipsub_mcache_not_validated_count",help:"Current mcache msg count not validated"}),fastMsgIdCacheCollision:e.gauge({name:"gossipsub_fastmsgid_cache_collision_total",help:"Total count of key collisions on fastmsgid cache put"}),newConnectionCount:e.gauge({name:"gossipsub_new_connection_total",help:"Total new connection by status",labelNames:["status"]}),topicStrToLabel:t,toTopic(e){return this.topicStrToLabel.get(e)??e},onJoin(e){this.topicSubscriptionStatus.set({topicStr:e},1),this.meshPeerCounts.set({topicStr:e},0)},onLeave(e){this.topicSubscriptionStatus.set({topicStr:e},0),this.meshPeerCounts.set({topicStr:e},0)},onAddToMesh(e,t,r){const n=this.toTopic(e);switch(t){case zc.Fanout:this.meshPeerInclusionEventsFanout.inc({topic:n},r);break;case zc.Random:this.meshPeerInclusionEventsRandom.inc({topic:n},r);break;case zc.Subscribed:this.meshPeerInclusionEventsSubscribed.inc({topic:n},r);break;case zc.Outbound:this.meshPeerInclusionEventsOutbound.inc({topic:n},r);break;case zc.NotEnough:this.meshPeerInclusionEventsNotEnough.inc({topic:n},r);break;case zc.Opportunistic:this.meshPeerInclusionEventsOpportunistic.inc({topic:n},r);break;default:this.meshPeerInclusionEventsUnknown.inc({topic:n},r)}},onRemoveFromMesh(e,t,r){const n=this.toTopic(e);switch(t){case qc.Dc:this.meshPeerChurnEventsDisconnected.inc({topic:n},r);break;case qc.BadScore:this.meshPeerChurnEventsBadScore.inc({topic:n},r);break;case qc.Prune:this.meshPeerChurnEventsPrune.inc({topic:n},r);break;case qc.Excess:this.meshPeerChurnEventsExcess.inc({topic:n},r);break;default:this.meshPeerChurnEventsUnknown.inc({topic:n},r)}},onReportValidation(e,t,r){if(this.asyncValidationMcacheHit.inc({hit:null!=e?"hit":"miss"}),null!=e){const r=this.toTopic(e.message.topic);switch(t){case E.Accept:this.acceptedMessagesTotal.inc({topic:r});break;case E.Ignore:this.ignoredMessagesTotal.inc({topic:r});break;case E.Reject:this.rejectedMessagesTotal.inc({topic:r});break;default:this.unknownValidationResultsTotal.inc({topic:r})}}null!=r?this.asyncValidationDelayFromFirstSeenSec.observe((Date.now()-r)/1e3):this.asyncValidationUnknownFirstSeen.inc()},onScorePenalty(e){this.scoringPenalties.inc({penalty:e},1)},onIhaveRcv(e,t,r){const n=this.toTopic(e);this.ihaveRcvMsgids.inc({topic:n},t),this.ihaveRcvNotSeenMsgids.inc({topic:n},r)},onIwantRcv(e,t){for(const[t,r]of e){const e=this.toTopic(t);this.iwantRcvMsgids.inc({topic:e},r)}this.iwantRcvDonthaveMsgids.inc(t)},onIdontwantRcv(e,t){this.idontwantRcvMsgids.inc(e),this.idontwantRcvDonthaveMsgids.inc(t)},onForwardMsg(e,t){const r=this.toTopic(e);this.msgForwardCount.inc({topic:r},1),this.msgForwardPeers.inc({topic:r},t)},onPublishMsg(e,t,r,n,s){const i=this.toTopic(e);this.msgPublishCount.inc({topic:i},1),this.msgPublishBytes.inc({topic:i},r*n),this.msgPublishPeersByTopic.inc({topic:i},r),this.directPeersPublishedTotal.inc({topic:i},t.direct),this.floodsubPeersPublishedTotal.inc({topic:i},t.floodsub),this.meshPeersPublishedTotal.inc({topic:i},t.mesh),this.fanoutPeersPublishedTotal.inc({topic:i},t.fanout),this.msgPublishTime.observe({topic:i},s/1e3)},onMsgRecvPreValidation(e){const t=this.toTopic(e);this.msgReceivedPreValidation.inc({topic:t},1)},onMsgRecvError(e){const t=this.toTopic(e);this.msgReceivedError.inc({topic:t},1)},onPrevalidationResult(e,t){const r=this.toTopic(e);switch(t){case $c.duplicate:this.prevalidationDuplicateTotal.inc({topic:r});break;case $c.invalid:this.prevalidationInvalidTotal.inc({topic:r});break;case $c.valid:this.prevalidationValidTotal.inc({topic:r});break;default:this.prevalidationUnknownTotal.inc({topic:r})}},onMsgRecvInvalid(e,t){const r=this.toTopic(e),n=t.reason===Fc.Error?t.error:t.reason;this.msgReceivedInvalid.inc({error:n},1),this.msgReceivedInvalidByTopic.inc({topic:r},1)},onDuplicateMsgDelivery(e,t,r){const n=this.toTopic(e);this.duplicateMsgDeliveryDelay.observe({topic:n},t/1e3),r&&this.duplicateMsgLateDelivery.inc({topic:n},1)},onPublishDuplicateMsg(e){const t=this.toTopic(e);this.duplicateMsgIgnored.inc({topic:t},1)},onPeerReadStreamError(){this.peerReadStreamError.inc(1)},onRpcRecvError(){this.rpcRecvError.inc(1)},onRpcDataError(){this.rpcDataError.inc(1)},onRpcRecv(e,t){this.rpcRecvBytes.inc(t),this.rpcRecvCount.inc(1),null!=e.subscriptions&&this.rpcRecvSubscription.inc(e.subscriptions.length),null!=e.messages&&this.rpcRecvMessage.inc(e.messages.length),null!=e.control&&(this.rpcRecvControl.inc(1),null!=e.control.ihave&&this.rpcRecvIHave.inc(e.control.ihave.length),null!=e.control.iwant&&this.rpcRecvIWant.inc(e.control.iwant.length),null!=e.control.graft&&this.rpcRecvGraft.inc(e.control.graft.length),null!=e.control.prune&&this.rpcRecvPrune.inc(e.control.prune.length))},onRpcSent(e,t){if(this.rpcSentBytes.inc(t),this.rpcSentCount.inc(1),null!=e.subscriptions&&this.rpcSentSubscription.inc(e.subscriptions.length),null!=e.messages&&this.rpcSentMessage.inc(e.messages.length),null!=e.control){const t=e.control.ihave?.length??0,r=e.control.iwant?.length??0,n=e.control.graft?.length??0,s=e.control.prune?.length??0,i=e.control.idontwant?.length??0;t>0&&this.rpcSentIHave.inc(t),r>0&&this.rpcSentIWant.inc(r),n>0&&this.rpcSentGraft.inc(n),s>0&&this.rpcSentPrune.inc(s),i>0&&this.rpcSentIDontWant.inc(i),(t>0||r>0||n>0||s>0||i>0)&&this.rpcSentControl.inc(1)}},registerScores(e,t){let r=0,n=0,s=0,i=0;for(const o of e)o>=t.graylistThreshold&&r++,o>=t.publishThreshold&&n++,o>=t.gossipThreshold&&s++,o>=0&&i++;this.peersByScoreThreshold.set({threshold:Kc.graylist},r),this.peersByScoreThreshold.set({threshold:Kc.publish},n),this.peersByScoreThreshold.set({threshold:Kc.gossip},s),this.peersByScoreThreshold.set({threshold:Kc.mesh},i),this.score.set(e)},registerScoreWeights(e){for(const[t,r]of e.byTopic)this.scoreWeights.set({topic:t,p:"p1"},r.p1w),this.scoreWeights.set({topic:t,p:"p2"},r.p2w),this.scoreWeights.set({topic:t,p:"p3"},r.p3w),this.scoreWeights.set({topic:t,p:"p3b"},r.p3bw),this.scoreWeights.set({topic:t,p:"p4"},r.p4w);this.scoreWeights.set({p:"p5"},e.p5w),this.scoreWeights.set({p:"p6"},e.p6w),this.scoreWeights.set({p:"p7"},e.p7w)},registerScorePerMesh(e,t){const r=new Map;e.forEach(((e,t)=>{const n=this.topicStrToLabel.get(t)??"unknown";let s=r.get(n);null==s&&(s=new Set,r.set(n,s)),e.forEach((e=>s?.add(e)))}));for(const[e,n]of r){const r=[];n.forEach((e=>{r.push(t.get(e)??0)})),this.scorePerMesh.set({topic:e},r)}}}}(t.metricsRegister,t.metricsTopicStrToLabel,{gossipPromiseExpireSec:this.opts.gossipsubIWantFollowupMs/1e3,behaviourPenaltyThreshold:r.scoreParams.behaviourPenaltyThreshold,maxMeshMessageDeliveriesWindowSec:e/1e3});n.mcacheSize.addCollect((()=>{this.onScrapeMetrics(n)}));for(const e of this.multicodecs)n.protocolsEnabled.set({protocol:e},1);this.metrics=n}else this.metrics=null;this.gossipTracer=new pl(this.opts.gossipsubIWantFollowupMs,this.msgIdToStrFn,this.metrics),this.score=new ll(this.opts.scoreParams,this.metrics,this.components.logger,{scoreCacheValidityMs:r.heartbeatInterval}),this.maxInboundStreams=t.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams,this.runOnLimitedConnection=t.runOnLimitedConnection,this.allowedTopics=null!=r.allowedTopics?new Set(r.allowedTopics):null}[Symbol.toStringTag]="@chainsafe/libp2p-gossipsub";[I]=["@libp2p/pubsub"];[_]=["@libp2p/identify"];getPeers(){return[...this.peers.keys()].map((e=>ec(e)))}isStarted(){return this.status.code===Zl.started}async start(){if(this.isStarted())return;this.log("starting"),this.publishConfig=function(e,t,r){switch(e){case v:return{type:Uc.Signing,author:t,key:ja(r.publicKey),privateKey:r};case S:return{type:Uc.Anonymous};default:throw new Error(`Unknown signature policy "${e}"`)}}(this.globalSignaturePolicy,this.components.peerId,this.components.privateKey),this.outboundInflightQueue=kc({objectMode:!0}),Ic(this.outboundInflightQueue,(async e=>{for await(const{peerId:t,connection:r}of e)await this.createOutboundStream(t,r)})).catch((e=>{this.log.error("outbound inflight queue error",e)})),await Promise.all(this.opts.directPeers.map((async e=>{await this.components.peerStore.merge(e.id,{multiaddrs:e.addrs})})));const e=this.components.registrar;await Promise.all(this.multicodecs.map((async t=>e.handle(t,this.onIncomingStream.bind(this),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}))));const t={onConnect:this.onPeerConnected.bind(this),onDisconnect:this.onPeerDisconnected.bind(this),notifyOnLimitedConnection:this.runOnLimitedConnection},r=await Promise.all(this.multicodecs.map((async r=>e.register(r,t)))),n=setTimeout(this.runHeartbeat,100);this.status={code:Zl.started,registrarTopologyIds:r,heartbeatTimeout:n,hearbeatStartMs:Date.now()+100},this.score.start(),this.directPeerInitial=setTimeout((()=>{Promise.resolve().then((async()=>{await Promise.all(Array.from(this.direct).map((async e=>this.connect(e))))})).catch((e=>{this.log(e)}))}),1e3),this.opts.tagMeshPeers&&(this.addEventListener("gossipsub:graft",this.tagMeshPeer),this.addEventListener("gossipsub:prune",this.untagMeshPeer)),this.log("started")}async stop(){if(this.log("stopping"),this.status.code!==Zl.started)return;const{registrarTopologyIds:e}=this.status;this.status={code:Zl.stopped},this.opts.tagMeshPeers&&(this.removeEventListener("gossipsub:graft",this.tagMeshPeer),this.removeEventListener("gossipsub:prune",this.untagMeshPeer));const t=this.components.registrar;await Promise.all(this.multicodecs.map((async e=>t.unhandle(e)))),e.forEach((e=>{t.unregister(e)})),this.outboundInflightQueue.end();const r=[];for(const e of this.streamsOutbound.values())r.push(e.close());this.streamsOutbound.clear();for(const e of this.streamsInbound.values())r.push(e.close());this.streamsInbound.clear(),await Promise.all(r),this.peers.clear(),this.subscriptions.clear(),null!=this.heartbeatTimer&&(this.heartbeatTimer.cancel(),this.heartbeatTimer=null),this.score.stop(),this.mesh.clear(),this.fanout.clear(),this.fanoutLastpub.clear(),this.gossip.clear(),this.control.clear(),this.peerhave.clear(),this.iasked.clear(),this.backoff.clear(),this.outbound.clear(),this.gossipTracer.clear(),this.seenCache.clear(),null!=this.fastMsgIdCache&&this.fastMsgIdCache.clear(),null!=this.directPeerInitial&&clearTimeout(this.directPeerInitial),this.idontwantCounts.clear(),this.idontwants.clear(),this.log("stopped")}dumpPeerScoreStats(){return this.score.dumpPeerScoreStats()}onIncomingStream({stream:e,connection:t}){if(!this.isStarted())return;const r=t.remotePeer;this.addPeer(r,t.direction,t.remoteAddr),this.createInboundStream(r,e),this.outboundInflightQueue.push({peerId:r,connection:t})}onPeerConnected(e,t){this.metrics?.newConnectionCount.inc({status:t.status}),this.isStarted()&&"open"===t.status&&(this.addPeer(e,t.direction,t.remoteAddr),this.outboundInflightQueue.push({peerId:e,connection:t}))}onPeerDisconnected(e){this.log("connection ended %p",e),this.removePeer(e)}async createOutboundStream(e,t){if(!this.isStarted())return;const r=e.toString();if(this.peers.has(r)&&!this.streamsOutbound.has(r))try{const n=new hl(await t.newStream(this.multicodecs,{runOnLimitedConnection:this.runOnLimitedConnection}),(e=>{this.log.error("outbound pipe error",e)}),{maxBufferSize:this.opts.maxOutboundBufferSize});this.log("create outbound stream %p",e),this.streamsOutbound.set(r,n);const s=n.protocol;s===Pc&&this.floodsubPeers.add(r),this.metrics?.peersPerProtocol.inc({protocol:s},1),this.subscriptions.size>0&&(this.log("send subscriptions to",r),this.sendSubscriptions(r,Array.from(this.subscriptions),!0))}catch(e){this.log.error("createOutboundStream error",e)}}createInboundStream(e,t){if(!this.isStarted())return;const r=e.toString();if(!this.peers.has(r))return;const n=this.streamsInbound.get(r);void 0!==n&&(this.log("replacing existing inbound steam %s",r),n.close().catch((e=>{this.log.error(e)}))),this.log("create inbound stream %s",r);const s=new dl(t,{maxDataLength:this.opts.maxInboundDataLength});this.streamsInbound.set(r,s),this.pipePeerReadStream(e,s.source).catch((e=>{this.log(e)}))}addPeer(e,t,r){const n=e.toString();if(!this.peers.has(n)){this.log("new peer %p",e),this.peers.add(n),this.score.addPeer(n);const s=function(e){for(const t of e.tuples())switch(t[0]){case Ql.ip4:case Ql.ip6:return zl(t[0],t[1])}return null}(r);null!==s?this.score.addIP(n,s):this.log("Added peer has no IP in current address %s %s",n,r.toString()),this.outbound.has(n)||this.outbound.set(n,"outbound"===t)}}removePeer(e){const t=e.toString();if(!this.peers.has(t))return;this.log("delete peer %p",e),this.peers.delete(t);const r=this.streamsOutbound.get(t),n=this.streamsInbound.get(t);null!=r&&this.metrics?.peersPerProtocol.inc({protocol:r.protocol},-1),r?.close().catch((e=>{this.log.error(e)})),n?.close().catch((e=>{this.log.error(e)})),this.streamsOutbound.delete(t),this.streamsInbound.delete(t);for(const e of this.topics.values())e.delete(t);for(const[e,r]of this.mesh)r.delete(t)&&this.metrics?.onRemoveFromMesh(e,qc.Dc,1);for(const e of this.fanout.values())e.delete(t);this.floodsubPeers.delete(t),this.gossip.delete(t),this.control.delete(t),this.outbound.delete(t),this.idontwantCounts.delete(t),this.idontwants.delete(t),this.score.removePeer(t),this.acceptFromWhitelist.delete(t)}get started(){return this.status.code===Zl.started}getMeshPeers(e){const t=this.mesh.get(e);return null!=t?Array.from(t):[]}getSubscribers(e){const t=this.topics.get(e);return(null!=t?Array.from(t):[]).map((e=>ec(e)))}getTopics(){return Array.from(this.subscriptions)}async pipePeerReadStream(e,t){try{await Ic(t,(async t=>{for await(const r of t)try{const t=r.subarray(),n=Lc.decode(t,{limits:{subscriptions:this.decodeRpcLimits.maxSubscriptions,messages:this.decodeRpcLimits.maxMessages,control$:{ihave:this.decodeRpcLimits.maxIhaveMessageIDs,iwant:this.decodeRpcLimits.maxIwantMessageIDs,graft:this.decodeRpcLimits.maxControlMessages,prune:this.decodeRpcLimits.maxControlMessages,prune$:{peers:this.decodeRpcLimits.maxPeerInfos},idontwant:this.decodeRpcLimits.maxControlMessages,idontwant$:{messageIDs:this.decodeRpcLimits.maxIdontwantMessageIDs}}}});if(this.metrics?.onRpcRecv(n,t.length),this.opts.awaitRpcHandler)try{await this.handleReceivedRpc(e,n)}catch(e){this.metrics?.onRpcRecvError(),this.log(e)}else this.handleReceivedRpc(e,n).catch((e=>{this.metrics?.onRpcRecvError(),this.log(e)}))}catch(e){this.metrics?.onRpcDataError(),this.log(e)}}))}catch(t){this.metrics?.onPeerReadStreamError(),this.handlePeerReadStreamError(t,e)}}handlePeerReadStreamError(e,t){this.log.error(e),this.onPeerDisconnected(t)}async handleReceivedRpc(e,t){if(!this.acceptFrom(e.toString()))return this.log("received message from unacceptable peer %p",e),void this.metrics?.rpcRecvNotAccepted.inc();const r=null!=t.subscriptions?t.subscriptions.length:0,n=null!=t.messages?t.messages.length:0;let s=0,i=0,o=0,a=0;if(null!=t.control&&(null!=t.control.ihave&&(s=t.control.ihave.length),null!=t.control.iwant&&(i=t.control.iwant.length),null!=t.control.graft&&(o=t.control.graft.length),null!=t.control.prune&&(a=t.control.prune.length)),this.log(`rpc.from ${e.toString()} subscriptions ${r} messages ${n} ihave ${s} iwant ${i} graft ${o} prune ${a}`),null!=t.subscriptions&&t.subscriptions.length>0){const r=[];t.subscriptions.forEach((t=>{const n=t.topic,s=!0===t.subscribe;if(null!=n){if(null!=this.allowedTopics&&!this.allowedTopics.has(n))return;this.handleReceivedSubscription(e,n,s),r.push({topic:n,subscribe:s})}})),this.safeDispatchEvent("subscription-change",{detail:{peerId:e,subscriptions:r}})}for(const r of t.messages){if(null!=this.allowedTopics&&!this.allowedTopics.has(r.topic))continue;const t=this.handleReceivedMessage(e,r).catch((e=>{this.metrics?.onMsgRecvError(r.topic),this.log(e)}));this.opts.awaitRpcMessageHandler&&await t}null!=t.control&&await this.handleControlMessage(e.toString(),t.control)}handleReceivedSubscription(e,t,r){this.log("subscription update from %p topic %s",e,t);let n=this.topics.get(t);null==n&&(n=new Set,this.topics.set(t,n)),r?n.add(e.toString()):n.delete(e.toString())}async handleReceivedMessage(e,t){this.metrics?.onMsgRecvPreValidation(t.topic);const r=await this.validateReceivedMessage(e,t);this.metrics?.onPrevalidationResult(t.topic,r.code);const n=r.code;switch(n){case $c.duplicate:return this.score.duplicateMessage(e.toString(),r.msgIdStr,t.topic),this.gossipTracer.deliverMessage(r.msgIdStr,!0),void this.mcache.observeDuplicate(r.msgIdStr,e.toString());case $c.invalid:if(null!=r.msgIdStr){const n=r.msgIdStr;this.score.rejectMessage(e.toString(),n,t.topic,r.reason),this.gossipTracer.rejectMessage(n,r.reason)}else this.score.rejectInvalidMessage(e.toString(),t.topic);return void this.metrics?.onMsgRecvInvalid(t.topic,r);case $c.valid:this.score.validateMessage(r.messageId.msgIdStr),this.gossipTracer.deliverMessage(r.messageId.msgIdStr),this.mcache.put(r.messageId,t,!this.opts.asyncValidation),this.subscriptions.has(t.topic)&&(this.components.peerId.equals(e)&&!this.opts.emitSelf||(super.dispatchEvent(new CustomEvent("gossipsub:message",{detail:{propagationSource:e,msgId:r.messageId.msgIdStr,msg:r.msg}})),super.dispatchEvent(new CustomEvent("message",{detail:r.msg})))),this.opts.asyncValidation||this.forwardMessage(r.messageId.msgIdStr,t,e.toString());break;default:throw new Error(`Invalid validation result: ${n}`)}}async validateReceivedMessage(e,t){const r=this.fastMsgIdFn?.(t),n=void 0!==r?this.fastMsgIdCache?.get(r):void 0;if(null!=n)return{code:$c.duplicate,msgIdStr:n};const s=await async function(e,t){switch(e){case S:return null!=t.signature?{valid:!1,error:Vc.SignaturePresent}:null!=t.seqno?{valid:!1,error:Vc.SeqnoPresent}:null!=t.key?{valid:!1,error:Vc.FromPresent}:{valid:!0,message:{type:"unsigned",topic:t.topic,data:t.data??new Uint8Array(0)}};case v:{if(null==t.seqno)return{valid:!1,error:Vc.InvalidSeqno};if(8!==t.seqno.length)return{valid:!1,error:Vc.InvalidSeqno};if(null==t.signature)return{valid:!1,error:Vc.InvalidSignature};if(null==t.from)return{valid:!1,error:Vc.InvalidPeerId};let e,r;try{e=rc(He(t.from))}catch(e){return{valid:!1,error:Vc.InvalidPeerId}}if(null!=t.key){if(r=qa(t.key),void 0!==e.publicKey&&!r.equals(e.publicKey))return{valid:!1,error:Vc.InvalidPeerId}}else{if(null==e.publicKey)return{valid:!1,error:Vc.InvalidPeerId};r=e.publicKey}const n={from:t.from,data:t.data,seqno:t.seqno,topic:t.topic,signature:void 0,key:void 0},s=sc([gl,Lc.Message.encode(n)]);return await r.verify(s,t.signature)?{valid:!0,message:{type:"signed",from:e,data:t.data??new Uint8Array(0),sequenceNumber:BigInt(`0x${ia(t.seqno,"base16")}`),topic:t.topic,signature:t.signature,key:null!=t.key?qa(t.key):r}}:{valid:!1,error:Vc.InvalidSignature}}default:throw new Error("Unreachable")}}(this.globalSignaturePolicy,t);if(!s.valid)return{code:$c.invalid,reason:Fc.Error,error:s.error};const i=s.message;try{null!=this.dataTransform&&(i.data=this.dataTransform.inboundTransform(t.topic,i.data))}catch(e){return this.log("Invalid message, transform failed",e),{code:$c.invalid,reason:Fc.Error,error:Vc.TransformFailed}}const o=await this.msgIdFn(i),a=this.msgIdToStrFn(o),c={msgId:o,msgIdStr:a};if(void 0!==r&&null!=this.fastMsgIdCache&&this.fastMsgIdCache.put(r,a)&&this.metrics?.fastMsgIdCacheCollision.inc(),this.seenCache.has(a))return{code:$c.duplicate,msgIdStr:a};this.seenCache.put(a),(t.data?.length??0)>=this.opts.idontwantMinDataSize&&this.sendIDontWants(o,t.topic,e.toString());const l=this.topicValidators.get(t.topic);if(null!=l){let t;try{t=await l(e,i)}catch(e){const r=e.code;"ERR_TOPIC_VALIDATOR_IGNORE"===r&&(t=E.Ignore),t="ERR_TOPIC_VALIDATOR_REJECT"===r?E.Reject:E.Ignore}if(t!==E.Accept)return{code:$c.invalid,reason:Yc(t),msgIdStr:a}}return{code:$c.valid,messageId:c,msg:i}}getScore(e){return this.score.score(e)}sendSubscriptions(e,t,r){this.sendRpc(e,{subscriptions:t.map((e=>({topic:e,subscribe:r}))),messages:[]})}async handleControlMessage(e,t){if(void 0===t)return;const r=t.ihave?.length>0?this.handleIHave(e,t.ihave):[],n=t.iwant?.length>0?this.handleIWant(e,t.iwant):[],s=t.graft?.length>0?await this.handleGraft(e,t.graft):[];if(t.prune?.length>0&&await this.handlePrune(e,t.prune),t.idontwant?.length>0&&this.handleIdontwant(e,t.idontwant),0===r.length&&0===n.length&&0===s.length)return;const i=this.sendRpc(e,ml(n,{iwant:r,prune:s})),o=r[0]?.messageIDs;null!=o&&(i?this.gossipTracer.addPromise(e,o):this.metrics?.iwantPromiseUntracked.inc(1))}acceptFrom(e){if(this.direct.has(e))return!0;const t=Date.now(),r=this.acceptFromWhitelist.get(e);if(null!=r&&r.messagesAccepted<128&&r.acceptUntil>=t)return r.messagesAccepted+=1,!0;const n=this.score.score(e);return n>=0?this.acceptFromWhitelist.set(e,{messagesAccepted:0,acceptUntil:t+1e3}):this.acceptFromWhitelist.delete(e),n>=this.opts.scoreThresholds.graylistThreshold}handleIHave(e,t){if(0===t.length)return[];const r=this.score.score(e);if(r<this.opts.scoreThresholds.gossipThreshold)return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]",e,r),this.metrics?.ihaveRcvIgnored.inc({reason:Wc.LowScore}),[];const n=(this.peerhave.get(e)??0)+1;if(this.peerhave.set(e,n),n>10)return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring",e,n),this.metrics?.ihaveRcvIgnored.inc({reason:Wc.MaxIhave}),[];const s=this.iasked.get(e)??0;if(s>=Rc)return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring",e,s),this.metrics?.ihaveRcvIgnored.inc({reason:Wc.MaxIasked}),[];const i=new Map;if(t.forEach((({topicID:e,messageIDs:t})=>{if(null==e||null==t||!this.mesh.has(e))return;let r=0;t.forEach((e=>{const t=this.msgIdToStrFn(e);this.seenCache.has(t)||(i.set(t,e),r++)})),this.metrics?.onIhaveRcv(e,t.length,r)})),0===i.size)return[];let o=i.size;o+s>Rc&&(o=Rc-s),this.log("IHAVE: Asking for %d out of %d messages from %s",o,i.size,e);let a=Array.from(i.values());return bl(a),a=a.slice(0,o),this.iasked.set(e,s+o),[{messageIDs:a}]}handleIWant(e,t){if(0===t.length)return[];const r=this.score.score(e);if(r<this.opts.scoreThresholds.gossipThreshold)return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]",e,r),[];const n=new Map,s=new Map;let i=0;return t.forEach((({messageIDs:t})=>{t?.forEach((t=>{const r=this.msgIdToStrFn(t),o=this.mcache.getWithIWantCount(r,e);null!=o?(s.set(o.msg.topic,1+(s.get(o.msg.topic)??0)),o.count>3?this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request",e,t):n.set(r,o.msg)):i++}))})),this.metrics?.onIwantRcv(s,i),0===n.size?(this.log("IWANT: Could not provide any wanted messages to %s",e),[]):(this.log("IWANT: Sending %d messages to %s",n.size,e),Array.from(n.values()))}async handleGraft(e,t){const r=[],n=this.score.score(e),s=Date.now();let i=this.opts.doPX;return t.forEach((({topicID:t})=>{if(null==t)return;const o=this.mesh.get(t);if(null==o)return void(i=!1);if(o.has(e))return;const a=this.backoff.get(t)?.get(e);if(this.direct.has(e))this.log("GRAFT: ignoring request from direct peer %s",e),r.push(t),i=!1;else if("number"==typeof a&&s<a){this.log("GRAFT: ignoring backed off peer %s",e),this.score.addPenalty(e,1,jc.GraftBackoff),i=!1;const n=a+this.opts.graftFloodThreshold-this.opts.pruneBackoff;s<n&&this.score.addPenalty(e,1,jc.GraftBackoff),this.addBackoff(e,t),r.push(t)}else n<0?(this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s",e,n,t),r.push(t),i=!1,this.addBackoff(e,t)):o.size>=this.opts.Dhi&&!this.outbound.get(e)?(r.push(t),this.addBackoff(e,t)):(this.log("GRAFT: Add mesh link from %s in %s",e,t),this.score.graft(e,t),o.add(e),this.metrics?.onAddToMesh(t,zc.Subscribed,1));this.safeDispatchEvent("gossipsub:graft",{detail:{peerId:e,topic:t,direction:"inbound"}})})),0===r.length?[]:Promise.all(r.map((async t=>this.makePrune(e,t,i,!1))))}async handlePrune(e,t){const r=this.score.score(e);for(const{topicID:n,backoff:s,peers:i}of t){if(null==n)continue;const t=this.mesh.get(n);if(null==t)return;this.log("PRUNE: Remove mesh link to %s in %s",e,n),this.score.prune(e,n),t.has(e)&&(t.delete(e),this.metrics?.onRemoveFromMesh(n,qc.Prune,1)),"number"==typeof s&&s>0?this.doAddBackoff(e,n,1e3*s):this.addBackoff(e,n),null!=i&&i.length>0&&(r<this.opts.scoreThresholds.acceptPXThreshold?this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]",e,r,n):await this.pxConnect(i)),this.safeDispatchEvent("gossipsub:prune",{detail:{peerId:e,topic:n,direction:"inbound"}})}}handleIdontwant(e,t){let r=this.idontwantCounts.get(e)??0;if(r>=this.opts.idontwantMaxMessages)return;const n=r;let s=this.idontwants.get(e);null==s&&(s=new Map,this.idontwants.set(e,s));let i=0;e:for(const{messageIDs:e}of t)for(const t of e){if(r>=this.opts.idontwantMaxMessages)break e;r++;const e=this.msgIdToStrFn(t);s.set(e,this.heartbeatTicks),this.mcache.msgs.has(e)||i++}this.idontwantCounts.set(e,r);const o=r-n;this.metrics?.onIdontwantRcv(o,i)}addBackoff(e,t){this.doAddBackoff(e,t,this.opts.pruneBackoff)}doAddBackoff(e,t,r){let n=this.backoff.get(t);null==n&&(n=new Map,this.backoff.set(t,n));const s=Date.now()+r;(n.get(e)??0)<s&&n.set(e,s)}applyIwantPenalties(){this.gossipTracer.getBrokenPromises().forEach(((e,t)=>{this.log("peer %s didn't follow up in %d IWANT requests; adding penalty",t,e),this.score.addPenalty(t,e,jc.BrokenPromise)}))}clearBackoff(){if(this.heartbeatTicks%15!=0)return;const e=Date.now();this.backoff.forEach(((t,r)=>{t.forEach(((r,n)=>{r+1*this.opts.heartbeatInterval<e&&t.delete(n)})),0===t.size&&this.backoff.delete(r)}))}async directConnect(){const e=[];this.direct.forEach((t=>{this.streamsOutbound.has(t)||e.push(t)})),await Promise.all(e.map((async e=>this.connect(e))))}async pxConnect(e){e.length>this.opts.prunePeers&&(bl(e),e=e.slice(0,this.opts.prunePeers));const t=[];await Promise.all(e.map((async e=>{if(null==e.peerID)return;const r=rc(He(e.peerID)),n=r.toString();if(!this.peers.has(n))if(null!=e.signedPeerRecord)try{if(!await this.components.peerStore.consumePeerRecord(e.signedPeerRecord,r))return void this.log("bogus peer record obtained through px: could not add peer record to address book");t.push(n)}catch(e){this.log("bogus peer record obtained through px: invalid signature or not a peer record")}else t.push(n)}))),0!==t.length&&await Promise.all(t.map((async e=>this.connect(e))))}async connect(e){this.log("Initiating connection with %s",e);const t=ec(e),r=await this.components.connectionManager.openConnection(t);for(const e of this.multicodecs)for(const n of this.components.registrar.getTopologies(e))n.onConnect?.(t,r)}subscribe(e){if(this.status.code!==Zl.started)throw new Error("Pubsub has not started");if(!this.subscriptions.has(e)){this.subscriptions.add(e);for(const t of this.peers.keys())this.sendSubscriptions(t,[e],!0)}this.join(e)}unsubscribe(e){if(this.status.code!==Zl.started)throw new Error("Pubsub is not started");const t=this.subscriptions.delete(e);if(this.log("unsubscribe from %s - am subscribed %s",e,t),t)for(const t of this.peers.keys())this.sendSubscriptions(t,[e],!1);this.leave(e)}join(e){if(this.status.code!==Zl.started)throw new Error("Gossipsub has not started");if(this.mesh.has(e))return;this.log("JOIN %s",e),this.metrics?.onJoin(e);const t=new Set,r=this.backoff.get(e),n=this.fanout.get(e);if(null!=n&&(this.fanout.delete(e),this.fanoutLastpub.delete(e),n.forEach((e=>{!this.direct.has(e)&&this.score.score(e)>=0&&!0!==r?.has(e)&&t.add(e)})),this.metrics?.onAddToMesh(e,zc.Fanout,t.size)),t.size<this.opts.D){const n=t.size;this.getRandomGossipPeers(e,this.opts.D,(e=>!t.has(e)&&!this.direct.has(e)&&this.score.score(e)>=0&&!0!==r?.has(e))).forEach((e=>{t.add(e)})),this.metrics?.onAddToMesh(e,zc.Random,t.size-n)}this.mesh.set(e,t),t.forEach((t=>{this.log("JOIN: Add mesh link to %s in %s",t,e),this.sendGraft(t,e)}))}leave(e){if(this.status.code!==Zl.started)throw new Error("Gossipsub has not started");this.log("LEAVE %s",e),this.metrics?.onLeave(e);const t=this.mesh.get(e);null!=t&&(Promise.all(Array.from(t).map((async t=>{this.log("LEAVE: Remove mesh link to %s in %s",t,e),await this.sendPrune(t,e)}))).catch((e=>{this.log("Error sending prunes to mesh peers",e)})),this.mesh.delete(e))}selectPeersToForward(e,t,r){const n=new Set,s=this.topics.get(e);null!=s&&(this.direct.forEach((e=>{s.has(e)&&t!==e&&!r?.has(e)&&n.add(e)})),this.floodsubPeers.forEach((e=>{s.has(e)&&t!==e&&!r?.has(e)&&this.score.score(e)>=this.opts.scoreThresholds.publishThreshold&&n.add(e)})));const i=this.mesh.get(e);return null!=i&&i.size>0&&i.forEach((e=>{t===e||r?.has(e)||n.add(e)})),n}selectPeersToPublish(e){const t=new Set,r={direct:0,floodsub:0,mesh:0,fanout:0},n=this.topics.get(e);if(null!=n)if(this.opts.floodPublish)n.forEach((e=>{this.direct.has(e)?(t.add(e),r.direct++):this.score.score(e)>=this.opts.scoreThresholds.publishThreshold&&(t.add(e),r.floodsub++)}));else{this.direct.forEach((e=>{n.has(e)&&(t.add(e),r.direct++)})),this.floodsubPeers.forEach((e=>{n.has(e)&&this.score.score(e)>=this.opts.scoreThresholds.publishThreshold&&(t.add(e),r.floodsub++)}));const s=this.mesh.get(e);if(null!=s&&s.size>0)s.forEach((e=>{t.add(e),r.mesh++})),s.size<this.opts.D&&this.getRandomGossipPeers(e,this.opts.D-s.size,(e=>!s.has(e)&&!this.direct.has(e)&&!this.floodsubPeers.has(e)&&this.score.score(e)>=this.opts.scoreThresholds.publishThreshold)).forEach((e=>{t.add(e),r.mesh++}));else{const n=this.fanout.get(e);if(null!=n&&n.size>0)n.forEach((e=>{t.add(e),r.fanout++}));else{const n=this.getRandomGossipPeers(e,this.opts.D,(e=>this.score.score(e)>=this.opts.scoreThresholds.publishThreshold));n.size>0&&(this.fanout.set(e,n),n.forEach((e=>{t.add(e),r.fanout++})))}this.fanoutLastpub.set(e,Date.now())}}return{tosend:t,tosendCount:r}}forwardMessage(e,t,r,n){null!=r&&this.score.deliverMessage(r,e,t.topic);const s=this.selectPeersToForward(t.topic,r,n);s.forEach((e=>{this.sendRpc(e,ml([t]))})),this.metrics?.onForwardMsg(t.topic,s.size)}async publish(e,t,r){const n=Date.now(),s=null!=this.dataTransform?this.dataTransform.outboundTransform(e,t):t;if(null==this.publishConfig)throw Error("PublishError.Uninitialized");const{raw:i,msg:o}=await async function(e,t,r,n){switch(e.type){case Uc.Signing:{const s={from:e.author.toMultihash().bytes,data:n,seqno:fl(8),topic:t,signature:void 0,key:void 0},i=sc([gl,Lc.Message.encode(s)]);return s.signature=await e.privateKey.sign(i),s.key=e.key,{raw:s,msg:{type:"signed",from:e.author,data:r,sequenceNumber:BigInt(`0x${ia(s.seqno??new Uint8Array(0),"base16")}`),topic:t,signature:s.signature,key:qa(s.key)}}}case Uc.Anonymous:return{raw:{from:void 0,data:n,seqno:void 0,topic:t,signature:void 0,key:void 0},msg:{type:"unsigned",data:r,topic:t}};default:throw new Error("Unreachable")}}(this.publishConfig,e,t,s),a=await this.msgIdFn(o),c=this.msgIdToStrFn(a),l=r?.ignoreDuplicatePublishError??this.opts.ignoreDuplicatePublishError;if(this.seenCache.has(c)){if(l)return this.metrics?.onPublishDuplicateMsg(e),{recipients:[]};throw Error("PublishError.Duplicate")}const{tosend:u,tosendCount:h}=this.selectPeersToPublish(e),d=this.opts.emitSelf&&this.subscriptions.has(e),p=r?.allowPublishToZeroTopicPeers??this.opts.allowPublishToZeroTopicPeers;if(0===u.size&&!p&&!d)throw Error("PublishError.NoPeersSubscribedToTopic");this.seenCache.put(c),this.mcache.put({msgId:a,msgIdStr:c},i,!0),this.publishedMessageIds.put(c);const f=r?.batchPublish??this.opts.batchPublish,g=ml([i]);if(f)this.sendRpcInBatch(u,g);else for(const e of u)this.sendRpc(e,g)||u.delete(e);const m=Date.now()-n;return this.metrics?.onPublishMsg(e,h,u.size,null!=i.data?i.data.length:0,m),d&&(u.add(this.components.peerId.toString()),super.dispatchEvent(new CustomEvent("gossipsub:message",{detail:{propagationSource:this.components.peerId,msgId:c,msg:o}})),super.dispatchEvent(new CustomEvent("message",{detail:o}))),{recipients:Array.from(u.values()).map((e=>ec(e)))}}sendRpcInBatch(e,t){const r=Lc.encode(t),n=hc.single(r);for(const s of e){const i=this.streamsOutbound.get(s);if(null!=i){try{i.pushPrefixed(n)}catch(t){e.delete(s),this.log.error(`Cannot send rpc to ${s}`,t)}this.metrics?.onRpcSent(t,r.length)}else this.log(`Cannot send RPC to ${s} as there is no open stream to it available`),e.delete(s)}}reportMessageValidationResult(e,t,r){let n;if(r===E.Accept){if(n=this.mcache.validate(e),null!=n){const{message:r,originatingPeers:s}=n;this.score.deliverMessage(t,e,r.topic),this.forwardMessage(e,n.message,t,s)}}else if(n=this.mcache.remove(e),null!=n){const s=Yc(r),{message:i,originatingPeers:o}=n;this.score.rejectMessage(t,e,i.topic,s);for(const t of o)this.score.rejectMessage(t,e,i.topic,s)}const s=this.score.messageFirstSeenTimestampMs(e);this.metrics?.onReportValidation(n,r,s)}sendGraft(e,t){const r=ml([],{graft:[{topicID:t}]});this.sendRpc(e,r)}async sendPrune(e,t){const r=ml([],{prune:[await this.makePrune(e,t,this.opts.doPX,!0)]});this.sendRpc(e,r)}sendIDontWants(e,t,r){const n=this.mesh.get(t);if(null==n)return;const s=new Set(n);s.delete(r);for(const e of s)this.streamsOutbound.get(e)?.protocol!==Nc&&s.delete(e);const i=ml([],{idontwant:[{messageIDs:[e]}]});this.sendRpcInBatch(s,i)}sendRpc(e,t){const r=this.streamsOutbound.get(e);if(null==r)return this.log(`Cannot send RPC to ${e} as there is no open stream to it available`),!1;const n=this.control.get(e);null!=n&&(this.piggybackControl(e,t,n),this.control.delete(e));const s=this.gossip.get(e);null!=s&&(this.piggybackGossip(e,t,s),this.gossip.delete(e));const i=Lc.encode(t);try{r.push(i)}catch(t){return this.log.error(`Cannot send rpc to ${e}`,t),null!=n&&this.control.set(e,n),null!=s&&this.gossip.set(e,s),!1}if(this.metrics?.onRpcSent(t,i.length),null!=t.control?.graft)for(const r of t.control?.graft)null!=r.topicID&&this.safeDispatchEvent("gossipsub:graft",{detail:{peerId:e,topic:r.topicID,direction:"outbound"}});if(null!=t.control?.prune)for(const r of t.control?.prune)null!=r.topicID&&this.safeDispatchEvent("gossipsub:prune",{detail:{peerId:e,topic:r.topicID,direction:"outbound"}});return!0}piggybackControl(e,t,r){const n=yl(t);for(const t of r.graft)null!=t.topicID&&this.mesh.get(t.topicID)?.has(e)&&n.control.graft.push(t);for(const t of r.prune)null==t.topicID||this.mesh.get(t.topicID)?.has(e)||n.control.prune.push(t)}piggybackGossip(e,t,r){yl(t).control.ihave=r}async sendGraftPrune(e,t,r){const n=this.opts.doPX,s=!1;for(const[i,o]of e){const e=o.map((e=>({topicID:e})));let a=[];const c=t.get(i);null!=c&&(a=await Promise.all(c.map((async e=>this.makePrune(i,e,n&&!r.get(i),s)))),t.delete(i)),this.sendRpc(i,ml([],{graft:e,prune:a}))}for(const[e,i]of t){const t=await Promise.all(i.map((async t=>this.makePrune(e,t,n&&!r.get(e),s))));this.sendRpc(e,ml([],{prune:t}))}}emitGossip(e){const t=this.mcache.getGossipIDs(new Set(e.keys()));for(const[r,n]of e)this.doEmitGossip(r,n,t.get(r)??[])}doEmitGossip(e,t,r){if(0===r.length)return;if(bl(r),r.length>Rc&&this.log("too many messages for gossip; will truncate IHAVE list (%d messages)",r.length),0===t.size)return;let n=this.opts.Dlazy;const s=this.opts.gossipFactor*t.size;let i=t;s>n&&(n=s),n>i.size?n=i.size:i=bl(Array.from(i)).slice(0,n),i.forEach((t=>{let n=r;r.length>Rc&&(n=bl(n.slice()).slice(0,Rc)),this.pushGossip(t,{topicID:e,messageIDs:n})}))}flush(){for(const[e,t]of this.gossip.entries())this.gossip.delete(e),this.sendRpc(e,ml([],{ihave:t}));for(const[e,t]of this.control.entries()){this.control.delete(e);const r=ml([],{graft:t.graft,prune:t.prune});this.sendRpc(e,r)}}pushGossip(e,t){this.log("Add gossip to %s",e);const r=this.gossip.get(e)??[];this.gossip.set(e,r.concat(t))}async makePrune(e,t,r,n){if(this.score.prune(e,t),this.streamsOutbound.get(e)?.protocol===Dc)return{topicID:t,peers:[]};const s=n?this.opts.unsubcribeBackoff:this.opts.pruneBackoff,i=s/1e3;if(this.doAddBackoff(e,t,s),!r)return{topicID:t,peers:[],backoff:i};const o=this.getRandomGossipPeers(t,this.opts.prunePeers,(t=>t!==e&&this.score.score(t)>=0)),a=await Promise.all(Array.from(o).map((async e=>{const t=ec(e);let r;try{r=await this.components.peerStore.get(t)}catch(e){if("NotFoundError"!==e.name)throw e}return{peerID:t.toMultihash().bytes,signedPeerRecord:r?.peerRecordEnvelope}})));return{topicID:t,peers:a,backoff:i}}runHeartbeat=()=>{const e=this.metrics?.heartbeatDuration.startTimer();this.heartbeat().catch((e=>{this.log("Error running heartbeat",e)})).finally((()=>{if(null!=e&&e(),this.status.code===Zl.started){clearTimeout(this.status.heartbeatTimeout);let e=this.opts.heartbeatInterval-(Date.now()-this.status.hearbeatStartMs)%this.opts.heartbeatInterval;e<.25*this.opts.heartbeatInterval&&(e+=this.opts.heartbeatInterval,this.metrics?.heartbeatSkipped.inc()),this.status.heartbeatTimeout=setTimeout(this.runHeartbeat,e)}}))};async heartbeat(){const{D:e,Dlo:t,Dhi:r,Dscore:n,Dout:s,fanoutTTL:i}=this.opts;this.heartbeatTicks++;const o=new Map,a=e=>{let t=o.get(e);return void 0===t&&(t=this.score.score(e),o.set(e,t)),t},c=new Map,l=new Map,u=new Map;this.clearBackoff(),this.peerhave.clear(),this.metrics?.cacheSize.set({cache:"iasked"},this.iasked.size),this.iasked.clear(),this.applyIwantPenalties(),this.idontwantCounts.clear();for(const e of this.idontwants.values())for(const[t,r]of e)this.heartbeatTicks-r>=this.opts.mcacheLength&&e.delete(t);this.heartbeatTicks%this.opts.directConnectTicks==0&&await this.directConnect(),this.fastMsgIdCache?.prune(),this.seenCache.prune(),this.gossipTracer.prune(),this.publishedMessageIds.prune();const h=new Map;this.mesh.forEach(((i,o)=>{const d=this.topics.get(o),p=new Set,f=new Set;if(h.set(o,f),null!=d){const e=bl(Array.from(d)),t=this.backoff.get(o);for(const r of e){const e=this.streamsOutbound.get(r);if(null!=e&&this.multicodecs.includes(e.protocol)&&!i.has(r)&&!this.direct.has(r)){const e=a(r);!0!==t?.has(r)&&e>=0&&p.add(r),e>=this.opts.scoreThresholds.gossipThreshold&&f.add(r)}}}const g=(e,t)=>{this.log("HEARTBEAT: Remove mesh link to %s in %s",e,o),this.addBackoff(e,o),i.delete(e),a(e)>=this.opts.scoreThresholds.gossipThreshold&&f.add(e),this.metrics?.onRemoveFromMesh(o,t,1);const r=l.get(e);null==r?l.set(e,[o]):r.push(o)},m=(e,t)=>{this.log("HEARTBEAT: Add mesh link to %s in %s",e,o),this.score.graft(e,o),i.add(e),f.delete(e),this.metrics?.onAddToMesh(o,t,1);const r=c.get(e);null==r?c.set(e,[o]):r.push(o)};if(i.forEach((e=>{const t=a(e);t<0&&(this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s",e,t,o),g(e,qc.BadScore),u.set(e,!0))})),i.size<t){(y=p,w=e-i.size,nl(y,w,(()=>!0))).forEach((e=>{m(e,zc.NotEnough)}))}var y,w;if(i.size>r){let t=Array.from(i);t.sort(((e,t)=>a(t)-a(e))),t=t.slice(0,n).concat(bl(t.slice(n)));let r=0;if(t.slice(0,e).forEach((e=>{this.outbound.get(e)&&r++})),r<s){const n=e=>{const r=t[e];for(let r=e;r>0;r--)t[r]=t[r-1];t[0]=r};if(r>0){let s=r;for(let r=1;r<e&&s>0;r++)this.outbound.get(t[r])&&(n(r),s--)}let s=e-r;for(let r=e;r<t.length&&s>0;r++)this.outbound.get(t[r])&&(n(r),s--)}t.slice(e).forEach((e=>{g(e,qc.Excess)}))}if(i.size>=t){let e=0;i.forEach((t=>{this.outbound.get(t)&&e++})),e<s&&nl(p,s-e,(e=>!0===this.outbound.get(e))).forEach((e=>{m(e,zc.Outbound)}))}if(this.heartbeatTicks%this.opts.opportunisticGraftTicks==0&&i.size>1){const e=Array.from(i).sort(((e,t)=>a(e)-a(t))),t=Math.floor(i.size/2),r=a(e[t]);if(r<this.opts.scoreThresholds.opportunisticGraftThreshold){const e=nl(p,this.opts.opportunisticGraftPeers,(e=>a(e)>r));for(const t of e)this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s",t,o),m(t,zc.Opportunistic)}}}));const d=Date.now();this.fanoutLastpub.forEach(((e,t)=>{e+i<d&&(this.fanout.delete(t),this.fanoutLastpub.delete(t))})),this.fanout.forEach(((t,r)=>{const n=this.topics.get(r);t.forEach((e=>{(!n?.has(e)||a(e)<this.opts.scoreThresholds.publishThreshold)&&t.delete(e)}));const s=this.topics.get(r),i=[],o=new Set;if(h.set(r,o),null!=s){const e=bl(Array.from(s));for(const r of e){const e=this.streamsOutbound.get(r);if(null!=e&&this.multicodecs.includes(e.protocol)&&!t.has(r)&&!this.direct.has(r)){const e=a(r);e>=this.opts.scoreThresholds.publishThreshold&&i.push(r),e>=this.opts.scoreThresholds.gossipThreshold&&o.add(r)}}}if(t.size<e){const r=e-t.size;i.slice(0,r).forEach((e=>{t.add(e),o?.delete(e)}))}})),this.emitGossip(h),await this.sendGraftPrune(c,l,u),this.flush(),this.mcache.shift(),this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"))}getRandomGossipPeers(e,t,r=()=>!0){const n=this.topics.get(e);if(null==n)return new Set;let s=[];return n.forEach((e=>{const t=this.streamsOutbound.get(e);null!=t&&this.multicodecs.includes(t.protocol)&&r(e)&&s.push(e)})),s=bl(s),t>0&&s.length>t&&(s=s.slice(0,t)),new Set(s)}onScrapeMetrics(e){e.mcacheSize.set(this.mcache.size),e.mcacheNotValidatedCount.set(this.mcache.notValidatedCount),e.cacheSize.set({cache:"direct"},this.direct.size),e.cacheSize.set({cache:"seenCache"},this.seenCache.size),e.cacheSize.set({cache:"fastMsgIdCache"},this.fastMsgIdCache?.size??0),e.cacheSize.set({cache:"publishedMessageIds"},this.publishedMessageIds.size),e.cacheSize.set({cache:"mcache"},this.mcache.size),e.cacheSize.set({cache:"score"},this.score.size),e.cacheSize.set({cache:"gossipTracer.promises"},this.gossipTracer.size),e.cacheSize.set({cache:"gossipTracer.requests"},this.gossipTracer.requestMsByMsgSize),e.cacheSize.set({cache:"topics"},this.topics.size),e.cacheSize.set({cache:"subscriptions"},this.subscriptions.size),e.cacheSize.set({cache:"mesh"},this.mesh.size),e.cacheSize.set({cache:"fanout"},this.fanout.size),e.cacheSize.set({cache:"peers"},this.peers.size),e.cacheSize.set({cache:"streamsOutbound"},this.streamsOutbound.size),e.cacheSize.set({cache:"streamsInbound"},this.streamsInbound.size),e.cacheSize.set({cache:"acceptFromWhitelist"},this.acceptFromWhitelist.size),e.cacheSize.set({cache:"gossip"},this.gossip.size),e.cacheSize.set({cache:"control"},this.control.size),e.cacheSize.set({cache:"peerhave"},this.peerhave.size),e.cacheSize.set({cache:"outbound"},this.outbound.size);let t=0;const r=Date.now();e.connectedPeersBackoffSec.reset();for(const n of this.backoff.values()){t+=n.size;for(const[t,s]of n.entries())this.peers.has(t)&&e.connectedPeersBackoffSec.observe(Math.max(0,s-r)/1e3)}e.cacheSize.set({cache:"backoff"},t);let n=0;for(const e of this.idontwants.values())n+=e.size;e.cacheSize.set({cache:"idontwants"},n);for(const[t,r]of this.topics)e.topicPeersCount.set({topicStr:t},r.size);for(const[t,r]of this.mesh)e.meshPeerCounts.set({topicStr:t},r.size);const s=[],i=new Map;e.behaviourPenalty.reset();for(const t of this.peers.keys()){const r=this.score.score(t);s.push(r),i.set(t,r),e.behaviourPenalty.observe(this.score.peerStats.get(t)?.behaviourPenalty??0)}e.registerScores(s,this.opts.scoreThresholds),e.registerScorePerMesh(this.mesh,i);const o=function(e,t,r,n,s){const i={byTopic:new Map,p5w:[],p6w:[],p7w:[],score:[]};for(const o of e){const e=t.get(o);if(null!=e){const t=ul(o,e,r,n,s);for(const[e,r]of t.byTopic){let t=i.byTopic.get(e);null==t&&(t={p1w:[],p2w:[],p3w:[],p3bw:[],p4w:[]},i.byTopic.set(e,t)),t.p1w.push(r.p1w),t.p2w.push(r.p2w),t.p3w.push(r.p3w),t.p3bw.push(r.p3bw),t.p4w.push(r.p4w)}i.p5w.push(t.p5w),i.p6w.push(t.p6w),i.p7w.push(t.p7w),i.score.push(t.score)}else i.p5w.push(0),i.p6w.push(0),i.p7w.push(0),i.score.push(0)}return i}(this.peers.keys(),this.score.peerStats,this.score.params,this.score.peerIPs,e.topicStrToLabel);e.registerScoreWeights(o)}tagMeshPeer=e=>{const{peerId:t,topic:r}=e.detail;this.components.peerStore.merge(ec(t),{tags:{[r]:{value:100}}}).catch((e=>{this.log.error("Error tagging peer %s with topic %s",t,r,e)}))};untagMeshPeer=e=>{const{peerId:t,topic:r}=e.detail;this.components.peerStore.merge(ec(t),{tags:{[r]:void 0}}).catch((e=>{this.log.error("Error untagging peer %s with topic %s",t,r,e)}))}}function tu(e={}){return t=>new eu(t,e)}class ru extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}}async function nu(e,t,r){if(null==t)return e;if(t.aborted)return Promise.reject(new ru(r?.errorMessage,r?.errorCode,r?.errorName));let n;const s=new ru(r?.errorMessage,r?.errorCode,r?.errorName);try{return await Promise.race([e,new Promise(((e,r)=>{n=()=>{r(s)},t.addEventListener("abort",n)}))])}finally{null!=n&&t.removeEventListener("abort",n)}}class su{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=bc(),this.haveNext=bc()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=bc(),e}async throw(e){return this.ended=!0,null!=e&&(this.haveNext.promise.catch((()=>{})),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){return await this._push(void 0),{done:!0,value:void 0}}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=bc(),await nu(this.readNext.promise,t?.signal,t)}}class iu extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}class ou extends Error{code;constructor(e,t){super(e),this.code=t}}class au extends ou{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}}function cu(e,t){const r=new su;e.sink(r).catch((async e=>{await r.end(e)})),e.sink=async e=>{for await(const t of e)await r.push(t);await r.end()};let n=e.source;null!=e.source[Symbol.iterator]?n=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(n=e.source[Symbol.asyncIterator]());const s=new cc,i={read:async(e,t)=>{let r;t?.signal?.throwIfAborted();const i=new Promise(((e,n)=>{r=()=>{n(new au("Read aborted"))},t?.signal?.addEventListener("abort",r)}));try{if(null==e){const{done:e,value:t}=await Promise.race([n.next(),i]);return!0===e?new cc:t}for(;s.byteLength<e;){const{value:e,done:t}=await Promise.race([n.next(),i]);if(!0===t)throw new iu("unexpected end of input");s.append(e)}const t=s.sublist(0,e);return s.consume(e),t}finally{null!=r&&t?.signal?.removeEventListener("abort",r)}},write:async(e,t)=>{t?.signal?.throwIfAborted(),e instanceof Uint8Array?await r.push(e,t):await r.push(e.subarray(),t)},unwrap:()=>{if(s.byteLength>0){const r=e.source;e.source=async function*(){!1===t?.yieldBytes?yield s:yield*s,yield*r}()}return e}};return i}class lu extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class uu extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class hu extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function du(e,t={}){const r=cu(e,t);null!=t.maxDataLength&&null==t.maxLengthLength&&(t.maxLengthLength=hn(t.maxDataLength));const n=t?.lengthDecoder??gn,s=t?.lengthEncoder??fn,i={read:async e=>{let s=-1;const i=new cc;for(;;){i.append(await r.read(1,e));try{s=n(i)}catch(e){if(e instanceof RangeError)continue;throw e}if(s<0)throw new lu("Invalid message length");if(null!=t?.maxLengthLength&&i.byteLength>t.maxLengthLength)throw new hu("message length length too long");if(s>-1)break}if(null!=t?.maxDataLength&&s>t.maxDataLength)throw new uu("message length too long");return r.read(s,e)},write:async(e,t)=>{await r.write(new cc(s(e.byteLength),e),t)},writeV:async(e,t)=>{const n=new cc(...e.flatMap((e=>[s(e.byteLength),e])));await r.write(n,t)},unwrap:()=>r.unwrap()};return i}function pu(){const e=bc();let t=!1;return{sink:async r=>{if(t)throw new Error("already piped");t=!0,e.resolve(r)},source:async function*(){const t=await e.promise;yield*t}()}}const fu=65535,gu=Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);function mu(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function yu(e){if("boolean"!=typeof e)throw new Error(`boolean expected, not ${e}`)}function wu(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function bu(e,...t){if(!wu(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function vu(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}const Su=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4));if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function Eu(e){if("string"==typeof e)e=function(e){if("string"!=typeof e)throw new Error("string expected, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e);else{if(!wu(e))throw new Error("Uint8Array expected, got "+typeof e);e=Iu(e)}return e}const ku=(e,t)=>(Object.assign(t,e),t);function Au(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i),c=n?4:0,l=n?0:4;e.setUint32(t+c,o,n),e.setUint32(t+l,a,n)}function Iu(e){return Uint8Array.from(e)}function _u(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const Cu=e=>Uint8Array.from(e.split("").map((e=>e.charCodeAt(0)))),xu=Cu("expand 16-byte k"),Tu=Cu("expand 32-byte k"),Mu=Su(xu),Pu=Su(Tu);function Du(e,t){return e<<t|e>>>32-t}function Nu(e){return e.byteOffset%4==0}Pu.slice();const Ru=2**32-1,Bu=new Uint32Array;function Lu(e,t){const{allowShortKeys:r,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=function(e,t){if(null==t||"object"!=typeof t)throw new Error("options must be defined");return Object.assign({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t)}(0,t);if("function"!=typeof e)throw new Error("core must be a function");return mu(s),mu(o),yu(i),yu(r),(t,a,c,l,u=0)=>{bu(t),bu(a),bu(c);const h=c.length;if(void 0===l&&(l=new Uint8Array(h)),bu(l),mu(u),u<0||u>=Ru)throw new Error("arx: counter overflow");if(l.length<h)throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);const d=[];let p,f,g=t.length;if(32===g)d.push(p=Iu(t)),f=Pu;else{if(16!==g||!r)throw new Error(`arx: invalid 32-byte key, got length=${g}`);p=new Uint8Array(32),p.set(t),p.set(t,16),f=Mu,d.push(p)}Nu(a)||d.push(a=Iu(a));const m=Su(p);if(n){if(24!==a.length)throw new Error("arx: extended nonce must be 24 bytes");n(f,m,Su(a.subarray(0,16)),m),a=a.subarray(16)}const y=16-s;if(y!==a.length)throw new Error(`arx: nonce must be ${y} or 16 bytes`);if(12!==y){const e=new Uint8Array(12);e.set(a,i?0:12-a.length),a=e,d.push(a)}const w=Su(a);return function(e,t,r,n,s,i,o,a){const c=s.length,l=new Uint8Array(64),u=Su(l),h=Nu(s)&&Nu(i),d=h?Su(s):Bu,p=h?Su(i):Bu;for(let f=0;f<c;o++){if(e(t,r,n,u,o,a),o>=Ru)throw new Error("arx: counter overflow");const g=Math.min(64,c-f);if(h&&64===g){const e=f/4;if(f%4!=0)throw new Error("arx: invalid block position");for(let t,r=0;r<16;r++)t=e+r,p[t]=d[t]^u[r];f+=64}else{for(let e,t=0;t<g;t++)e=f+t,i[e]=s[e]^l[t];f+=g}}}(e,f,m,w,c,l,u,o),_u(...d),l}}const Ou=(e,t)=>255&e[t++]|(255&e[t++])<<8;class Uu{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,bu(e=Eu(e),32);const t=Ou(e,0),r=Ou(e,2),n=Ou(e,4),s=Ou(e,6),i=Ou(e,8),o=Ou(e,10),a=Ou(e,12),c=Ou(e,14);this.r[0]=8191&t,this.r[1]=8191&(t>>>13|r<<3),this.r[2]=7939&(r>>>10|n<<6),this.r[3]=8191&(n>>>7|s<<9),this.r[4]=255&(s>>>4|i<<12),this.r[5]=i>>>1&8190,this.r[6]=8191&(i>>>14|o<<2),this.r[7]=8065&(o>>>11|a<<5),this.r[8]=8191&(a>>>8|c<<8),this.r[9]=c>>>5&127;for(let t=0;t<8;t++)this.pad[t]=Ou(e,16+2*t)}process(e,t,r=!1){const n=r?0:2048,{h:s,r:i}=this,o=i[0],a=i[1],c=i[2],l=i[3],u=i[4],h=i[5],d=i[6],p=i[7],f=i[8],g=i[9],m=Ou(e,t+0),y=Ou(e,t+2),w=Ou(e,t+4),b=Ou(e,t+6),v=Ou(e,t+8),S=Ou(e,t+10),E=Ou(e,t+12),k=Ou(e,t+14);let A=s[0]+(8191&m),I=s[1]+(8191&(m>>>13|y<<3)),_=s[2]+(8191&(y>>>10|w<<6)),C=s[3]+(8191&(w>>>7|b<<9)),x=s[4]+(8191&(b>>>4|v<<12)),T=s[5]+(v>>>1&8191),M=s[6]+(8191&(v>>>14|S<<2)),P=s[7]+(8191&(S>>>11|E<<5)),D=s[8]+(8191&(E>>>8|k<<8)),N=s[9]+(k>>>5|n),R=0,B=R+A*o+I*(5*g)+_*(5*f)+C*(5*p)+x*(5*d);R=B>>>13,B&=8191,B+=T*(5*h)+M*(5*u)+P*(5*l)+D*(5*c)+N*(5*a),R+=B>>>13,B&=8191;let L=R+A*a+I*o+_*(5*g)+C*(5*f)+x*(5*p);R=L>>>13,L&=8191,L+=T*(5*d)+M*(5*h)+P*(5*u)+D*(5*l)+N*(5*c),R+=L>>>13,L&=8191;let O=R+A*c+I*a+_*o+C*(5*g)+x*(5*f);R=O>>>13,O&=8191,O+=T*(5*p)+M*(5*d)+P*(5*h)+D*(5*u)+N*(5*l),R+=O>>>13,O&=8191;let U=R+A*l+I*c+_*a+C*o+x*(5*g);R=U>>>13,U&=8191,U+=T*(5*f)+M*(5*p)+P*(5*d)+D*(5*h)+N*(5*u),R+=U>>>13,U&=8191;let F=R+A*u+I*l+_*c+C*a+x*o;R=F>>>13,F&=8191,F+=T*(5*g)+M*(5*f)+P*(5*p)+D*(5*d)+N*(5*h),R+=F>>>13,F&=8191;let V=R+A*h+I*u+_*l+C*c+x*a;R=V>>>13,V&=8191,V+=T*o+M*(5*g)+P*(5*f)+D*(5*p)+N*(5*d),R+=V>>>13,V&=8191;let $=R+A*d+I*h+_*u+C*l+x*c;R=$>>>13,$&=8191,$+=T*a+M*o+P*(5*g)+D*(5*f)+N*(5*p),R+=$>>>13,$&=8191;let H=R+A*p+I*d+_*h+C*u+x*l;R=H>>>13,H&=8191,H+=T*c+M*a+P*o+D*(5*g)+N*(5*f),R+=H>>>13,H&=8191;let z=R+A*f+I*p+_*d+C*h+x*u;R=z>>>13,z&=8191,z+=T*l+M*c+P*a+D*o+N*(5*g),R+=z>>>13,z&=8191;let q=R+A*g+I*f+_*p+C*d+x*h;R=q>>>13,q&=8191,q+=T*u+M*l+P*c+D*a+N*o,R+=q>>>13,q&=8191,R=(R<<2)+R|0,R=R+B|0,B=8191&R,R>>>=13,L+=R,s[0]=B,s[1]=L,s[2]=O,s[3]=U,s[4]=F,s[5]=V,s[6]=$,s[7]=H,s[8]=z,s[9]=q}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let n=e[1]>>>13;e[1]&=8191;for(let t=2;t<10;t++)e[t]+=n,n=e[t]>>>13,e[t]&=8191;e[0]+=5*n,n=e[0]>>>13,e[0]&=8191,e[1]+=n,n=e[1]>>>13,e[1]&=8191,e[2]+=n,r[0]=e[0]+5,n=r[0]>>>13,r[0]&=8191;for(let t=1;t<10;t++)r[t]=e[t]+n,n=r[t]>>>13,r[t]&=8191;r[9]-=8192;let s=(1^n)-1;for(let e=0;e<10;e++)r[e]&=s;s=~s;for(let t=0;t<10;t++)e[t]=e[t]&s|r[t];e[0]=65535&(e[0]|e[1]<<13),e[1]=65535&(e[1]>>>3|e[2]<<10),e[2]=65535&(e[2]>>>6|e[3]<<7),e[3]=65535&(e[3]>>>9|e[4]<<4),e[4]=65535&(e[4]>>>12|e[5]<<1|e[6]<<14),e[5]=65535&(e[6]>>>2|e[7]<<11),e[6]=65535&(e[7]>>>5|e[8]<<8),e[7]=65535&(e[8]>>>8|e[9]<<5);let i=e[0]+t[0];e[0]=65535&i;for(let r=1;r<8;r++)i=(e[r]+t[r]|0)+(i>>>16)|0,e[r]=65535&i;_u(r)}update(e){vu(this);const{buffer:t,blockLen:r}=this,n=(e=Eu(e)).length;for(let s=0;s<n;){const i=Math.min(r-this.pos,n-s);if(i!==r)t.set(e.subarray(s,s+i),this.pos),this.pos+=i,s+=i,this.pos===r&&(this.process(t,0,!1),this.pos=0);else for(;r<=n-s;s+=r)this.process(e,s)}return this}destroy(){_u(this.h,this.r,this.buffer,this.pad)}digestInto(e){vu(this),function(e,t){bu(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:n}=this;if(n){for(t[n++]=1;n<16;n++)t[n]=0;this.process(t,0,!0)}this.finalize();let s=0;for(let t=0;t<8;t++)e[s++]=r[t]>>>0,e[s++]=r[t]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}const Fu=function(e){const t=(t,r)=>e(r).update(Eu(t)).digest(),r=e(new Uint8Array(32));return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=t=>e(t),t}((e=>new Uu(e)));function Vu(e,t,r,n,s,i=20){let o=e[0],a=e[1],c=e[2],l=e[3],u=t[0],h=t[1],d=t[2],p=t[3],f=t[4],g=t[5],m=t[6],y=t[7],w=s,b=r[0],v=r[1],S=r[2],E=o,k=a,A=c,I=l,_=u,C=h,x=d,T=p,M=f,P=g,D=m,N=y,R=w,B=b,L=v,O=S;for(let e=0;e<i;e+=2)E=E+_|0,R=Du(R^E,16),M=M+R|0,_=Du(_^M,12),E=E+_|0,R=Du(R^E,8),M=M+R|0,_=Du(_^M,7),k=k+C|0,B=Du(B^k,16),P=P+B|0,C=Du(C^P,12),k=k+C|0,B=Du(B^k,8),P=P+B|0,C=Du(C^P,7),A=A+x|0,L=Du(L^A,16),D=D+L|0,x=Du(x^D,12),A=A+x|0,L=Du(L^A,8),D=D+L|0,x=Du(x^D,7),I=I+T|0,O=Du(O^I,16),N=N+O|0,T=Du(T^N,12),I=I+T|0,O=Du(O^I,8),N=N+O|0,T=Du(T^N,7),E=E+C|0,O=Du(O^E,16),D=D+O|0,C=Du(C^D,12),E=E+C|0,O=Du(O^E,8),D=D+O|0,C=Du(C^D,7),k=k+x|0,R=Du(R^k,16),N=N+R|0,x=Du(x^N,12),k=k+x|0,R=Du(R^k,8),N=N+R|0,x=Du(x^N,7),A=A+T|0,B=Du(B^A,16),M=M+B|0,T=Du(T^M,12),A=A+T|0,B=Du(B^A,8),M=M+B|0,T=Du(T^M,7),I=I+_|0,L=Du(L^I,16),P=P+L|0,_=Du(_^P,12),I=I+_|0,L=Du(L^I,8),P=P+L|0,_=Du(_^P,7);let U=0;n[U++]=o+E|0,n[U++]=a+k|0,n[U++]=c+A|0,n[U++]=l+I|0,n[U++]=u+_|0,n[U++]=h+C|0,n[U++]=d+x|0,n[U++]=p+T|0,n[U++]=f+M|0,n[U++]=g+P|0,n[U++]=m+D|0,n[U++]=y+N|0,n[U++]=w+R|0,n[U++]=b+B|0,n[U++]=v+L|0,n[U++]=S+O|0}const $u=Lu(Vu,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Hu=Lu(Vu,{counterRight:!1,counterLength:8,extendNonceFn:function(e,t,r,n){let s=e[0],i=e[1],o=e[2],a=e[3],c=t[0],l=t[1],u=t[2],h=t[3],d=t[4],p=t[5],f=t[6],g=t[7],m=r[0],y=r[1],w=r[2],b=r[3];for(let e=0;e<20;e+=2)s=s+c|0,m=Du(m^s,16),d=d+m|0,c=Du(c^d,12),s=s+c|0,m=Du(m^s,8),d=d+m|0,c=Du(c^d,7),i=i+l|0,y=Du(y^i,16),p=p+y|0,l=Du(l^p,12),i=i+l|0,y=Du(y^i,8),p=p+y|0,l=Du(l^p,7),o=o+u|0,w=Du(w^o,16),f=f+w|0,u=Du(u^f,12),o=o+u|0,w=Du(w^o,8),f=f+w|0,u=Du(u^f,7),a=a+h|0,b=Du(b^a,16),g=g+b|0,h=Du(h^g,12),a=a+h|0,b=Du(b^a,8),g=g+b|0,h=Du(h^g,7),s=s+l|0,b=Du(b^s,16),f=f+b|0,l=Du(l^f,12),s=s+l|0,b=Du(b^s,8),f=f+b|0,l=Du(l^f,7),i=i+u|0,m=Du(m^i,16),g=g+m|0,u=Du(u^g,12),i=i+u|0,m=Du(m^i,8),g=g+m|0,u=Du(u^g,7),o=o+h|0,y=Du(y^o,16),d=d+y|0,h=Du(h^d,12),o=o+h|0,y=Du(y^o,8),d=d+y|0,h=Du(h^d,7),a=a+c|0,w=Du(w^a,16),p=p+w|0,c=Du(c^p,12),a=a+c|0,w=Du(w^a,8),p=p+w|0,c=Du(c^p,7);let v=0;n[v++]=s,n[v++]=i,n[v++]=o,n[v++]=a,n[v++]=m,n[v++]=y,n[v++]=w,n[v++]=b},allowShortKeys:!1}),zu=new Uint8Array(16),qu=(e,t)=>{e.update(t);const r=t.length%16;r&&e.update(zu.subarray(r))},ju=new Uint8Array(32);function Wu(e,t,r,n,s){const i=e(t,r,ju),o=Fu.create(i);s&&qu(o,s),qu(o,n);const a=new Uint8Array(16),c=(l=a,new DataView(l.buffer,l.byteOffset,l.byteLength));var l;Au(c,0,BigInt(s?s.length:0),!0),Au(c,8,BigInt(n.length),!0),o.update(a);const u=o.digest();return _u(i,a),u}const Ku=e=>(t,r,n)=>(bu(t,32),bu(r),{encrypt(s,i){const o=s.length,a=o+16;i?bu(i,a):i=new Uint8Array(a),e(t,r,s,i,1);const c=Wu(e,t,r,i.subarray(0,-16),n);return i.set(c,o),_u(c),i},decrypt(s,i){const o=s.length,a=o-16;if(o<16)throw new Error("encrypted data must be at least 16 bytes");i?bu(i,a):i=new Uint8Array(a);const c=s.subarray(0,-16),l=s.subarray(-16),u=Wu(e,t,r,c,n);if(!function(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r}(l,u))throw new Error("invalid tag");return e(t,r,c,i,1),_u(u),i}}),Gu=ku({blockSize:64,nonceLength:12,tagLength:16},Ku($u));Ku(Hu);class Yu extends js{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Fs(e);const r=qs(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),s.fill(0)}update(e){return Vs(this),this.iHash.update(e),this}digestInto(e){Vs(this),Us(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:s,blockLen:i,outputLen:o}=this;return e.finished=n,e.destroyed=s,e.blockLen=i,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ju=(e,t,r)=>new Yu(e,t).update(r).digest();Ju.create=(e,t)=>new Yu(e,t);const Qu=new Uint8Array([0]),Zu=new Uint8Array;const Xu={hashSHA256:e=>Xs(e.subarray()),getHKDF(e,t){const r=function(e,t,r){return Fs(e),void 0===r&&(r=new Uint8Array(e.outputLen)),Ju(e,qs(r),qs(t))}(Xs,t,e),n=function(e,t,r,n=32){if(Fs(e),Os(n),n>255*e.outputLen)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(n/e.outputLen);void 0===r&&(r=Zu);const i=new Uint8Array(s*e.outputLen),o=Ju.create(e,t),a=o._cloneInto(),c=new Uint8Array(o.outputLen);for(let t=0;t<s;t++)Qu[0]=t+1,a.update(0===t?Zu:c).update(r).update(Qu).digestInto(c),i.set(c,e.outputLen*t),o._cloneInto(a);return o.destroy(),a.destroy(),c.fill(0),Qu.fill(0),i.slice(0,n)}(Xs,r,void 0,96);return[n.subarray(0,32),n.subarray(32,64),n.subarray(64,96)]},generateX25519KeyPair(){const e=Kr.utils.randomPrivateKey();return{publicKey:Kr.getPublicKey(e),privateKey:e}},generateX25519KeyPairFromSeed:e=>({publicKey:Kr.getPublicKey(e),privateKey:e}),generateX25519SharedKey:(e,t)=>Kr.getSharedSecret(e.subarray(),t.subarray()),chaCha20Poly1305Encrypt:(e,t,r,n)=>Gu(n,t,r).encrypt(e.subarray()),chaCha20Poly1305Decrypt:(e,t,r,n,s)=>Gu(n,t,r).decrypt(e.subarray(),s)},eh=e=>{const t=en(2);return t[0]=e>>8,t[1]=e,t};eh.bytes=2;const th=e=>{if(e.length<2)throw RangeError("Could not decode int16BE");if(e instanceof Uint8Array){let t=0;return t+=e[0]<<8,t+=e[1],t}return e.getUint16(0)};function rh(e,t){t.enabled&&gu&&(e?(t(`LOCAL_STATIC_PUBLIC_KEY ${ia(e.publicKey,"hex")}`),t(`LOCAL_STATIC_PRIVATE_KEY ${ia(e.privateKey,"hex")}`)):t("Missing local static keys."))}function nh(e,t){t.enabled&&gu&&(e?(t(`LOCAL_PUBLIC_EPHEMERAL_KEY ${ia(e.publicKey,"hex")}`),t(`LOCAL_PRIVATE_EPHEMERAL_KEY ${ia(e.privateKey,"hex")}`)):t("Missing local ephemeral keys."))}function sh(e,t){t.enabled&&gu&&t(e?`REMOTE_EPHEMERAL_PUBLIC_KEY ${ia(e.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function ih(e,t,r){r.enabled&&gu&&(r(`CIPHER_STATE_1 ${e.n.getUint64()} ${e.k&&ia(e.k,"hex")}`),r(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&ia(t.k,"hex")}`))}th.bytes=2;class oh extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=oh.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}class ah{n;bytes;view;constructor(e=0){this.n=e,this.bytes=Xr(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>4294967295)throw new Error("Cipherstate has reached maximum n, a new handshake must be performed")}}const ch=Xr(0);class lh{k;n;crypto;constructor(e,t=void 0,r=0){this.crypto=e,this.k=t,this.n=new ah(r)}hasKey(){return Boolean(this.k)}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),n}}class uh{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const r=ds(t,"utf-8");this.h=function(e,t){if(t.length<=32){const e=Xr(32);return e.set(t),e}return e.hash(t)}(e,r),this.ck=this.h,this.cs=new lh(e)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new lh(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new cc(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,ch);return[new lh(this.crypto,e),new lh(this.crypto,t)]}}class hh{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:r,prologue:n,initiator:s,s:i,e:o,rs:a,re:c}=e;this.crypto=t,this.ss=new uh(t,r),this.ss.mixHash(n),this.initiator=s,this.s=i,this.e=o,this.rs=a,this.re=c}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw new Error("message is not long enough");const n=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(n),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class dh extends hh{writeMessageA(e){return new cc(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new cc(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new cc(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(e){throw new oh(`handshake stage 0 validation fail: ${e.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(e){throw new oh(`handshake stage 1 validation fail: ${e.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(e){throw new oh(`handshake stage 2 validation fail: ${e.message}`)}}}var ph,fh;async function gh(e,t,r){const n=await e.sign(yh(t));return fh.encode({identityKey:ja(e.publicKey),identitySig:n,extensions:r})}async function mh(e,t,r){try{const n=fh.decode(e),s=qa(n.identityKey);if(!1===r?.equals(s))throw new Error(`Payload identity key ${s} does not match expected remote identity key ${r}`);if(!t)throw new Error("Remote static does not exist");const i=yh(t);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(e){throw new x(e.message)}}function yh(e){const t=ds("noise-libp2p-static-key:");return e instanceof Uint8Array?sc([t,e],t.length+e.length):(e.prepend(t),e)}!function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.webtransportCerthashes)for(const r of e.webtransportCerthashes)t.uint32(10),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={webtransportCerthashes:[]},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();t>>>3==1?r.webtransportCerthashes.push(e.bytes()):e.skipType(7&t)}return r}))),t),e.encode=t=>_s(t,e.codec()),e.decode=t=>Pn(t,e.codec())}(ph||(ph={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.identityKey&&e.identityKey.byteLength>0&&(t.uint32(10),t.bytes(e.identityKey)),null!=e.identitySig&&e.identitySig.byteLength>0&&(t.uint32(18),t.bytes(e.identitySig)),null!=e.extensions&&(t.uint32(34),ph.codec().encode(e.extensions,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={identityKey:Xr(0),identitySig:Xr(0)},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.identityKey=e.bytes();break;case 2:r.identitySig=e.bytes();break;case 4:r.extensions=ph.codec().decode(e,e.uint32());break;default:e.skipType(7&t)}}return r}))),t),e.encode=t=>_s(t,e.codec()),e.decode=t=>Pn(t,e.codec())}(fh||(fh={}));class wh{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:r,extensions:n,crypto:s,prologueBytes:i}=t,{metrics:o}=e;this.components=e;const a=s??Xu;this.crypto=function(e){return{generateKeypair:e.generateX25519KeyPair,dh:(t,r)=>e.generateX25519SharedKey(t.privateKey,r).subarray(0,32),encrypt:e.chaCha20Poly1305Encrypt,decrypt:e.chaCha20Poly1305Decrypt,hash:e.hashSHA256,hkdf:e.getHKDF}}(a),this.extensions=n,this.metrics=o?function(e){return{xxHandshakeSuccesses:e.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:e.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:e.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:e.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:e.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}(o):void 0,this.staticKey=r?a.generateX25519KeyPairFromSeed(r):a.generateX25519KeyPair(),this.prologue=i??Xr(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[I]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const r=du(e,{lengthEncoder:eh,lengthDecoder:th,maxDataLength:fu}),n=await this.performHandshakeInitiator(r,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(r,n);e.source=s.source,e.sink=s.sink;const i=qa(n.payload.identityKey);return{conn:e,remoteExtensions:n.payload.extensions,remotePeer:tc(i)}}async secureInbound(e,t){const r=du(e,{lengthEncoder:eh,lengthDecoder:th,maxDataLength:fu}),n=await this.performHandshakeResponder(r,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(r,n);e.source=s.source,e.sink=s.sink;const i=qa(n.payload.identityKey);return{conn:e,remoteExtensions:n.payload.extensions,remotePeer:tc(i)}}async performHandshakeInitiator(e,t,r,n){let s;try{s=await async function(e,t){const{log:r,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=e,u=await gh(i,a.publicKey,l),h=new dh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});rh(h.s,r),r.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(ch),t),r.trace("Stage 0 - Initiator finished sending first message."),nh(h.e,r),r.trace("Stage 1 - Initiator waiting to receive first message from responder...");const d=h.readMessageB(await n.read(t));var p,f;r.trace("Stage 1 - Initiator received the message."),sh(h.re,r),p=h.rs,(f=r).enabled&&gu&&f(p?`REMOTE_STATIC_PUBLIC_KEY ${ia(p.subarray(),"hex")}`:"Missing remote static public key."),r.trace("Initiator going to check remote's signature...");const g=await mh(d,h.rs,c);r.trace("All good with the signature!"),r.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(u),t),r.trace("Stage 2 - Initiator sent message with signed payload.");const[m,y]=h.ss.split();return ih(m,y,r),{payload:g,encrypt:e=>m.encryptWithAd(ch,e),decrypt:(e,t)=>y.decryptWithAd(ch,e,t)}}({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},n),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return s}async performHandshakeResponder(e,t,r,n){let s;try{s=await async function(e,t){const{log:r,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=e,u=await gh(i,a.publicKey,l),h=new dh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});rh(h.s,r),r.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(t)),r.trace("Stage 0 - Responder received first message."),sh(h.re,r),r.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(u),t),r.trace("Stage 1 - Responder sent the second handshake message with signed payload."),nh(h.e,r),r.trace("Stage 2 - Responder waiting for third handshake message...");const d=h.readMessageC(await n.read(t));r.trace("Stage 2 - Responder received the message, finished handshake.");const p=await mh(d,h.rs,c),[f,g]=h.ss.split();return ih(f,g,r),{payload:p,encrypt:e=>g.encryptWithAd(ch,e),decrypt:(e,t)=>f.decryptWithAd(ch,e,t)}}({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},n),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return s}async createSecureConnection(e,t){const[r,n]=function(){const e=pu(),t=pu();return[{source:e.source,sink:t.sink},{source:t.source,sink:e.sink}]}(),s=e.unwrap();return await Ic(r,function(e,t){return async function*(r){for await(const n of r)for(let r=0;r<n.length;r+=65519){let s,i=r+65519;i>n.length&&(i=n.length),s=n instanceof Uint8Array?e.encrypt(n.subarray(r,i)):e.encrypt(n.sublist(r,i)),t?.encryptedPackets.increment(),yield new cc(eh(s.byteLength),s)}}}(t,this.metrics),s,(e=>wc(e,{lengthDecoder:th})),function(e,t){return async function*(r){for await(const n of r)for(let r=0;r<n.length;r+=fu){let s=r+fu;if(s>n.length&&(s=n.length),s-16<r)throw new Error("Invalid chunk");const i=n.sublist(r,s),o=n.subarray(r,s-16);try{const r=e.decrypt(i,o);t?.decryptedPackets.increment(),yield r}catch(e){throw t?.decryptErrors.increment(),e}}}}(t,this.metrics),r),n}}function bh(e={}){return t=>new wh(t,e)}function vh(e){if(null!=e){if("function"==typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"==typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"==typeof e.next)return e}throw new Error("argument is not an iterator or iterable")}class Sh extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class Eh extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class kh extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class Ah extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class Ih extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class _h extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class Ch extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class xh extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const Th=new Set([Sh.name,Eh.name,kh.name,Ih.name,_h.name,Ch.name,xh.name]),Mh=262144,Ph={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Mh,maxStreamWindowSize:16777216,maxMessageSize:65536};var Dh,Nh,Rh;!function(e){e[e.Data=0]="Data",e[e.WindowUpdate=1]="WindowUpdate",e[e.Ping=2]="Ping",e[e.GoAway=3]="GoAway"}(Dh||(Dh={})),function(e){e[e.SYN=1]="SYN",e[e.ACK=2]="ACK",e[e.FIN=4]="FIN",e[e.RST=8]="RST"}(Nh||(Nh={})),Object.values(Nh).filter((e=>"string"!=typeof e)),function(e){e[e.NormalTermination=0]="NormalTermination",e[e.ProtocolError=1]="ProtocolError",e[e.InternalError=2]="InternalError"}(Rh||(Rh={}));const Bh=2**24;class Lh{source;buffer;frameInProgress;constructor(e){this.source=function(e){if(void 0!==e[Symbol.iterator]){const t=e[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator]:()=>t}}if(void 0!==e[Symbol.asyncIterator]){const t=e[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator]:()=>t}}throw new Error("a source must be either an iterable or an async iterable")}(e),this.buffer=new cc,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const e=this.readHeader();if(void 0===e)break;const{type:t,length:r}=e;t===Dh.Data?(this.frameInProgress=!0,yield{header:e,readData:this.readBytes.bind(this,r)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new Ah("decoding frame already in progress");if(this.buffer.length<12)return;const e=function(e){if(0!==e[0])throw new Sh("Invalid frame version");return{type:e[1],flag:(e[2]<<8)+e[3],streamID:e[4]*Bh+(e[5]<<16)+(e[6]<<8)+e[7],length:e[8]*Bh+(e[9]<<16)+(e[10]<<8)+e[11]}}(this.buffer.subarray(0,12));return this.buffer.consume(12),e}async readBytes(e){if(this.buffer.length<e)for await(const t of this.source)if(this.buffer.append(t),this.buffer.length>=e)break;const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function Oh(e){const t=new Uint8Array(12);return t[1]=e.type,t[2]=e.flag>>>8,t[3]=e.flag,t[4]=e.streamID>>>24,t[5]=e.streamID>>>16,t[6]=e.streamID>>>8,t[7]=e.streamID,t[8]=e.length>>>24,t[9]=e.length>>>16,t[10]=e.length>>>8,t[11]=e.length,t}function Uh(e){return null!=e&&"function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally}class Fh{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=bc(),this.closed=bc(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??5e3,this.onEnd=e.onEnd,this.onCloseRead=e?.onCloseRead,this.onCloseWrite=e?.onCloseWrite,this.onReset=e?.onReset,this.onAbort=e?.onAbort,this.source=this.streamSource=kc({onEnd:e=>{null!=e?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(e){if("ready"!==this.writeStatus)throw new U(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if("outbound"===this.direction){const e=this.sendNewStream(t);Uh(e)&&await e}const r=()=>{!function(e,t){const r=vh(e).return?.();var n;null!=(n=r)&&"function"==typeof n.then&&"function"==typeof n.catch&&"function"==typeof n.finally&&r.catch((e=>{t.error("could not cause iterator to return",e)}))}(e,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let r of e){r=r instanceof Uint8Array?new cc(r):r;const e=this.sendData(r,t);Uh(e)&&(this.sendingData=bc(),await e,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),"writing"===this.writeStatus&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){null==this.timeline.closeRead&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseRead?.(),null!=this.timeline.closeWrite?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){null==this.timeline.closeWrite&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseWrite?.(),null!=this.timeline.closeRead?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){"open"===this.status&&(this.log.trace("closing gracefully"),this.status="closing",await nu(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if("closing"===this.readStatus||"closed"===this.readStatus)return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing","reset"!==this.status&&"aborted"!==this.status&&null==this.timeline.closeRead&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),"ready"===t&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){"closing"!==this.writeStatus&&"closed"!==this.writeStatus&&(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),"ready"===this.writeStatus&&(this.log.trace("sink was never sunk, sink an empty array"),await nu(this.sink([]),e.signal)),"writing"===this.writeStatus&&(null!=this.sendingData&&await nu(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await nu(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();Uh(t)&&t.catch((e=>{this.log.error("error sending reset message",e)})),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;const e=new O("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){"writing"===this.writeStatus&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){"closing"!==this.readStatus&&"closed"!==this.readStatus&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){"closing"!==this.readStatus&&"closed"!==this.readStatus?(this.log.trace("remote close write"),this._closeSource()):this.log("received remote close write but local source is already closed")}remoteCloseRead(){"closing"!==this.writeStatus&&"closed"!==this.writeStatus?(this.log.trace("remote close read"),this._closeSink()):this.log("received remote close read but local sink is already closed")}destroy(){"closed"!==this.status&&"aborted"!==this.status&&"reset"!==this.status?(this.log.trace("stream destroyed"),this._closeSinkAndSource()):this.log("received destroy but we are already closed")}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}const Vh=function(e){const[t,r]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push:e=>{n.push(e)},next:()=>n.length>0?{done:!1,value:n.shift()}:t.next(),[r](){return this}}};function $h(e){return null!=e?.then}const Hh=function(e,t){let r=0;if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e){const e=t(n,r++);$h(e)&&await e,yield n}}();const n=Vh(e),{value:s,done:i}=n.next();if(!0===i)return function*(){}();const o=t(s,r++);if("function"==typeof o?.then)return async function*(){yield s;for await(const e of n){const n=t(e,r++);$h(n)&&await n,yield e}}();const a=t;return function*(){yield s;for(const e of n)a(e,r++),yield e}()};var zh;!function(e){e[e.Init=0]="Init",e[e.SYNSent=1]="SYNSent",e[e.SYNReceived=2]="SYNReceived",e[e.Established=3]="Established",e[e.Finished=4]="Finished"}(zh||(zh={}));class qh extends Fh{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=zh.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Mh,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=Hh(this.source,(()=>{this.sendWindowUpdate()}))}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();0!==e.byteLength;){if(0===this.sendWindowCapacity&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),"closed"===this.status||"aborted"===this.status||"reset"===this.status))return void this.log?.trace("%s while waiting for send window capacity",this.status);const r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-12,e.length),n=this.getSendFlags();this.sendFrame({type:Dh.Data,flag:n,streamID:this._id,length:r},e.sublist(0,r)),this.sendWindowCapacity-=r,e.consume(r)}}async sendReset(){this.sendFrame({type:Dh.WindowUpdate,flag:Nh.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|Nh.FIN;this.sendFrame({type:Dh.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,r;const n=()=>{"open"===this.status||"closing"===this.status?r(new C("Stream aborted")):t()};e.signal?.addEventListener("abort",n);try{await new Promise(((e,n)=>{this.sendWindowCapacityUpdate=()=>{e()},r=n,t=e}))}finally{e.signal?.removeEventListener("abort",n)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,0===t&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new xh("Receive window exceeded");const r=await t();this.recvWindowCapacity-=e.length,this.sourcePush(r)}processFlags(e){(e&Nh.ACK)===Nh.ACK&&this.state===zh.SYNSent&&(this.state=zh.Established),(e&Nh.FIN)===Nh.FIN&&this.remoteCloseWrite(),(e&Nh.RST)===Nh.RST&&this.reset()}getSendFlags(){switch(this.state){case zh.Init:return this.state=zh.SYNSent,Nh.SYN;case zh.SYNReceived:return this.state=zh.Established,Nh.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),r=this.getRTT();if(0===e&&r>-1&&t-this.epochStart<4*r&&(this.recvWindow=Math.min(2*this.recvWindow,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&0===e)return;const n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:Dh.WindowUpdate,flag:e,streamID:this._id,length:n})}}const jh="/yamux/1.0.0";class Wh{protocol=jh;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[I]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new Kh(this._components,{...this._init,...e})}}class Kh{protocol=jh;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client="outbound"===t.direction,this.config={...Ph,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),function(e){if(e.keepAliveInterval<=0)throw new M("keep-alive interval must be positive");if(e.maxInboundStreams<0)throw new M("max inbound streams must be larger or equal 0");if(e.maxOutboundStreams<0)throw new M("max outbound streams must be larger or equal 0");if(e.initialStreamWindowSize<Mh)throw new M("InitialStreamWindowSize must be larger or equal 256 kB");if(e.maxStreamWindowSize<e.initialStreamWindowSize)throw new M("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(e.maxStreamWindowSize>2**32-1)throw new M("MaxStreamWindowSize must be less than equal MAX_UINT32");if(e.maxMessageSize<1024)throw new M("MaxMessageSize must be greater than a kilobyte")}(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=kc({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach((e=>{e.destroy()}))}}),this.sink=async e=>{const t=()=>{const t=vh(e);if(null!=t.return){const e=t.return();null!=(r=e)&&"function"==typeof r.then&&e.catch((e=>{this.log?.("could not cause sink source to return",e)}))}var r};let r,n;try{const n=new Lh(e);try{this.closeController.signal.addEventListener("abort",t);for await(const e of n.emitFrames())await this.handleFrame(e.header,e.readData)}finally{this.closeController.signal.removeEventListener("abort",t)}r=Rh.NormalTermination}catch(e){Th.has(e.name)?(this.log?.error("protocol error in sink",e),r=Rh.ProtocolError):(this.log?.error("internal error in sink",e),r=Rh.InternalError),n=e}this.log?.trace("muxer sink ended"),null!=n?this.abort(n,r):await this.close({reason:r})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch((e=>this.log?.error("keepalive error: %s",e))),this.ping().catch((e=>this.log?.error("ping error: %s",e)))}get streams(){return Array.from(this._streams.values())}newStream(e){if(void 0!==this.remoteGoAway)throw new L("Muxer closed remotely");if(void 0!==this.localGoAway)throw new L("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new Z("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const r=this._newStream(t,e,zh.Init,"outbound");return this._streams.set(t,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(void 0!==this.remoteGoAway)throw new L("Muxer closed remotely");if(void 0!==this.localGoAway)throw new L("Muxer closed locally");if(void 0===this.activePing){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise(((t,r)=>{const n=()=>{r(new L("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",n,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",n),t()}})),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const r=Date.now();this.rtt=r-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??Rh.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),null==e.signal){const t=AbortSignal.timeout(500);e={...e,signal:t}}try{await Promise.all([...this._streams.values()].map((async t=>t.close(e)))),this.sendGoAway(t),this._closeMuxer()}catch(e){this.abort(e)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??Rh.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const t of this._streams.values())t.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,r,n){if(null!=this._streams.get(e))throw new M("Stream already exists with that id");const s=new qh({id:e.toString(),name:t,state:r,direction:n,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(s)},log:this.logger.forComponent(`libp2p:yamux:${n}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return s}closeStream(e){this.client===(e%2==0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise(((e,t)=>{this.closeController.signal.addEventListener("abort",t,{once:!0})}));for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise((e=>{t=setTimeout(e,this.config.keepAliveInterval)}))]),this.ping().catch((e=>this.log?.error("ping error: %s",e)))}catch(e){return void clearInterval(t)}}}async handleFrame(e,t){const{streamID:r,type:n,length:s}=e;if(this.log?.trace("received frame %o",e),0===r)switch(n){case Dh.Ping:return void this.handlePing(e);case Dh.GoAway:return void this.handleGoAway(s);default:throw new Sh("Invalid frame type")}else switch(e.type){case Dh.Data:case Dh.WindowUpdate:return void await this.handleStreamMessage(e,t);default:throw new Sh("Invalid frame type")}}handlePing(e){if(e.flag===Nh.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,Nh.ACK);else{if(e.flag!==Nh.ACK)throw new Sh("Invalid frame flag");this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length)}}handlePingResponse(e){if(void 0===this.activePing)throw new Eh("ping not requested");if(this.activePing.id!==e)throw new kh("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",Rh[e]??"unknown"),this.remoteGoAway=e;for(const e of this._streams.values())e.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:r,flag:n,type:s}=e;(n&Nh.SYN)===Nh.SYN&&this.incomingStream(r);const i=this._streams.get(r);if(void 0!==i)switch(s){case Dh.WindowUpdate:return void i.handleWindowUpdate(e);case Dh.Data:if(void 0===t)throw new Error("unreachable");return void await i.handleData(e,t);default:throw new Error("unreachable")}else if(s===Dh.Data){if(this.log?.("discarding data for stream id=%s",r),void 0===t)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",r)}incomingStream(e){if(this.client!==(e%2==0))throw new M("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),void 0!==this.localGoAway)return void this.sendFrame({type:Dh.WindowUpdate,flag:Nh.RST,streamID:e,length:0});if(this.numInboundStreams>=this.config.maxInboundStreams)return this.log?.("maxIncomingStreams exceeded, forcing stream reset"),void this.sendFrame({type:Dh.WindowUpdate,flag:Nh.RST,streamID:e,length:0});const t=this._newStream(e,void 0,zh.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===Dh.Data){if(void 0===t)throw new Sh("Invalid frame");this.source.push(new cc(Oh(e),t))}else this.source.push(Oh(e))}sendPing(e,t=Nh.SYN){t===Nh.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:Dh.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=Rh.NormalTermination){this.log?.("sending GoAway reason=%s",Rh[e]),this.localGoAway=e,this.sendFrame({type:Dh.GoAway,flag:0,streamID:0,length:e})}}function Gh(e={}){return t=>new Wh(t,e)}function Yh(e,t){const r={[Symbol.iterator]:()=>r,next:()=>{const r=e.next(),n=r.value;return!0===r.done||null==n?{done:!0,value:void 0}:{done:!1,value:t(n)}}};return r}function Jh(e){return rc(He(ue.decode(`z${e}`)))}class Qh{set;constructor(e){if(this.set=new Set,null!=e)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Yh(this.set.entries(),(e=>{const t=Jh(e[0]);return[t,t]}))}forEach(e){this.set.forEach((t=>{const r=Jh(t);e(r,r,this)}))}has(e){return this.set.has(e.toString())}values(){return Yh(this.set.values(),(e=>Jh(e)))}intersection(e){const t=new Qh;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new Qh;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new Qh;for(const r of e)t.add(r);for(const e of this)t.add(e);return t}}class Zh{fp;h;seed;constructor(e,t,r,n=2){if(n>64)throw new TypeError("Invalid Fingerprint Size");const s=t.hashV(e,r),i=Xr(n);for(let e=0;e<i.length;e++)i[e]=s[e];0===i.length&&(i[0]=7),this.fp=i,this.h=t,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array&&et(this.fp,e.fp)}}function Xh(e,t){return Math.floor(Math.random()*(t-e))+e}class ed{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Zh))throw new TypeError("Invalid Fingerprint");return this.contents.some((t=>e.equals(t)))}add(e){if(!(e instanceof Zh))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(null==this.contents[t])return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Zh))throw new TypeError("Invalid Fingerprint");const t=Xh(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof Zh))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex((t=>e.equals(t)));return t>-1&&(this.contents[t]=null,!0)}}const td={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},rd={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},nd=new globalThis.TextEncoder;r(8437);const sd={hash:e=>Number(function(e,{size:t=32,utf8Buffer:r}={}){if(!td[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if("string"==typeof e){if(r)return function(e,t,r){if(0===r.length)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=td[t];let s=rd[t],i=e;for(;i.length>0;){const e=nd.encodeInto(i,r);i=i.slice(e.read);for(let i=0;i<e.written;i++)s^=BigInt(r[i]),s=BigInt.asUintN(t,s*n)}return s}(e,t,r);e=nd.encode(e)}return function(e,t){const r=td[t];let n=rd[t];for(let s=0;s<e.length;s++)n^=BigInt(e[s]),n=BigInt.asUintN(t,n*r);return n}(e,t)}(e,{size:32})),hashV:(e,t)=>function(e){let t=e.toString(16);return t.length%2==1&&(t=`0${t}`),ds(t,"base16")}(sd.hash(e,t))};class id{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??sd,this.seed=e.seed??Xh(0,Math.pow(2,10))}add(e){"string"==typeof e&&(e=ds(e));const t=new Zh(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=(r^t.hash())%this.filterSize;if(null==this.buckets[r]&&(this.buckets[r]=new ed(this.bucketSize)),null==this.buckets[n]&&(this.buckets[n]=new ed(this.bucketSize)),this.buckets[r].add(t)||this.buckets[n].add(t))return this.count++,!0;const s=[r,n];let i=s[Xh(0,s.length-1)];null==this.buckets[i]&&(this.buckets[i]=new ed(this.bucketSize));for(let e=0;e<500;e++){const e=this.buckets[i].swap(t);if(null!=e&&(i=(i^e.hash())%this.filterSize,null==this.buckets[i]&&(this.buckets[i]=new ed(this.bucketSize)),this.buckets[i].add(e)))return this.count++,!0}return!1}has(e){"string"==typeof e&&(e=ds(e));const t=new Zh(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=this.buckets[r]?.has(t)??!1;if(n)return n;const s=(r^t.hash())%this.filterSize;return this.buckets[s]?.has(t)??!1}remove(e){"string"==typeof e&&(e=ds(e));const t=new Zh(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=this.buckets[r]?.remove(t)??!1;if(n)return this.count--,n;const s=(r^t.hash())%this.filterSize,i=this.buckets[s]?.remove(t)??!1;return i&&this.count--,i}get reliable(){return Math.floor(this.count/this.filterSize*100)<=90}}const od={1:.5,2:.84,4:.95,8:.98};function ad(e,t=.001){const r=function(e=.001){return e>.002?2:e>1e-5?4:8}(t),n=od[r];return{filterSize:Math.round(e/n),bucketSize:r,fingerprintSize:Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*r)),64)}}class cd{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??sd,this.seed=e.seed??Xh(0,Math.pow(2,10)),this.filterSeries=[new id({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if("string"==typeof e&&(e=ds(e)),this.has(e))return!0;let t=this.filterSeries.find((e=>e.reliable));if(null==t){const e=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new id({filterSize:e,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){"string"==typeof e&&(e=ds(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){"string"==typeof e&&(e=ds(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce(((e,t)=>e+t.count),0)}}function ld(e,t=.001,r){return new cd({...ad(e,t),...r??{}})}function ud(e){try{const[[r,n]]=e.stringTuples();if(null==n)return!1;if(41===r)return t=n,new Tl("2000::/3").contains(t)}catch{}var t;return!1}var hd=r(5507);const dd=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map((e=>new hd.Netmask(e)));function pd(e){for(const t of dd)if(t.contains(e))return!0;return!1}function fd(e){return Ml(e)?pd(e):/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(e)?function(e){const t=e.split(":");if(t.length<2)return!1;const r=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0");return pd(`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}`)}(e):/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)?function(e){const t=e.split(":");return pd(t[t.length-1])}(e):Pl(e)?function(e){return/^::$/.test(e)||/^::1$/.test(e)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(e)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(e)||/^ff([0-9a-fA-F]{2,2}):/i.test(e)}(e):void 0}function gd(e){try{const[[t,r]]=e.stringTuples();if(null==r)return!0;if(53===t||54===t||55===t||56===t)return!1;if(4===t||41===t)return fd(r)??!1}catch{}return!0}class md extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}}async function yd(e,t,r,n){const s=new md(n?.errorMessage,n?.errorCode);return!0===r?.aborted?Promise.reject(s):new Promise(((i,o)=>{function a(){r?.removeEventListener("abort",u),e.removeEventListener(t,c),null!=n?.errorEvent&&e.removeEventListener(n.errorEvent,l)}const c=e=>{try{if(!1===n?.filter?.(e))return}catch(e){return a(),void o(e)}a(),i(e)},l=e=>{a(),o(e.detail)},u=()=>{a(),o(s)};r?.addEventListener("abort",u),e.addEventListener(t,c),null!=n?.errorEvent&&e.addEventListener(n.errorEvent,l)}))}class wd extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}class bd extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class vd{deferred;signal;constructor(e){this.signal=e,this.deferred=bc(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new C)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}class Sd{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=`${parseInt(String(1e9*Math.random()),10).toString()}${Date.now()}`,this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce(((e,t)=>e&&!0===t.signal?.aborted),!0)&&(this.controller.abort(new C),this.cleanup())}async join(e={}){const t=new vd(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await nu(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach((t=>{t.deferred.resolve(e)})),this.status="complete"}catch(e){this.recipients.forEach((t=>{t.deferred.reject(e)})),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach((e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)}))}}class Ed extends b{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,null!=e.metricName&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[]}tryToStartAnother(){if(0===this.size)return queueMicrotask((()=>{this.safeDispatchEvent("empty")})),0===this.running&&queueMicrotask((()=>{this.safeDispatchEvent("idle")})),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if("queued"===t.status){e=t;break}return null!=e&&(this.safeDispatchEvent("active"),this.pending++,e.run().finally((()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")})),!0)}return!1}enqueue(e){this.queue.push(e),null!=this.sort&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new bd;const r=new Sd(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.tryToStartAnother(),r.join(t).then((e=>(this.safeDispatchEvent("completed",{detail:e}),this.safeDispatchEvent("success",{detail:{job:r,result:e}}),e))).catch((e=>{if("queued"===r.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===r){this.queue.splice(e,1);break}throw this.safeDispatchEvent("error",{detail:e}),this.safeDispatchEvent("failure",{detail:{job:r,error:e}}),e}))}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach((e=>{e.abort(new C)})),this.clear()}async onEmpty(e){0!==this.size&&await yd(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await yd(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){0===this.pending&&0===this.size||await yd(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=kc({objectMode:!0}),r=e=>{null!=e?this.abort():this.clear(),t.end(e)},n=e=>{null!=e.detail&&t.push(e.detail)},s=e=>{r(e.detail)},i=()=>{r()},o=()=>{r(new C("Queue aborted"))};this.addEventListener("completed",n),this.addEventListener("error",s),this.addEventListener("idle",i),e?.signal?.addEventListener("abort",o);try{yield*t}finally{this.removeEventListener("completed",n),this.removeEventListener("error",s),this.removeEventListener("idle",i),e?.signal?.removeEventListener("abort",o),r()}}}class kd extends Ed{has(e){return null!=this.find(e)}find(e){return this.queue.find((t=>e.equals(t.options.peerId)))}}function Ad(e){const t=new globalThis.AbortController;function r(){t.abort();for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",r)}for(const t of e){if(!0===t?.aborted){r();break}null!=t?.addEventListener&&t.addEventListener("abort",r)}const n=t.signal;return n.clear=function(){for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",r)},n}function Id(e){const t=[],r=[];let n=null,s=0;for(;s<e.length;){const i=gn(e,s),o=hn(i),a=Fl(i),c=xd(a,e.slice(s+o));if(0===c){t.push([i]),r.push([i]),s+=o;continue}const l=e.slice(s+o,s+o+c);if(s+=c+o,s>e.length)throw Md("Invalid address Uint8Array: "+ia(e,"base16"));t.push([i,l]);const u=zl(i,l);if(r.push([i,u]),!0===a.path){n=u;break}}return{bytes:Uint8Array.from(e),string:_d(r),tuples:t,stringTuples:r,path:n}}function _d(e){const t=[];return e.map((e=>{const r=Fl(e[0]);return t.push(r.name),e.length>1&&null!=e[1]&&t.push(e[1]),null})),Td(t.join("/"))}function Cd(e){return sc(e.map((e=>{const t=Fl(e[0]);let r=Uint8Array.from(fn(t.code));return e.length>1&&null!=e[1]&&(r=sc([r,e[1]])),r})))}function xd(e,t){if(e.size>0)return e.size/8;if(0===e.size)return 0;{const e=gn(t instanceof Uint8Array?t:Uint8Array.from(t));return e+hn(e)}}function Td(e){return"/"+e.trim().split("/").filter((e=>e)).join("/")}function Md(e){return new Error("Error parsing address: "+e)}const Pd=Symbol.for("nodejs.util.inspect.custom"),Dd=Symbol.for("@multiformats/js-multiaddr/multiaddr"),Nd=[Fl("dns").code,Fl("dns4").code,Fl("dns6").code,Fl("dnsaddr").code];class Rd extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}class Bd{bytes;#t;#r;#n;#s;[Dd]=!0;constructor(e){let t;if(null==e&&(e=""),e instanceof Uint8Array)t=Id(e);else if("string"==typeof e){if(e.length>0&&"/"!==e.charAt(0))throw new Error(`multiaddr "${e}" must start with a "/"`);t=function(e){const t=[],r=[];let n=null;const s=(e=Td(e)).split("/").slice(1);if(1===s.length&&""===s[0])return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){const o=Fl(s[i]);if(0===o.size){t.push([o.code]),r.push([o.code]);continue}if(i++,i>=s.length)throw Md("invalid address: "+e);if(!0===o.path){n=Td(s.slice(i).join("/")),t.push([o.code,ql(o.code,n)]),r.push([o.code,n]);break}const a=ql(o.code,s[i]);t.push([o.code,a]),r.push([o.code,zl(o.code,a)])}return{string:_d(r),bytes:Cd(t),tuples:t,stringTuples:r,path:n}}(e)}else{if(!Od(e))throw new Error("addr must be a string, Buffer, or another Multiaddr");t=Id(e.bytes)}this.bytes=t.bytes,this.#t=t.string,this.#r=t.tuples,this.#n=t.stringTuples,this.#s=t.path}toString(){return this.#t}toJSON(){return this.toString()}toOptions(){let e,t,r,n,s="";const i=Fl("tcp"),o=Fl("udp"),a=Fl("ip4"),c=Fl("ip6"),l=Fl("dns6"),u=Fl("ip6zone");for(const[h,d]of this.stringTuples())h===u.code&&(s=`%${d??""}`),Nd.includes(h)&&(t=i.name,n=443,r=`${d??""}${s}`,e=h===l.code?6:4),h!==i.code&&h!==o.code||(t=Fl(h).name,n=parseInt(d??"")),h!==a.code&&h!==c.code||(t=Fl(h).name,r=`${d??""}${s}`,e=h===c.code?6:4);if(null==e||null==t||null==r||null==n)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:n}}protos(){return this.#r.map((([e])=>Object.assign({},Fl(e))))}protoCodes(){return this.#r.map((([e])=>e))}protoNames(){return this.#r.map((([e])=>Fl(e).name))}tuples(){return this.#r.map((([e,t])=>null==t?[e]:[e,t]))}stringTuples(){return this.#n.map((([e,t])=>null==t?[e]:[e,t]))}encapsulate(e){return e=new Bd(e),new Bd(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),r=this.toString(),n=r.lastIndexOf(t);if(n<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new Bd(r.slice(0,n))}decapsulateCode(e){const t=this.tuples();for(let r=t.length-1;r>=0;r--)if(t[r][0]===e)return new Bd(Cd(t.slice(0,r)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach((([t,r])=>{t===Ol.p2p.code&&e.push([t,r]),t===Ol["p2p-circuit"].code&&(e=[])}));const t=e.pop();if(null!=t?.[1]){const e=t[1];return"Q"===e[0]||"1"===e[0]?ia(ue.decode(`z${e}`),"base58btc"):ia(Ke.parse(e).multihash.bytes,"base58btc")}return null}catch(e){return null}}getPath(){return this.#s}equals(e){return et(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find((e=>e.resolvable));if(null==t)return[this];const r=Ld.get(t.name);if(null==r)throw new Rd(`no available resolver for ${t.name}`);return(await r(this,e)).map((e=>Ud(e)))}nodeAddress(){const e=this.toOptions();if("tcp"!==e.transport&&"udp"!==e.transport)throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(2!==t.length||4!==t[0].code&&41!==t[0].code||6!==t[1].code&&273!==t[1].code)}[Pd](){return`Multiaddr(${this.#t})`}}const Ld=new Map;function Od(e){return Boolean(e?.[Dd])}function Ud(e){return new Bd(e)}function Fd(e,t){const r=du(e,t),n={read:async(e,t)=>{const n=await r.read(t);return e.decode(n)},write:async(e,t,n)=>{await r.write(t.encode(e),n)},writeV:async(e,t,n)=>{await r.writeV(e.map((e=>t.encode(e))),n)},pb:e=>({read:async t=>n.read(e,t),write:async(t,r)=>n.write(t,e,r),writeV:async(t,r)=>n.writeV(t,e,r),unwrap:()=>n}),unwrap:()=>r.unwrap()};return n}var Vd;!function(e){let t,r,n,s,i,o,a,c;!function(e){e.DIAL="DIAL",e.DIAL_RESPONSE="DIAL_RESPONSE"}(t=e.MessageType||(e.MessageType={})),function(e){e[e.DIAL=0]="DIAL",e[e.DIAL_RESPONSE=1]="DIAL_RESPONSE"}(r||(r={})),function(e){e.codec=()=>Ns(r)}(t=e.MessageType||(e.MessageType={})),function(e){e.OK="OK",e.E_DIAL_ERROR="E_DIAL_ERROR",e.E_DIAL_REFUSED="E_DIAL_REFUSED",e.E_BAD_REQUEST="E_BAD_REQUEST",e.E_INTERNAL_ERROR="E_INTERNAL_ERROR"}(n=e.ResponseStatus||(e.ResponseStatus={})),function(e){e[e.OK=0]="OK",e[e.E_DIAL_ERROR=100]="E_DIAL_ERROR",e[e.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",e[e.E_BAD_REQUEST=200]="E_BAD_REQUEST",e[e.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"}(s||(s={})),function(e){e.codec=()=>Ns(s)}(n=e.ResponseStatus||(e.ResponseStatus={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.id&&(t.uint32(10),t.bytes(e.id)),null!=e.addrs)for(const r of e.addrs)t.uint32(18),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={addrs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.id=e.bytes();break;case 2:if(null!=r.limits?.addrs&&n.addrs.length===r.limits.addrs)throw new Bs('Decode error - map field "addrs" had too many elements');n.addrs.push(e.bytes());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(i=e.PeerInfo||(e.PeerInfo={})),function(t){let r;t.codec=()=>(null==r&&(r=Rs(((t,r,n={})=>{!1!==n.lengthDelimited&&r.fork(),null!=t.peer&&(r.uint32(10),e.PeerInfo.codec().encode(t.peer,r)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();r>>>3==1?s.peer=e.PeerInfo.codec().decode(t,t.uint32(),{limits:n.limits?.peer}):t.skipType(7&r)}return s}))),r),t.encode=e=>_s(e,t.codec()),t.decode=(e,r)=>Pn(e,t.codec(),r)}(o=e.Dial||(e.Dial={})),function(t){let r;t.codec=()=>(null==r&&(r=Rs(((t,r,n={})=>{!1!==n.lengthDelimited&&r.fork(),null!=t.status&&(r.uint32(8),e.ResponseStatus.codec().encode(t.status,r)),null!=t.statusText&&(r.uint32(18),r.string(t.statusText)),null!=t.addr&&(r.uint32(26),r.bytes(t.addr)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.status=e.ResponseStatus.codec().decode(t);break;case 2:s.statusText=t.string();break;case 3:s.addr=t.bytes();break;default:t.skipType(7&r)}}return s}))),r),t.encode=e=>_s(e,t.codec()),t.decode=(e,r)=>Pn(e,t.codec(),r)}(a=e.DialResponse||(e.DialResponse={})),e.codec=()=>(null==c&&(c=Rs(((t,r,n={})=>{!1!==n.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.MessageType.codec().encode(t.type,r)),null!=t.dial&&(r.uint32(18),e.Dial.codec().encode(t.dial,r)),null!=t.dialResponse&&(r.uint32(26),e.DialResponse.codec().encode(t.dialResponse,r)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.type=e.MessageType.codec().decode(t);break;case 2:s.dial=e.Dial.codec().decode(t,t.uint32(),{limits:n.limits?.dial});break;case 3:s.dialResponse=e.DialResponse.codec().decode(t,t.uint32(),{limits:n.limits?.dialResponse});break;default:t.skipType(7&r)}}return s}))),c),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Vd||(Vd={}));class $d{components;protocol;timeout;maxInboundStreams;maxOutboundStreams;maxMessageSize;started;log;topologyId;dialResults;findPeers;addressFilter;connectionThreshold;constructor(e,t){this.components=e,this.log=e.logger.forComponent("libp2p:auto-nat"),this.started=!1,this.protocol=`/${t.protocolPrefix??"libp2p"}/autonat/1.0.0`,this.timeout=t.timeout??3e4,this.maxInboundStreams=t.maxInboundStreams??2,this.maxOutboundStreams=t.maxOutboundStreams??20,this.connectionThreshold=t.connectionThreshold??80,this.maxMessageSize=t.maxMessageSize??8192,this.dialResults=new Map,this.findPeers=function(e){let t,r;function n(){const s={signal:r.signal};Promise.resolve().then((async()=>{await e(s)})).catch((()=>{})).finally((()=>{r.signal.aborted||(t=setTimeout(n,6e4))}))}let s=!1;return{start:()=>{s||(s=!0,r=new AbortController,r.signal,t=setTimeout(n,6e4))},stop:()=>{clearTimeout(t),r?.abort(),s=!1}}}(this.findRandomPeers.bind(this)),this.addressFilter=ld(1024)}[Symbol.toStringTag]="@libp2p/autonat";[I]=["@libp2p/autonat"];get[_](){return["@libp2p/identify"]}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,(e=>{this.handleIncomingAutonatStream(e).catch((e=>{this.log.error("error handling incoming autonat stream - %e",e)}))}),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.topologyId=await this.components.registrar.register(this.protocol,{onConnect:(e,t)=>{this.verifyExternalAddresses(t).catch((e=>{this.log.error("could not verify addresses - %e",e)}))}}),this.findPeers.start(),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),null!=this.topologyId&&await this.components.registrar.unhandle(this.topologyId),this.dialResults.clear(),this.findPeers.stop(),this.started=!1}allAddressesAreVerified(){return this.components.addressManager.getAddressesWithMetadata().every((e=>e.expires>Date.now()||e.verified))}async findRandomPeers(e){if(this.allAddressesAreVerified())return;const t=Ad([AbortSignal.timeout(1e4),e?.signal]);try{this.log("starting random walk to find peers to run AutoNAT");for await(const e of this.components.randomWalk.walk({signal:t}))if(await this.components.connectionManager.isDialable(e.multiaddrs)){try{this.log.trace("dial random peer %p",e.id),await this.components.connectionManager.openConnection(e.multiaddrs,{signal:t})}catch{}if(this.allAddressesAreVerified())return void this.log("stopping random walk, all addresses are verified");if(!this.hasConnectionCapacity())return void this.log("stopping random walk, too close to max connections")}else this.log.trace("random peer %p was not dialable %s",e.id,e.multiaddrs.map((e=>e.toString())).join(", "))}catch{}}async handleIncomingAutonatStream(e){const t=AbortSignal.timeout(this.timeout),r=Fd(e.stream,{maxDataLength:this.maxMessageSize}).pb(Vd);try{const n=await r.read({signal:t}),s=await this.handleAutonatMessage(n,e.connection,{signal:t});await r.write(s,{signal:t}),await r.unwrap().unwrap().close({signal:t})}catch(t){this.log.error("error handling incoming autonat stream - %e",t),e.stream.abort(t)}}async handleAutonatMessage(e,t,r){const n=this.components.addressManager.getAddresses().map((e=>e.toOptions().host)),s=e.dial;if(null==s)return this.log.error("dial was missing from message"),{type:Vd.MessageType.DIAL_RESPONSE,dialResponse:{status:Vd.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}};let i;const o=s.peer;if(null==o?.id)return this.log.error("PeerId missing from message"),{type:Vd.MessageType.DIAL_RESPONSE,dialResponse:{status:Vd.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}};try{const e=He(o.id);i=rc(e)}catch(e){return this.log.error("invalid PeerId - %e",e),{type:Vd.MessageType.DIAL_RESPONSE,dialResponse:{status:Vd.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}}}if(this.log("incoming request from %p",i),!t.remotePeer.equals(i))return this.log("target peer %p did not equal sending peer %p",i,t.remotePeer),{type:Vd.MessageType.DIAL_RESPONSE,dialResponse:{status:Vd.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}};const a=o.addrs.map((e=>Ud(e))).filter((e=>{const r=e.toOptions();return!(gd(e)||(r.host!==t.remoteAddr.toOptions().host?(this.log.trace("not dialing %a - target host did not match remote host %a",e,t.remoteAddr),1):n.includes(r.host)||null==this.components.transportManager.dialTransportForMultiaddr(e)&&(this.log.trace("not dialing %a - transport unsupported",e),1)))})).map((e=>(null==e.getPeerId()&&(e=e.encapsulate(`/p2p/${i.toString()}`)),e)));if(0===a.length)return this.log("refused to dial all multiaddrs for %p from message",i),{type:Vd.MessageType.DIAL_RESPONSE,dialResponse:{status:Vd.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}};this.log("dial multiaddrs %s for peer %p",a.map((e=>e.toString())).join(", "),i);let c="",l=a[0];for await(const e of a){let t;l=e;try{if(t=await this.components.connectionManager.openConnection(e,r),!t.remoteAddr.equals(e))throw this.log.error("tried to dial %a but dialed %a",e,t.remoteAddr),new Error("Unexpected remote address");return this.log("successfully dialed %p via %a",i,e),{type:Vd.MessageType.DIAL_RESPONSE,dialResponse:{status:Vd.ResponseStatus.OK,addr:t.remoteAddr.decapsulateCode(Fl("p2p").code).bytes}}}catch(e){this.log.error("could not dial %p - %e",i,e),c=e.message}finally{null!=t&&await t.close()}}return{type:Vd.MessageType.DIAL_RESPONSE,dialResponse:{status:Vd.ResponseStatus.E_DIAL_ERROR,statusText:c,addr:l.bytes}}}getFirstUnverifiedMultiaddr(e,t){const r=this.components.addressManager.getAddressesWithMetadata().sort(((e,t)=>"observed"===e.type&&"observed"!==t.type?1:"observed"===t.type&&"observed"!==e.type?-1:0)).filter((e=>{if(!(e.expires<Date.now()))return!1;if(6===e.multiaddr.toOptions().family){if(!t)return!1;if(!ud(e.multiaddr))return!1}return!gd(e.multiaddr)}));for(const t of r){const r=t.multiaddr.toString();let n=this.dialResults.get(r);if(null!=n){if(n.networkSegments.includes(e)){this.log.trace("%a already has a network segment result from %s",n.multiaddr,e);continue}if(n.queue.size>10){this.log.trace("%a already has enough peers queued",n.multiaddr);continue}}if(null==n){const e=t.expires<Date.now();if(e&&this.addressFilter.remove?.(r),this.addressFilter.has(r))continue;this.addressFilter.add(r),this.log.trace("creating dial result %s %s",e?"to revalidate":"for",r),n={multiaddr:t.multiaddr,success:0,failure:0,networkSegments:[],verifyingPeers:new Qh,queue:new kd({concurrency:3,maxSize:50}),type:t.type,lastVerified:t.lastVerified},this.dialResults.set(r,n)}return n}}removeOutdatedMultiaddrResults(){const e=new Set(this.components.addressManager.getAddressesWithMetadata().filter((({expires:e})=>e<Date.now())).map((({multiaddr:e})=>e.toString())));for(const t of this.dialResults.keys())e.has(t)||(this.log.trace("remove results for %a",t),this.dialResults.delete(t))}async verifyExternalAddresses(e){if(!this.isStarted())return;this.removeOutdatedMultiaddrResults();const t=(await this.components.peerStore.get(e.remotePeer)).addresses.some((({multiaddr:e})=>6===e.toOptions().family)),r=this.getNetworkSegment(e.remoteAddr),n=this.getFirstUnverifiedMultiaddr(r,t);null!=n?this.hasConnectionCapacity()?n.queue.add((async t=>{await this.askPeerToVerify(e,r,t)}),{peerId:e.remotePeer,multiaddr:n.multiaddr}).catch((t=>{null==n?.result&&this.log.error("error from %p verifying address %a - %e",e.remotePeer,n?.multiaddr,t)})):null!=n.lastVerified?(this.log("automatically re-verifying %a because we are too close to the connection limit",n.multiaddr),this.confirmAddress(n)):this.log("skipping verifying %a because we are too close to the connection limit",n.multiaddr):this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification",e.remotePeer)}async askPeerToVerify(e,t,r){let n=this.dialResults.get(r.multiaddr.toString());if(null==n)return void this.log("%a was verified while %p was queued",r.multiaddr,e.remotePeer);const s=AbortSignal.timeout(this.timeout);this.log.trace("asking %p to verify multiaddr %s",e.remotePeer,r.multiaddr);const i=await e.newStream(this.protocol,{signal:s});try{const o=Fd(i).pb(Vd),[,a]=await Promise.all([o.write({type:Vd.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toMultihash().bytes,addrs:[r.multiaddr.bytes]}}},{signal:s}),o.read({signal:s})]);if(a.type!==Vd.MessageType.DIAL_RESPONSE||null==a.dialResponse)return void this.log("invalid autonat response from %p - %j",e.remotePeer,a);const c=a.dialResponse.status;if(this.log.trace("autonat response from %p for %a is %s",e.remotePeer,r.multiaddr,c),c!==Vd.ResponseStatus.OK&&c!==Vd.ResponseStatus.E_DIAL_ERROR)return;if(n=this.dialResults.get(r.multiaddr.toString()),null==n)return void this.log.trace("peer reported %a as %s but there is no result object",r.multiaddr,a.dialResponse.status);if(n.networkSegments.includes(t))return void this.log.trace("%a results included network segment %s",r.multiaddr,t);if(null!=n.result)return void this.log.trace("already resolved result for %a, ignoring response from",r.multiaddr,e.remotePeer);if(n.verifyingPeers.has(e.remotePeer))return void this.log.trace("peer %p has already verified %a, ignoring response",e.remotePeer,r.multiaddr);if(n.verifyingPeers.add(e.remotePeer),n.networkSegments.push(t),c===Vd.ResponseStatus.OK){if(n.success++,"observed"!==n.type)return void this.confirmAddress(n)}else c===Vd.ResponseStatus.E_DIAL_ERROR&&n.failure++;this.log("%a success %d failure %d",n.multiaddr,n.success,n.failure),4===n.success&&this.confirmAddress(n),8===n.failure&&this.unconfirmAddress(n)}finally{try{await i.close({signal:s})}catch(e){i.abort(e)}}}hasConnectionCapacity(){return this.components.connectionManager.getConnections().length/this.components.connectionManager.getMaxConnections()*100<this.connectionThreshold}confirmAddress(e){this.log("%s address %a is externally dialable",e.type,e.multiaddr),this.components.addressManager.confirmObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!0,e.queue.abort()}unconfirmAddress(e){this.log("%s address %a is not externally dialable",e.type,e.multiaddr),this.components.addressManager.removeObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!1,e.queue.abort()}getNetworkSegment(e){const t=e.toOptions();return 4===t.family?t.host.split(".")[0].padStart(3,"0"):t.host.split(":")[0].padStart(4,"0")}}function Hd(e={}){return t=>new $d(t,e)}const zd=Symbol.for("@libp2p/peer-discovery"),qd=Sp("dns4"),jd=Sp("dns6"),Wd=Sp("dnsaddr"),Kd=vp(Sp("dns"),Wd,qd,jd),Gd=vp(Sp("ip4"),Sp("ip6")),Yd=vp(bp(Gd,Sp("tcp")),bp(Kd,Sp("tcp"))),Jd=bp(Gd,Sp("udp")),Qd=bp(Jd,Sp("utp")),Zd=bp(Jd,Sp("quic")),Xd=bp(Jd,Sp("quic-v1")),ep=vp(bp(Yd,Sp("ws")),bp(Kd,Sp("ws"))),tp=vp(bp(ep,Sp("p2p")),ep),rp=vp(bp(Yd,Sp("wss")),bp(Kd,Sp("wss")),bp(Yd,Sp("tls"),Sp("ws")),bp(Kd,Sp("tls"),Sp("ws"))),np=vp(bp(rp,Sp("p2p")),rp),sp=vp(bp(Yd,Sp("http")),bp(Gd,Sp("http")),bp(Kd,Sp("http"))),ip=vp(bp(Yd,Sp("https")),bp(Gd,Sp("https")),bp(Kd,Sp("https"))),op=bp(Jd,Sp("webrtc-direct"),Sp("certhash")),ap=vp(bp(op,Sp("p2p")),op),cp=bp(Xd,Sp("webtransport"),Sp("certhash"),Sp("certhash")),lp=vp(bp(cp,Sp("p2p")),cp),up=vp(bp(tp,Sp("p2p-webrtc-star"),Sp("p2p")),bp(np,Sp("p2p-webrtc-star"),Sp("p2p")),bp(tp,Sp("p2p-webrtc-star")),bp(np,Sp("p2p-webrtc-star"))),hp=(vp(bp(tp,Sp("p2p-websocket-star"),Sp("p2p")),bp(np,Sp("p2p-websocket-star"),Sp("p2p")),bp(tp,Sp("p2p-websocket-star")),bp(np,Sp("p2p-websocket-star"))),vp(bp(sp,Sp("p2p-webrtc-direct"),Sp("p2p")),bp(ip,Sp("p2p-webrtc-direct"),Sp("p2p")),bp(sp,Sp("p2p-webrtc-direct")),bp(ip,Sp("p2p-webrtc-direct")))),dp=vp(ep,rp,sp,ip,up,hp,Yd,Qd,Zd,Kd,ap,lp),pp=(vp(bp(dp,Sp("p2p-stardust"),Sp("p2p")),bp(dp,Sp("p2p-stardust"))),vp(bp(dp,Sp("p2p")),up,hp,ap,lp,Sp("p2p"))),fp=vp(bp(pp,Sp("p2p-circuit"),pp),bp(pp,Sp("p2p-circuit")),bp(Sp("p2p-circuit"),pp),bp(dp,Sp("p2p-circuit")),bp(Sp("p2p-circuit"),dp),Sp("p2p-circuit")),gp=()=>vp(bp(fp,gp),fp),mp=gp(),yp=vp(bp(mp,pp,mp),bp(pp,mp),bp(mp,pp),mp,pp);function wp(e){return function(t){let r;try{r=Ud(t)}catch(e){return!1}const n=e(r.protoNames());return null!==n&&(!0===n||!1===n?n:0===n.length)}}function bp(...e){function t(t){if(t.length<e.length)return null;let r=t;return e.some((e=>(r="function"==typeof e?e().partialMatch(t):e.partialMatch(t),Array.isArray(r)&&(t=r),null===r))),r}return{toString:function(){return"{ "+e.join(" ")+" }"},input:e,matches:wp(t),partialMatch:t}}function vp(...e){function t(t){let r=null;return e.some((e=>{const n="function"==typeof e?e().partialMatch(t):e.partialMatch(t);return null!=n&&(r=n,!0)})),r}return{toString:function(){return"{ "+e.join(" ")+" }"},input:e,matches:wp(t),partialMatch:t}}function Sp(e){const t=e;return{toString:function(){return t},matches:function(e){let r;try{r=Ud(e)}catch(e){return!1}const n=r.protoNames();return 1===n.length&&n[0]===t},partialMatch:function(e){return 0===e.length?null:e[0]===t?e.slice(1):null}}}vp(bp(mp,Sp("webrtc"),Sp("p2p")),bp(mp,Sp("webrtc")),bp(dp,Sp("webrtc"),Sp("p2p")),bp(dp,Sp("webrtc")),Sp("webrtc"));class Ep extends b{static tag="bootstrap";log;timer;list;timeout;components;_init;constructor(e,t={list:[]}){if(null==t.list||0===t.list.length)throw new Error("Bootstrap requires a list of peer addresses");super(),this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=t.timeout??1e3,this.list=[];for(const e of t.list){if(!yp.matches(e)){this.log.error("Invalid multiaddr");continue}const t=Ud(e),r=t.getPeerId();if(null==r){this.log.error("Invalid bootstrap multiaddr without peer id");continue}const n={id:ec(r),multiaddrs:[t]};this.list.push(n)}this._init=t}[zd]=this;[Symbol.toStringTag]="@libp2p/bootstrap";[I]=["@libp2p/peer-discovery"];isStarted(){return Boolean(this.timer)}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout((()=>{this._discoverBootstrapPeers().catch((e=>{this.log.error(e)}))}),this.timeout))}async _discoverBootstrapPeers(){if(null!=this.timer)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??"bootstrap"]:{value:this._init.tagValue??50,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),null==this.timer)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch((t=>{this.log.error("could not dial bootstrap peer %p",e.id,t)}))}}stop(){null!=this.timer&&clearTimeout(this.timer),this.timer=void 0}}var kp;!function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.publicKey&&e.publicKey.byteLength>0&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.payloadType&&e.payloadType.byteLength>0&&(t.uint32(18),t.bytes(e.payloadType)),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(26),t.bytes(e.payload)),null!=e.signature&&e.signature.byteLength>0&&(t.uint32(42),t.bytes(e.signature)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={publicKey:Xr(0),payloadType:Xr(0),payload:Xr(0),signature:Xr(0)},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.publicKey=e.bytes();break;case 2:n.payloadType=e.bytes();break;case 3:n.payload=e.bytes();break;case 5:n.signature=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(kp||(kp={}));class Ap extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class Ip{static createFromProtobuf=async e=>{const t=kp.decode(e),r=qa(t.publicKey);return new Ip({publicKey:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(null==t)throw new Error("Missing private key");const r=e.domain,n=e.codec,s=e.marshal(),i=_p(r,n,s),o=await t.sign(i.subarray());return new Ip({publicKey:t.publicKey,payloadType:n,payload:s,signature:o})};static openAndCertify=async(e,t)=>{const r=await Ip.createFromProtobuf(e);if(!await r.validate(t))throw new Ap("Envelope signature is not valid for the given domain");return r};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:r,payload:n,signature:s}=e;this.publicKey=t,this.payloadType=r,this.payload=n,this.signature=s}marshal(){return null==this.marshaled&&(this.marshaled=kp.encode({publicKey:ja(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return et(this.marshal(),e.marshal())}async validate(e){const t=_p(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}}const _p=(e,t,r)=>{const n=ds(e),s=fn(n.byteLength),i=fn(t.length),o=fn(r.length);return new cc(s,n,i,t,o,r)},Cp="keep-alive",xp="circuit-relay-source",Tp=`${Cp}-circuit-relay`,Mp=`${Cp}-circuit-relay-source`,Pp=BigInt(1<<17),Dp="/libp2p/circuit/relay/0.2.0/hop",Np="/libp2p/circuit/relay/0.2.0/stop";var Rp,Bp,Lp,Op,Up,Fp,Vp,$p,Hp;!function(e){let t,r,n;!function(e){e.RESERVE="RESERVE",e.CONNECT="CONNECT",e.STATUS="STATUS"}(t=e.Type||(e.Type={})),function(e){e[e.RESERVE=0]="RESERVE",e[e.CONNECT=1]="CONNECT",e[e.STATUS=2]="STATUS"}(r||(r={})),function(e){e.codec=()=>Ns(r)}(t=e.Type||(e.Type={})),e.codec=()=>(null==n&&(n=Rs(((t,r,n={})=>{!1!==n.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.Type.codec().encode(t.type,r)),null!=t.peer&&(r.uint32(18),Lp.codec().encode(t.peer,r)),null!=t.reservation&&(r.uint32(26),Op.codec().encode(t.reservation,r)),null!=t.limit&&(r.uint32(34),Up.codec().encode(t.limit,r)),null!=t.status&&(r.uint32(40),Fp.codec().encode(t.status,r)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.type=e.Type.codec().decode(t);break;case 2:s.peer=Lp.codec().decode(t,t.uint32(),{limits:n.limits?.peer});break;case 3:s.reservation=Op.codec().decode(t,t.uint32(),{limits:n.limits?.reservation});break;case 4:s.limit=Up.codec().decode(t,t.uint32(),{limits:n.limits?.limit});break;case 5:s.status=Fp.codec().decode(t);break;default:t.skipType(7&r)}}return s}))),n),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Rp||(Rp={})),function(e){let t,r,n;!function(e){e.CONNECT="CONNECT",e.STATUS="STATUS"}(t=e.Type||(e.Type={})),function(e){e[e.CONNECT=0]="CONNECT",e[e.STATUS=1]="STATUS"}(r||(r={})),function(e){e.codec=()=>Ns(r)}(t=e.Type||(e.Type={})),e.codec=()=>(null==n&&(n=Rs(((t,r,n={})=>{!1!==n.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.Type.codec().encode(t.type,r)),null!=t.peer&&(r.uint32(18),Lp.codec().encode(t.peer,r)),null!=t.limit&&(r.uint32(26),Up.codec().encode(t.limit,r)),null!=t.status&&(r.uint32(32),Fp.codec().encode(t.status,r)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.type=e.Type.codec().decode(t);break;case 2:s.peer=Lp.codec().decode(t,t.uint32(),{limits:n.limits?.peer});break;case 3:s.limit=Up.codec().decode(t,t.uint32(),{limits:n.limits?.limit});break;case 4:s.status=Fp.codec().decode(t);break;default:t.skipType(7&r)}}return s}))),n),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Bp||(Bp={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.id&&e.id.byteLength>0&&(t.uint32(10),t.bytes(e.id)),null!=e.addrs)for(const r of e.addrs)t.uint32(18),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={id:Xr(0),addrs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.id=e.bytes();break;case 2:if(null!=r.limits?.addrs&&n.addrs.length===r.limits.addrs)throw new Bs('Decode error - map field "addrs" had too many elements');n.addrs.push(e.bytes());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Lp||(Lp={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.expire&&0n!==e.expire&&(t.uint32(8),t.uint64(e.expire)),null!=e.addrs)for(const r of e.addrs)t.uint32(18),t.bytes(r);null!=e.voucher&&(t.uint32(26),Hp.codec().encode(e.voucher,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={expire:0n,addrs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.expire=e.uint64();break;case 2:if(null!=r.limits?.addrs&&n.addrs.length===r.limits.addrs)throw new Bs('Decode error - map field "addrs" had too many elements');n.addrs.push(e.bytes());break;case 3:n.voucher=Hp.codec().decode(e,e.uint32(),{limits:r.limits?.voucher});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Op||(Op={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.duration&&(t.uint32(8),t.uint32(e.duration)),null!=e.data&&(t.uint32(16),t.uint64(e.data)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.duration=e.uint32();break;case 2:n.data=e.uint64();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Up||(Up={})),function(e){e.UNUSED="UNUSED",e.OK="OK",e.RESERVATION_REFUSED="RESERVATION_REFUSED",e.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",e.PERMISSION_DENIED="PERMISSION_DENIED",e.CONNECTION_FAILED="CONNECTION_FAILED",e.NO_RESERVATION="NO_RESERVATION",e.MALFORMED_MESSAGE="MALFORMED_MESSAGE",e.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"}(Fp||(Fp={})),function(e){e[e.UNUSED=0]="UNUSED",e[e.OK=100]="OK",e[e.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",e[e.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",e[e.PERMISSION_DENIED=202]="PERMISSION_DENIED",e[e.CONNECTION_FAILED=203]="CONNECTION_FAILED",e[e.NO_RESERVATION=204]="NO_RESERVATION",e[e.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",e[e.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"}(Vp||(Vp={})),function(e){e.codec=()=>Ns(Vp)}(Fp||(Fp={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.relay&&e.relay.byteLength>0&&(t.uint32(10),t.bytes(e.relay)),null!=e.peer&&e.peer.byteLength>0&&(t.uint32(18),t.bytes(e.peer)),null!=e.expiration&&0n!==e.expiration&&(t.uint32(24),t.uint64(e.expiration)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={relay:Xr(0),peer:Xr(0),expiration:0n},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.relay=e.bytes();break;case 2:n.peer=e.bytes();break;case 3:n.expiration=e.uint64();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}($p||($p={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.publicKey&&e.publicKey.byteLength>0&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.payloadType&&e.payloadType.byteLength>0&&(t.uint32(18),t.bytes(e.payloadType)),null!=e.payload&&(t.uint32(26),$p.codec().encode(e.payload,t)),null!=e.signature&&e.signature.byteLength>0&&(t.uint32(42),t.bytes(e.signature)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={publicKey:Xr(0),payloadType:Xr(0),signature:Xr(0)},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.publicKey=e.bytes();break;case 2:n.payloadType=e.bytes();break;case 3:n.payload=$p.codec().decode(e,e.uint32(),{limits:r.limits?.payload});break;case 5:n.signature=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Hp||(Hp={}));const zp=e=>({match:t=>!(t.length<1)&&!!e(t[0])&&t.slice(1),pattern:"fn"}),qp=e=>({match:t=>zp((t=>t===e)).match(t),pattern:e}),jp=()=>({match:e=>zp((e=>"string"==typeof e)).match(e),pattern:"{string}"}),Wp=()=>({match:e=>zp((e=>!isNaN(parseInt(e)))).match(e),pattern:"{number}"}),Kp=()=>({match:e=>{if(e.length<2)return!1;if("p2p"!==e[0]&&"ipfs"!==e[0])return!1;if(!e[1].startsWith("Q")&&!e[1].startsWith("1"))return!1;try{ue.decode(`z${e[1]}`)}catch(e){return!1}return e.slice(2)},pattern:"/p2p/{peerid}"}),Gp=()=>({match:e=>{if(e.length<2)return!1;if("certhash"!==e[0])return!1;try{Hn.decode(e[1])}catch{return!1}return e.slice(2)},pattern:"/certhash/{certhash}"}),Yp=e=>({match:t=>{const r=e.match(t);return!1===r?t:r},pattern:`optional(${e.pattern})`}),Jp=(...e)=>({match:t=>{let r;for(const n of e){const e=n.match(t);!1!==e&&(null==r||e.length<r.length)&&(r=e)}return null!=r&&r},pattern:`or(${e.map((e=>e.pattern)).join(", ")})`}),Qp=(...e)=>({match:t=>{for(const r of e){const e=r.match(t);if(!1===e)return!1;t=e}return t},pattern:`and(${e.map((e=>e.pattern)).join(", ")})`});function Zp(...e){function t(t){let r=(e=>e.toString().split("/").slice(1))(t);for(const t of e){const e=t.match(r);if(!1===e)return!1;r=e}return r}return{matchers:e,matches:function(e){return!1!==t(e)},exactMatch:function(e){const r=t(e);return!1!==r&&0===r.length}}}const Xp=Qp(qp("dns4"),jp()),ef=Qp(qp("dns6"),jp()),tf=Qp(qp("dnsaddr"),jp()),rf=Qp(qp("dns"),jp()),nf=(Zp(Xp,Yp(Kp())),Zp(ef,Yp(Kp())),Zp(tf,Yp(Kp())),Zp(Jp(rf,tf,Xp,ef),Yp(Kp()))),sf=Qp(qp("ip4"),zp(Ml)),of=Qp(qp("ip6"),zp(Pl)),af=Jp(sf,of),cf=Jp(af,rf,Xp,ef,tf),lf=Zp(Jp(af,Qp(Jp(rf,tf,Xp,ef),Yp(Kp())))),uf=(Zp(sf),Zp(of),Zp(af)),hf=Qp(cf,qp("tcp"),Wp()),df=Qp(cf,qp("udp"),Wp()),pf=Zp(Qp(hf,Yp(Kp()))),ff=(Zp(df),Qp(df,qp("quic"),Yp(Kp()))),gf=Qp(df,qp("quic-v1"),Yp(Kp())),mf=Jp(ff,gf),yf=(Zp(ff),Zp(gf),Jp(cf,hf,df,ff,gf)),wf=Jp(Qp(yf,qp("ws"),Yp(Kp()))),bf=Zp(wf),vf=Jp(Qp(yf,qp("wss"),Yp(Kp())),Qp(yf,qp("tls"),Yp(Qp(qp("sni"),jp())),qp("ws"),Yp(Kp()))),Sf=Zp(vf),Ef=Qp(df,qp("webrtc-direct"),Yp(Gp()),Yp(Gp()),Yp(Kp())),kf=Zp(Ef),Af=Qp(gf,qp("webtransport"),Yp(Gp()),Yp(Gp()),Yp(Kp())),If=Zp(Af),_f=Jp(wf,vf,Qp(hf,Yp(Kp())),Qp(mf,Yp(Kp())),Qp(cf,Yp(Kp())),Ef,Af,Kp()),Cf=Zp(_f),xf=Zp(Qp(_f,qp("p2p-circuit"),Kp())),Tf=Zp(Jp(Qp(_f,qp("p2p-circuit"),qp("webrtc"),Yp(Kp())),Qp(_f,qp("webrtc"),Yp(Kp())),Qp(qp("webrtc"),Yp(Kp()))));Zp(Jp(Qp(cf,qp("tcp"),Wp(),qp("http"),Yp(Kp())),Qp(cf,qp("http"),Yp(Kp())))),Zp(Jp(Qp(cf,qp("tcp"),Jp(Qp(qp("443"),qp("http")),Qp(Wp(),qp("https"))),Yp(Kp())),Qp(cf,qp("tls"),qp("http"),Yp(Kp())),Qp(cf,qp("https"),Yp(Kp())))),Zp(Jp(Qp(qp("memory"),jp(),Yp(Kp()))));class Mf extends Error{constructor(e="Transfer limit error"){super(e),this.name="TransferLimitError"}}class Pf extends Error{constructor(e="Duration limit error"){super(e),this.name="DurationLimitError"}}class Df extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class Nf extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class Rf extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}async function*Bf(e,t,r){const n=t.remaining;for await(const s of e){const e=BigInt(s.byteLength);if(t.remaining-e<0){const e=Number(t.remaining);t.remaining=0n;try{0!==e&&(yield s.subarray(0,e))}catch(e){r.log.error(e)}throw new Mf(`data limit of ${n} bytes exceeded`)}t.remaining-=e,yield s}}function Lf(e){const t=e*BigInt(1e3),r=(new Date).getTime();return Number(t-BigInt(r))}class Of{expires;bytes;constructor(e){null!=e?.duration&&0!==e?.duration&&(this.expires=Date.now()+1e3*e.duration),this.bytes=e?.data,0n===this.bytes&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){null!=this.bytes&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(null==this.expires&&null==this.bytes)return;const e={};if(null!=this.bytes){const t=this;Object.defineProperty(e,"bytes",{get:()=>t.bytes})}if(null!=this.expires){const t=this;Object.defineProperty(e,"seconds",{get:()=>Math.round(((t.expires??0)-Date.now())/1e3)})}return e}}const Uf=Zp(Qp(Cf.matchers[0],qp("p2p-circuit"))),Ff=Zp(qp("p2p-circuit"));class Vf{map;constructor(e){if(this.map=new Map,null!=e)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Yh(this.map.entries(),(e=>[e[1].key,e[1].value]))}forEach(e){this.map.forEach(((t,r)=>{e(t.value,t.key,this)}))}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Yh(this.map.values(),(e=>e.key))}values(){return Yh(this.map.values(),(e=>e.value))}get size(){return this.map.size}}class $f extends Vf{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}class Hf extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}}function zf(e,t){const r=new Hf(t?.errorMessage,t?.errorCode,t?.errorName),n=new AbortController,s=()=>{n.abort(r)};let i=AbortSignal.timeout(e);i.addEventListener("abort",s);const o=n.signal;return o.reset=t=>{i?.removeEventListener("abort",s),i=AbortSignal.timeout(t??e),i.addEventListener("abort",(()=>{n.abort(r)}))},o.clear=()=>{i?.removeEventListener("abort",s),i=void 0},o}class qf{reservations;maxReservations;applyDefaultLimit;reservationTtl;defaultDurationLimit;defaultDataLimit;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:server:reservation-store"),this.maxReservations=t.maxReservations??15,this.applyDefaultLimit=!1!==t.applyDefaultLimit,this.reservationTtl=t.reservationTtl??72e5,this.defaultDurationLimit=t.defaultDurationLimit??12e4,this.defaultDataLimit=t.defaultDataLimit??Pp,this.reservations=function(e){const{name:t,metrics:r}=e;let n;return n=null!=r?new $f({name:t,metrics:r}):new Vf,n}({metrics:e.metrics,name:"libp2p_circuit_relay_server_reservations_total"})}reserve(e,t,r){let n=this.reservations.get(e);if(this.reservations.size>=this.maxReservations&&null==n)return{status:Fp.RESERVATION_REFUSED};const s=new Date(Date.now()+this.reservationTtl);let i;return this.applyDefaultLimit&&(i=r??{data:this.defaultDataLimit,duration:this.defaultDurationLimit}),null!=n?(this.log("refreshing reservation for client %p",e),n.signal.reset(this.reservationTtl)):(this.log("creating new reservation for client %p",e),n={addr:t,expiry:s,limit:i,signal:zf(this.reservationTtl)}),this.reservations.set(e,n),n.signal.addEventListener("abort",(()=>{this.reservations.delete(e)})),{status:Fp.OK,expire:Math.round(s.getTime()/1e3)}}removeReservation(e){this.reservations.delete(e)}get(e){return this.reservations.get(e)}clear(){this.reservations.clear()}}class jf{domain="libp2p-relay-rsvp";codec=new Uint8Array([3,2]);relay;peer;expiration;constructor({relay:e,peer:t,expiration:r}){this.relay=e,this.peer=t,this.expiration=r}marshal(){return $p.encode({relay:this.relay.toMultihash().bytes,peer:this.peer.toMultihash().bytes,expiration:BigInt(this.expiration)})}equals(e){return e instanceof jf&&!!this.peer.equals(e.peer)&&!!this.relay.equals(e.relay)&&this.expiration===e.expiration}}const Wf=e=>e.protoCodes().includes(290);class Kf extends b{registrar;peerStore;addressManager;peerId;privateKey;connectionManager;connectionGater;reservationStore;started;hopTimeout;shutdownController;maxInboundHopStreams;maxOutboundHopStreams;maxOutboundStopStreams;log;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:server"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.addressManager=e.addressManager,this.peerId=e.peerId,this.privateKey=e.privateKey,this.connectionManager=e.connectionManager,this.connectionGater=e.connectionGater,this.started=!1,this.hopTimeout=t?.hopTimeout??3e4,this.maxInboundHopStreams=t.maxInboundHopStreams,this.maxOutboundHopStreams=t.maxOutboundHopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??300,this.reservationStore=new qf(e,t.reservations),this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-server";isStarted(){return this.started}async start(){this.started||(await this.registrar.handle(Dp,(e=>{this.onHop(e).catch((e=>{this.log.error(e)}))}),{maxInboundStreams:this.maxInboundHopStreams,maxOutboundStreams:this.maxOutboundHopStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){this.reservationStore.clear(),this.shutdownController.abort(),await this.registrar.unhandle(Dp),this.started=!1}async onHop({connection:e,stream:t}){this.log("received circuit v2 hop protocol stream from %p",e.remotePeer);const r={signal:AbortSignal.timeout(this.hopTimeout)},n=Fd(t);try{const t=await n.pb(Rp).read(r);if(null==t?.type)throw new Error("request was invalid, could not read from stream");this.log("received",t.type),await this.handleHopProtocol({connection:e,stream:n,request:t},r)}catch(e){this.log.error("error while handling hop",e),await n.pb(Rp).write({type:Rp.Type.STATUS,status:Fp.MALFORMED_MESSAGE},r),t.abort(e)}}async handleHopProtocol({stream:e,request:t,connection:r},n){switch(this.log("received hop message"),t.type){case Rp.Type.RESERVE:await this.handleReserve({stream:e,request:t,connection:r},n);break;case Rp.Type.CONNECT:await this.handleConnect({stream:e,request:t,connection:r},n);break;default:this.log.error("invalid hop request type %s via peer %p",t.type,r.remotePeer),await e.pb(Rp).write({type:Rp.Type.STATUS,status:Fp.UNEXPECTED_MESSAGE})}}async handleReserve({stream:e,connection:t},r){const n=e.pb(Rp);if(this.log("hop reserve request from %p",t.remotePeer),Wf(t.remoteAddr))return this.log.error("relay reservation over circuit connection denied for peer: %p",t.remotePeer),void await n.write({type:Rp.Type.STATUS,status:Fp.PERMISSION_DENIED},r);if(!0===await(this.connectionGater.denyInboundRelayReservation?.(t.remotePeer)))return this.log.error("reservation for %p denied by connection gater",t.remotePeer),void await n.write({type:Rp.Type.STATUS,status:Fp.PERMISSION_DENIED},r);const s=this.reservationStore.reserve(t.remotePeer,t.remoteAddr);try{if(s.status!==Fp.OK)return void await n.write({type:Rp.Type.STATUS,status:s.status},r);if(null!=s.expire){const e=1e3*s.expire-Date.now();await this.peerStore.merge(t.remotePeer,{tags:{[xp]:{value:1,ttl:e},[Mp]:{value:1,ttl:e}}})}await n.write({type:Rp.Type.STATUS,status:Fp.OK,reservation:await this.makeReservation(t.remotePeer,BigInt(s.expire??0)),limit:this.reservationStore.get(t.remotePeer)?.limit},r),this.log("sent confirmation response to %s",t.remotePeer)}catch(e){this.log.error("failed to send confirmation response to %p - %e",t.remotePeer,e),this.reservationStore.removeReservation(t.remotePeer);try{await this.peerStore.merge(t.remotePeer,{tags:{[xp]:void 0,[Mp]:void 0}})}catch(e){this.log.error("failed to untag relay source peer %p - %e",t.remotePeer,e)}}}async makeReservation(e,t){const r=[];for(const e of this.addressManager.getAddresses())e.toString().includes("/p2p-circuit")||r.push(e.bytes);const n=await Ip.seal(new jf({peer:e,relay:this.peerId,expiration:t}),this.privateKey);return{addrs:r,expire:t,voucher:{publicKey:ja(n.publicKey),payloadType:n.payloadType,payload:{peer:e.toMultihash().bytes,relay:this.peerId.toMultihash().bytes,expiration:t},signature:n.signature}}}async handleConnect({stream:e,request:t,connection:r},n){const s=e.pb(Rp);if(Wf(r.remoteAddr))return this.log.error("relay reservation over circuit connection denied for peer: %p",r.remotePeer),void await s.write({type:Rp.Type.STATUS,status:Fp.PERMISSION_DENIED},n);let i;this.log("hop connect request from %p",r.remotePeer);try{if(null==t.peer)throw this.log.error("no peer info in hop connect request"),new Error("no peer info in request");t.peer.addrs.forEach(Ud),i=rc(He(t.peer.id))}catch(e){return this.log.error("invalid hop connect request via peer %p %s",r.remotePeer,e),void await s.write({type:Rp.Type.STATUS,status:Fp.MALFORMED_MESSAGE},n)}const o=this.reservationStore.get(i);if(null==o)return this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s",i,r.remotePeer,Fp.NO_RESERVATION),void await s.write({type:Rp.Type.STATUS,status:Fp.NO_RESERVATION},n);if(!0===await(this.connectionGater.denyOutboundRelayedConnection?.(r.remotePeer,i)))return this.log.error("hop connect for %p to %p denied by connection gater",r.remotePeer,i),void await s.write({type:Rp.Type.STATUS,status:Fp.PERMISSION_DENIED},n);const a=this.connectionManager.getConnections(i);if(0===a.length)return this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection",i,r.remotePeer),void await s.write({type:Rp.Type.STATUS,status:Fp.NO_RESERVATION},n);const c=a[0],l=await this.stopHop({connection:c,request:{type:Bp.Type.CONNECT,peer:{id:r.remotePeer.toMultihash().bytes,addrs:[]},limit:o?.limit}},n);if(null==l)return this.log.error("failed to open stream to destination peer %p",c?.remotePeer),void await s.write({type:Rp.Type.STATUS,status:Fp.CONNECTION_FAILED},n);await s.write({type:Rp.Type.STATUS,status:Fp.OK,limit:o?.limit},n);const u=e.unwrap();this.log("connection from %p to %p established - merging streams",r.remotePeer,i),function(e,t,r,n,s){function i(r){e.abort(r),t.abort(r)}const o=[r,n.signal];null!=n.limit?.duration&&(s.log("limiting relayed connection duration to %dms",n.limit.duration),o.push(AbortSignal.timeout(n.limit.duration)));const a=Ad(o);let c,l=!1,u=!1;null!=n.limit?.data&&(c={remaining:n.limit.data}),queueMicrotask((()=>{const r=()=>{s.log("relayed connection reached time limit"),t.abort(new Pf(`duration limit of ${n.limit?.duration} ms exceeded`))};a.addEventListener("abort",r,{once:!0}),t.sink(null==c?e.source:Bf(e.source,c,s)).catch((e=>{s.log.error("error while relaying streams src -> dst",e),i(e)})).finally((()=>{l=!0,u&&(a.removeEventListener("abort",r),a.clear())}))})),queueMicrotask((()=>{const r=()=>{s.log("relayed connection reached time limit"),e.abort(new Pf(`duration limit of ${n.limit?.duration} ms exceeded`))};a.addEventListener("abort",r,{once:!0}),e.sink(null==c?t.source:Bf(t.source,c,s)).catch((e=>{s.log.error("error while relaying streams dst -> src",e),i(e)})).finally((()=>{u=!0,l&&(a.removeEventListener("abort",r),a.clear())}))}))}(u,l,this.shutdownController.signal,o,{log:this.log})}async stopHop({connection:e,request:t},r){this.log("starting circuit relay v2 stop request to %s",e.remotePeer);const n=await e.newStream([Np],{maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0,...r}),s=Fd(n),i=s.pb(Bp);let o;await i.write(t,r);try{o=await i.read(r)}catch(t){this.log.error("error parsing stop message response from %p",e.remotePeer)}return null==o?(this.log.error("could not read response from %p",e.remotePeer),void await n.close(r)):o.status===Fp.OK?(this.log("stop request to %p was successful",e.remotePeer),s.unwrap()):(this.log("stop request failed with code %d",o.status),void await n.close(r))}get reservations(){return this.reservationStore.reservations}}function Gf(e={}){return t=>new Kf(t,e)}const Yf=Symbol.for("@libp2p/transport");var Jf;function Qf(e){return null!=e&&"function"==typeof e.start&&"function"==typeof e.stop}async function Zf(...e){const t=[];for(const r of e)Qf(r)&&t.push(r);await Promise.all(t.map((async e=>{null!=e.beforeStart&&await e.beforeStart()}))),await Promise.all(t.map((async e=>{await e.start()}))),await Promise.all(t.map((async e=>{null!=e.afterStart&&await e.afterStart()})))}async function Xf(...e){const t=[];for(const r of e)Qf(r)&&t.push(r);await Promise.all(t.map((async e=>{null!=e.beforeStop&&await e.beforeStop()}))),await Promise.all(t.map((async e=>{await e.stop()}))),await Promise.all(t.map((async e=>{null!=e.afterStop&&await e.afterStop()})))}!function(e){e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"}(Jf||(Jf={}));class eg{filter;constructor(e,t){this.filter=ld(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function tg(e,t=.001){return new eg(e,t)}function rg(e){const{stream:t,remoteAddr:r,logger:n,onDataRead:s,onDataWrite:i}=e,o=n.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=t.close.bind(t);t.close=async e=>{await l(e),p(!0)};const u=t.abort.bind(t);t.abort=e=>{u(e),p(!0)};const h=t.sink.bind(t);t.sink=async e=>{try{await h(Ic(e,(e=>Hh(e,(e=>i?.(e))))))}catch(e){"aborted"!==e.type&&o.error("%s error in sink",r,e)}finally{c=!0,p()}};const d={log:o,sink:t.sink,source:async function*(){try{for await(const e of t.source)s?.(e),yield e}finally{a=!0,p()}}(),remoteAddr:r,timeline:{open:Date.now(),close:void 0},close:t.close,abort:t.abort};function p(e){!0===e&&(a=!0,c=!0),a&&c&&null==d.timeline.close&&(d.timeline.close=Date.now())}return d}class ng extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}class sg extends b{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(Dp,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){null!=this.topologyId&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then((async()=>{this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[e=>e.protocols.includes(Dp)],orders:[()=>Math.random()<.5?1:-1,(e,t)=>{const r=ig(e),n=ig(t);return r>n?-1:n>r?1:0}]});for(const t of e)this.log.trace("found relay peer %p in peer store",t.id),this.safeDispatchEvent("relay:discover",{detail:t.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new kd({concurrency:5});this.log("start random walk");for await(const e of this.randomWalk.walk({signal:this.discoveryController.signal}))this.log.trace("found random peer %p",e.id),t.has(e.id)?this.log.trace("random peer %p was already in queue",e.id):this.connectionManager.getConnections(e.id)?.length>0?this.log.trace("random peer %p was already connected",e.id):await this.connectionManager.isDialable(e.multiaddrs)?(t.queued>10&&(this.log.trace("wait for space in queue for %p",e.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",e.id,t.size,t.running),t.add((async()=>{const t=Ad([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(e.id,{signal:t})}finally{t.clear()}}),{peerId:e.id,signal:this.discoveryController.signal}).catch((t=>{this.log.error("error opening connection to random peer %p",e.id,t)}))):this.log.trace("random peer %p was not dialable",e.id,e.multiaddrs.map((e=>e.toString())));this.log("stop random walk"),await t.onIdle()})).catch((e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)})))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}}function ig(e){const t=e.metadata.get("last-dial-success");return null==t?0:new Date(ia(t)).getTime()}class og extends b{peerId;connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??2e3,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),!0===this.relay?.equals(e.detail.relay)&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach((e=>{this.addressManager.removeObservedAddr(e)})),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;"configured"!==t.type&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(this.log("listen on %a",e),Ff.exactMatch(e))this.reservationId=this.reservationStore.reserveRelay();else{if(!Uf.exactMatch(e))throw new Y(`Could not listen on p2p-circuit address "${e}"`);{const t=AbortSignal.timeout(this.listenTimeout),r=e.decapsulate("/p2p-circuit"),n=await this.connectionManager.openConnection(r,{signal:t});if(!this.reservationStore.hasReservation(n.remotePeer)){this.log("making reservation on peer %p",n.remotePeer);const e=await this.reservationStore.addRelay(n.remotePeer,"configured");this.addedRelay(e)}}}}getAddrs(){return[...this.listeningAddrs.values()].flat()}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask((()=>{this.safeDispatchEvent("close")}))}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map((e=>Ud(e).encapsulate("/p2p-circuit"))),this.listeningAddrs.forEach((e=>{this.addressManager.confirmObservedAddr(e,{type:"transport"})})),queueMicrotask((()=>{this.safeDispatchEvent("listening")}))}}let ag=(e=21)=>{let t="",r=crypto.getRandomValues(new Uint8Array(e|=0));for(;e--;)t+="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[63&r[e]];return t};class cg extends b{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Vf,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??100,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??2e3,this.started=!1,this.relayFilter=ld(100),this.reserveQueue=new kd({concurrency:t?.reservationConcurrency??1,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",(e=>{null!=[...this.reservations.values()].find((t=>t.connection===e.detail.id))&&this.#i(e.detail.remotePeer).catch((t=>{this.log("could not remove relay %p - %e",e.detail,t)}))}))}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then((async()=>{const e=await this.peerStore.all({filters:[e=>e.tags.has(Tp)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map((async e=>{await this.peerStore.merge(e.id,{tags:{[Tp]:void 0}})}))),this.log("redialing %d old relays",e.length),await Promise.all(e.map((async e=>this.addRelay(e.id,"discovered")))),this.#o()})).catch((e=>{this.log.error(e)}))}stop(){this.reserveQueue.clear(),this.reservations.forEach((({timeout:e})=>{clearTimeout(e)})),this.reservations.clear(),this.started=!1}reserveRelay(){const e=ag();return this.pendingReservations.push(e),this.#o(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Y("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new Rf("The reservation queue is full");const r=this.reserveQueue.find(e);if(null!=r)return this.log.trace("potential relay peer %p is already in the reservation queue",e),r.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Y("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add((async()=>{const r=Date.now();try{const r=this.reservations.get(e);if(null!=r){const t=this.connectionManager.getConnections(e);let n=!1;if(0===t.length&&this.log("already have relay reservation with %p but we are no longer connected",e),t.map((e=>e.id)).includes(r.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),n=!0),n&&Lf(r.reservation.expire)>6e5)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:r};await this.#i(e)}if("discovered"===t&&0===this.pendingReservations.length)throw new Df("Not making reservation on discovered relay because we do not need any more relays");const n=AbortSignal.timeout(this.reservationCompletionTimeout),s=await this.connectionManager.openConnection(e,{signal:n});if(xf.matches(s.remoteAddr))throw new Nf("not creating reservation over relayed connection");const i=await this.#a(s,{signal:n}),o=Lf(i.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+o).toString());const a=Math.min(Math.max(o-3e5,3e4),Math.pow(2,31)-1),c=setTimeout((()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch((async t=>{this.log.error("could not refresh reservation to relay %p - %e",e,t),await this.#i(e)})).catch((t=>{this.log.error("could not remove expired reservation to relay %p - %e",e,t)}))}),a);let l;if("discovered"===t){const e=this.pendingReservations.pop();if(null==e)throw new Df("Made reservation on relay but did not need any more discovered relays");l={timeout:c,reservation:i,type:t,connection:s.id,id:e}}else l={timeout:c,reservation:i,type:t,connection:s.id};this.reservations.set(e,l),await this.peerStore.merge(e,{tags:{[Tp]:{value:1,ttl:o}}}),this.#o();const u={relay:e,details:l};return this.safeDispatchEvent("relay:created-reservation",{detail:u}),u}catch(n){throw"discovered"===t&&"HadEnoughRelaysError"===n.name||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-r,n),"DialError"!==n.name&&"UnsupportedProtocolError"!==n.name||this.relayFilter.add(e.toMultihash().bytes),this.#i(e).catch((t=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,t)})),n}}),{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return null==e?this.reservations.size:[...this.reservations.values()].reduce(((t,r)=>(r.type===e&&t++,t)),0)}cancelReservations(){[...this.reservations.values()].forEach((e=>{clearTimeout(e.timeout)})),this.reservations.clear()}async#a(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const r=await e.newStream(Dp,t),n=Fd(r).pb(Rp);let s;this.log.trace("send RESERVE to %p",e.remotePeer),await n.write({type:Rp.Type.RESERVE},t);try{this.log.trace("reading response from %p",e.remotePeer),s=await n.read(t)}catch(e){throw r.abort(e),e}finally{"closed"!==r.status&&await r.close(t)}if(this.log.trace("read response %o",s),s.status===Fp.OK&&null!=s.reservation){const t=new Set;t.add(e.remoteAddr.toString());for(const r of s.reservation.addrs){let n=Ud(r);null==n.getPeerId()&&(n=n.encapsulate(`/p2p/${e.remotePeer}`)),n=Ud(n.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),t.add(n.toString())}return s.reservation.addrs=[...t].map((e=>Ud(e).bytes)),s.reservation}const i=`reservation failed with status ${s.status??"undefined"}`;throw this.log.error(i),new Error(i)}async#i(e){const t=this.reservations.get(e);null!=t&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),"discovered"===t.type&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[Tp]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#o())}#o(){if(0===this.pendingReservations.length)return this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),void this.safeDispatchEvent("relay:found-enough-relays");this.relayFilter=ld(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}class lg{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;stopTimeout;started;log;constructor(e,t){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??300,this.maxOutboundStopStreams=t.maxOutboundStopStreams??300,this.stopTimeout=t.stopTimeout??3e4,this.discovery=new sg(e,{filter:t.discoveryFilter??tg(4096,.001)}),this.discovery.addEventListener("relay:discover",(e=>{this.reservationStore.addRelay(e.detail,"discovered").catch((t=>{"HadEnoughRelaysError"!==t.name&&"RelayQueueFullError"!==t.name&&this.log.error("could not add discovered relay %p",e.detail,t)}))})),this.reservationStore=new cg(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",(()=>{this.discovery?.startDiscovery()})),this.reservationStore.addEventListener("relay:found-enough-relays",(()=>{this.discovery?.stopDiscovery()})),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[I]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[_](){return null!=this.discovery?["@libp2p/identify"]:[]}[Yf]=!0;isStarted(){return this.started}async start(){await this.registrar.handle(Np,(e=>{this.onStop(e).catch((t=>{this.log.error("error while handling STOP protocol",t),e.stream.abort(t)}))}),{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Zf(this.discovery,this.reservationStore),this.started=!0}async stop(){await Xf(this.discovery,this.reservationStore),await this.registrar.unhandle(Np),this.started=!1}async dial(e,t){if(1!==e.protoCodes().filter((e=>290===e)).length){const t="Invalid circuit relay address";throw this.log.error(t,e),new G(t)}const r=e.toString().split("/p2p-circuit"),n=Ud(r[0]),s=Ud(r[r.length-1]),i=n.getPeerId(),o=s.getPeerId();if(null==i||null==o){const t=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${t}`),new G(`C${t}`)}const a=ec(i),c=ec(o);let l,u=this.connectionManager.getConnections(a)[0];null==u?(await this.peerStore.merge(a,{multiaddrs:[n]}),t.onProgress?.(new ng("circuit-relay:open-connection")),u=await this.connectionManager.openConnection(a,t)):t.onProgress?.(new ng("circuit-relay:reuse-connection"));try{t.onProgress?.(new ng("circuit-relay:open-hop-stream")),l=await u.newStream(Dp,t);const r=Fd(l),i=r.pb(Rp);t.onProgress?.(new ng("circuit-relay:write-connect-message")),await i.write({type:Rp.Type.CONNECT,peer:{id:c.toMultihash().bytes,addrs:[Ud(s).bytes]}},t),t.onProgress?.(new ng("circuit-relay:read-connect-response"));const o=await i.read(t);if(o.status!==Fp.OK)throw new j(`failed to connect via relay with status ${o?.status?.toString()??"undefined"}`);const a=new Of(o.limit),h=rg({stream:r.unwrap(),remoteAddr:e,localAddr:n.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});return this.log("new outbound relayed connection %a",h.remoteAddr),await this.upgrader.upgradeOutbound(h,{...t,limits:a.getLimits()})}catch(e){throw this.log.error("circuit relay dial to destination %p via relay %p failed",c,a,e),l?.abort(e),e}}createListener(e){return function(e){return new og(e)}({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return(e=Array.isArray(e)?e:[e]).filter((e=>Uf.exactMatch(e)||Ff.exactMatch(e)))}dialFilter(e){return(e=Array.isArray(e)?e:[e]).filter((e=>xf.exactMatch(e)))}async onStop({connection:e,stream:t}){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(e){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",e)}const r=AbortSignal.timeout(this.stopTimeout),n=Fd(t).pb(Bp),s=await n.read({signal:r});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,s.type),void 0===s?.type)return this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await n.write({type:Bp.Type.STATUS,status:Fp.MALFORMED_MESSAGE},{signal:r}),void await t.close();if(s.type!==Bp.Type.CONNECT)return this.log.error("invalid stop connect request via peer %p",e.remotePeer),await n.write({type:Bp.Type.STATUS,status:Fp.UNEXPECTED_MESSAGE},{signal:r}),void await t.close();if(!(e=>{if(null==e.peer)return!1;try{e.peer.addrs.forEach(Ud)}catch{return!1}return!0})(s))return this.log.error("invalid stop connect request via peer %p",e.remotePeer),await n.write({type:Bp.Type.STATUS,status:Fp.MALFORMED_MESSAGE},{signal:r}),void await t.close();const i=rc(He(s.peer.id));if(!0===await(this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,i)))return this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await n.write({type:Bp.Type.STATUS,status:Fp.PERMISSION_DENIED},{signal:r}),void await t.close();this.log.trace("sending success response to %p",e.remotePeer),await n.write({type:Bp.Type.STATUS,status:Fp.OK},{signal:r});const o=new Of(s.limit),a=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${i.toString()}`),c=this.addressManager.getAddresses()[0],l=rg({stream:n.unwrap().unwrap(),remoteAddr:a,localAddr:c,logger:this.logger,onDataRead:o.onData,onDataWrite:o.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:o.getLimits()}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function ug(e={}){return t=>new lg(t,e)}const hg=()=>{const e=new Error("Delay aborted");return e.name="AbortError",e},dg=new WeakMap,pg=function({clearTimeout:e,setTimeout:t}={}){return(r,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(hg());let i,o,a;const c=e??clearTimeout,l=()=>{c(i),a(hg())},u=new Promise(((e,c)=>{o=()=>{s&&s.removeEventListener("abort",l),e(n)},a=c,i=(t??setTimeout)(o,r)}));return s&&s.addEventListener("abort",l,{once:!0}),dg.set(u,(()=>{c(i),i=null,o()})),u}}();var fg;function gg(e,t){return!xf.matches(e)&&(null!=t.dialTransportForMultiaddr(e)&&(!!nf.matches(e)||!!uf.matches(e)&&!1===fd(e.toOptions().host)))}!function(e){let t,r,n;!function(e){e.UNUSED="UNUSED",e.CONNECT="CONNECT",e.SYNC="SYNC"}(t=e.Type||(e.Type={})),function(e){e[e.UNUSED=0]="UNUSED",e[e.CONNECT=100]="CONNECT",e[e.SYNC=300]="SYNC"}(r||(r={})),function(e){e.codec=()=>Ns(r)}(t=e.Type||(e.Type={})),e.codec=()=>(null==n&&(n=Rs(((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.Type.codec().encode(t.type,r)),null!=t.observedAddresses)for(const e of t.observedAddresses)r.uint32(18),r.bytes(e);!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={observedAddresses:[]},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.type=e.Type.codec().decode(t);break;case 2:if(null!=n.limits?.observedAddresses&&s.observedAddresses.length===n.limits.observedAddresses)throw new Bs('Decode error - map field "observedAddresses" had too many elements');s.observedAddresses.push(t.bytes());break;default:t.skipType(7&r)}}return s}))),n),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(fg||(fg={}));class mg{started;timeout;retries;maxInboundStreams;maxOutboundStreams;peerStore;registrar;connectionManager;addressManager;transportManager;topologyId;log;constructor(e,t){this.log=e.logger.forComponent("libp2p:dcutr"),this.started=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.timeout=t.timeout??5e3,this.retries=t.retries??3,this.maxInboundStreams=t.maxInboundStreams??1,this.maxOutboundStreams=t.maxOutboundStreams??1}[Symbol.toStringTag]="@libp2p/dcutr";[_]=["@libp2p/identify"];isStarted(){return this.started}async start(){this.started||(this.topologyId=await this.registrar.register(yg,{notifyOnLimitedConnection:!0,onConnect:(e,t)=>{xf.exactMatch(t.remoteAddr)&&"inbound"===t.direction&&this.upgradeInbound(t).catch((e=>{this.log.error("error during outgoing DCUtR attempt",e)}))}}),await this.registrar.handle(yg,(e=>{this.handleIncomingUpgrade(e.stream,e.connection).catch((t=>{this.log.error("error during incoming DCUtR attempt",t),e.stream.abort(t)}))}),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){await this.registrar.unhandle(yg),null!=this.topologyId&&this.registrar.unregister(this.topologyId),this.started=!1}async upgradeInbound(e){if(await this.attemptUnilateralConnectionUpgrade(e))return;let t;for(let r=0;r<this.retries;r++){const n={signal:AbortSignal.timeout(this.timeout)};try{t=await e.newStream([yg],{signal:n.signal,runOnLimitedConnection:!0});const r=Fd(t,{maxDataLength:4096}).pb(fg);this.log("B sending connect to %p",e.remotePeer);const s=Date.now();await r.write({type:fg.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map((e=>e.bytes))},n),this.log("B receiving connect from %p",e.remotePeer);const i=await r.read(n);if(i.type!==fg.Type.CONNECT)throw this.log("A sent wrong message type"),new j("DCUtR message type was incorrect");const o=this.getDialableMultiaddrs(i.observedAddresses);if(0===o.length)throw this.log("A did not have any dialable multiaddrs"),new j("DCUtR connect message had no multiaddrs");const a=Date.now()-s;this.log("A sending sync, rtt %dms",a),await r.write({type:fg.Type.SYNC,observedAddresses:[]},n),this.log("A waiting for half RTT"),await pg(a/2),this.log("B dialing",o);const c=await this.connectionManager.openConnection(o,{signal:n.signal,priority:100});this.log("DCUtR to %p succeeded to address %a, closing relayed connection",e.remotePeer,c.remoteAddr),await e.close(n);break}catch(e){if(this.log.error("error while attempting DCUtR on attempt %d of %d",r+1,this.retries,e),t?.abort(e),r===this.retries)throw e}finally{null!=t&&await t.close(n)}}}async attemptUnilateralConnectionUpgrade(e){const t=(await this.peerStore.get(e.remotePeer)).addresses.map((t=>{const r=t.multiaddr;return null==r.getPeerId()?r.encapsulate(`/p2p/${e.remotePeer}`):r})).filter((e=>gg(e,this.transportManager)));if(t.length>0){const r=AbortSignal.timeout(this.timeout);try{this.log("attempting unilateral connection upgrade to %a",t);const n=await this.connectionManager.openConnection(t,{signal:r,force:!0});if(xf.exactMatch(n.remoteAddr))throw new Error("Could not open a new, non-limited, connection");return this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection",e.remotePeer,n.remoteAddr),await e.close({signal:r}),!0}catch(r){this.log.error("unilateral connection upgrade to %p on addresses %a failed",e.remotePeer,t,r)}}else this.log("peer %p has no public addresses, not attempting unilateral connection upgrade",e.remotePeer);return!1}async handleIncomingUpgrade(e,t){const r={signal:AbortSignal.timeout(this.timeout)};try{const n=Fd(e,{maxDataLength:4096}).pb(fg);this.log("A receiving connect");const s=await n.read(r);if(s.type!==fg.Type.CONNECT)throw this.log("B sent wrong message type"),new j("DCUtR message type was incorrect");if(0===s.observedAddresses.length)throw this.log("B sent no multiaddrs"),new j("DCUtR connect message had no multiaddrs");const i=this.getDialableMultiaddrs(s.observedAddresses);if(0===i.length)throw this.log("B had no dialable multiaddrs"),new j("DCUtR connect message had no dialable multiaddrs");if(this.log("A sending connect"),await n.write({type:fg.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map((e=>e.bytes))}),this.log("A receiving sync"),(await n.read(r)).type!==fg.Type.SYNC)throw new j("DCUtR message type was incorrect");this.log("A dialing",i);const o=await this.connectionManager.openConnection(i,{signal:r.signal,priority:100,force:!0});this.log("DCUtR to %p succeeded via %a, closing relayed connection",t.remotePeer,o.remoteAddr),await t.close(r)}catch(r){this.log.error("incoming DCUtR from %p failed",t.remotePeer,r),e.abort(r)}finally{await e.close(r)}}getDialableMultiaddrs(e){const t=[];for(const r of e)if(null!=r&&0!==r.length)try{const e=Ud(r);if(!gg(e,this.transportManager))continue;t.push(e)}catch{}return t}}const yg="/libp2p/dcutr";function wg(e={}){return t=>new mg(t,e)}const bg=1e3,vg=60*bg,Sg=60*vg,Eg=24*Sg,kg=7*Eg,Ag=function(e,t){try{if("string"==typeof e&&e.length>0)return function(e){if((e=String(e)).length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const t=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!t)return NaN;const r=parseFloat(t[1]),n=(t[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*r;case"weeks":case"week":case"w":return r*kg;case"days":case"day":case"d":return r*Eg;case"hours":case"hour":case"hrs":case"hr":case"h":return r*Sg;case"minutes":case"minute":case"mins":case"min":case"m":return r*vg;case"seconds":case"second":case"secs":case"sec":case"s":return r*bg;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:throw new Error(`The unit ${n} was matched, but no matching case exists.`)}}(e);if("number"==typeof e&&isFinite(e))return t?.long?function(e){const t=Math.abs(e);return t>=Eg?Ig(e,t,Eg,"day"):t>=Sg?Ig(e,t,Sg,"hour"):t>=vg?Ig(e,t,vg,"minute"):t>=bg?Ig(e,t,bg,"second"):`${e} ms`}(e):function(e){const t=Math.abs(e);return t>=Eg?`${Math.round(e/Eg)}d`:t>=Sg?`${Math.round(e/Sg)}h`:t>=vg?`${Math.round(e/vg)}m`:t>=bg?`${Math.round(e/bg)}s`:`${e}ms`}(e);throw new Error("Value is not a string or number.")}catch(t){const r=function(e){return"object"==typeof e&&null!==e&&"message"in e}(t)?`${t.message}. value=${JSON.stringify(e)}`:"An unknown error has occured.";throw new Error(r)}};function Ig(e,t,r,n){const s=t>=1.5*r;return`${Math.round(e/r)} ${n}${s?"s":""}`}const _g=function(){try{return localStorage}catch(e){}}(),Cg=console.debug??console.log??(()=>{}),xg=function(e){function t(e){let n,s,i,o=null;function a(...e){if(!a.enabled)return;const r=a,s=Number(new Date),i=s-(n||s);r.diff=i,r.prev=n,r.curr=s,n=s,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let o=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((n,s)=>{if("%%"===n)return"%";o++;const i=t.formatters[s];if("function"==typeof i){const t=e[o];n=i.call(r,t),e.splice(o,1),o--}return n})),t.formatArgs.call(r,e),(r.log||t.log).apply(r,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=r,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==o?o:(s!==t.namespaces&&(s=t.namespaces,i=t.enabled(e)),i),set:e=>{o=e}}),"function"==typeof t.init&&t.init(a),a}function r(e,r){const n=t(this.namespace+(void 0===r?":":r)+e);return n.log=this.log,n}function n(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){return e instanceof Error?e.stack??e.message:e},t.disable=function(){const e=[...t.names.map(n),...t.skips.map(n).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let r;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const n=("string"==typeof e?e:"").split(/[\s,]+/),s=n.length;for(r=0;r<s;r++)n[r]&&("-"===(e=n[r].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.substr(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let r,n;for(r=0,n=t.skips.length;r<n;r++)if(t.skips[r].test(e))return!1;for(r=0,n=t.names.length;r<n;r++)if(t.names[r].test(e))return!0;return!1},t.humanize=Ag,t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((r=>{t[r]=e[r]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let r=0;for(let t=0;t<e.length;t++)r=(r<<5)-r+e.charCodeAt(t),r|=0;return t.colors[Math.abs(r)%t.colors.length]},t.setupFormatters(t.formatters),t.enable(t.load()),t}({formatArgs:function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+Ag(this.diff),!this.useColors)return;const t="color: "+this.color;e.splice(1,0,t,"color: inherit");let r=0,n=0;e[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(r++,"%c"===e&&(n=r))})),e.splice(n,0,t)},save:function(e){try{e?_g?.setItem("debug",e):_g?.removeItem("debug")}catch(e){}},load:function(){let e;try{e=_g?.getItem("debug")}catch(e){}return!e&&void 0!==globalThis.process&&"env"in globalThis.process&&(e=globalThis.process.env.DEBUG),e},useColors:function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||null==navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement?.style?.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&null!=navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/))},setupFormatters:function(e){e.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},colors:["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],storage:_g,log:Cg}),Tg=xg;function Mg(){return{forComponent:e=>Pg(e)}}function Pg(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}(`${e}:trace`);return Tg.enabled(`${e}:trace`)&&null!=Tg.names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=Tg(`${e}:trace`)),Object.assign(Tg(e),{error:Tg(`${e}:error`),trace:t})}function Dg(e){if(null!=e&&0!==(e=e.trim()).length)return e}Tg.formatters.b=e=>null==e?"undefined":ue.baseEncode(e),Tg.formatters.t=e=>null==e?"undefined":de.baseEncode(e),Tg.formatters.m=e=>null==e?"undefined":Vn.baseEncode(e),Tg.formatters.p=e=>null==e?"undefined":e.toString(),Tg.formatters.c=e=>null==e?"undefined":e.toString(),Tg.formatters.k=e=>null==e?"undefined":e.toString(),Tg.formatters.a=e=>null==e?"undefined":e.toString(),Tg.formatters.e=e=>null==e?"undefined":Dg(e.stack)??Dg(e.message)??e.toString();var Ng=r(3007);const Rg=Pg("libp2p:simple-metrics");class Bg{value=0;update(e){this.value=e}increment(e=1){this.value+=e}decrement(e=1){this.value-=e}reset(){this.value=0}timer(){const e=Date.now();return()=>{this.value=Date.now()-e}}}class Lg{values={};update(e){Object.entries(e).forEach((([e,t])=>{this.values[e]=t}))}increment(e){Object.entries(e).forEach((([e,t])=>{this.values[e]=this.values[e]??0;const r="number"==typeof t?t:1;this.values[e]+=Number(r)}))}decrement(e){Object.entries(e).forEach((([e,t])=>{this.values[e]=this.values[e]??0;const r="number"==typeof t?t:1;this.values[e]-=Number(r)}))}reset(){this.values={}}timer(e){const t=Date.now();return()=>{this.values[e]=Date.now()-t}}}class Og{bucketValues=new Map;countValue=0;sumValue=0;constructor(e){const t=[...e.buckets??[.005,.01,.025,.05,.1,.25,.5,1,2.5,5,10],1/0];for(const e of t)this.bucketValues.set(e,0)}observe(e){this.countValue++,this.sumValue+=e;for(const[t,r]of this.bucketValues.entries())e<=t&&this.bucketValues.set(t,r+1)}reset(){this.countValue=0,this.sumValue=0;for(const e of this.bucketValues.keys())this.bucketValues.set(e,0)}timer(){const e=Date.now();return()=>{this.observe(Date.now()-e)}}}class Ug{histograms={};constructor(e){this.histograms={}}observe(e){for(const[t,r]of Object.entries(e))void 0===this.histograms[t]&&(this.histograms[t]=new Og({})),this.histograms[t].observe(r)}reset(){for(const e of Object.values(this.histograms))e.reset()}timer(e){const t=Date.now();return()=>{this.observe({[e]:Date.now()-t})}}}class Fg{sumValue=0;countValue=0;percentiles;tdigest=new Ng.TDigest(.01);compressCount;constructor(e){this.percentiles=e.percentiles??[.01,.05,.5,.9,.95,.99,.999],this.compressCount=e.compressCount??1e3}observe(e){this.sumValue+=e,this.countValue++,this.tdigest.push(e),this.tdigest.size()>this.compressCount&&this.tdigest.compress()}reset(){this.sumValue=0,this.countValue=0,this.tdigest.reset()}timer(){const e=Date.now();return()=>{this.observe(Date.now()-e)}}}class Vg{summaries={};opts;constructor(e){this.summaries={},this.opts=e}observe(e){for(const[t,r]of Object.entries(e))void 0===this.summaries[t]&&(this.summaries[t]=new Fg(this.opts)),this.summaries[t].observe(r)}reset(){for(const e of Object.values(this.summaries))e.reset()}timer(e){const t=Date.now();return()=>{this.observe({[e]:Date.now()-t})}}}class $g{metrics=new Map;transferStats;started;interval;intervalMs;onMetrics;constructor(e,t){this.started=!1,this._emitMetrics=this._emitMetrics.bind(this),this.intervalMs=t.intervalMs??1e3,this.onMetrics=t.onMetrics,this.transferStats=new Map}[Symbol.toStringTag]="@libp2p/metrics-simple";[I]=["@libp2p/metrics"];isStarted(){return this.started}start(){this.started=!0,this.interval=setInterval(this._emitMetrics,this.intervalMs)}stop(){this.started=!1,clearInterval(this.interval)}_emitMetrics(){Promise.resolve().then((async()=>{const e={};for(const[t,r]of this.metrics.entries())e[t]=r instanceof Bg?r.value:r instanceof Lg?r.values:r instanceof Og?{count:r.countValue,sum:r.sumValue,buckets:{...r.bucketValues}}:r instanceof Ug?{...Object.fromEntries(Object.entries(r.histograms).map((([e,t])=>[e,{count:t.countValue,sum:t.sumValue,buckets:{...t.bucketValues}}])))}:r instanceof Fg?{count:r.countValue,sum:r.sumValue,percentiles:Object.fromEntries(r.percentiles.map((e=>[e,r.tdigest.percentile(e)])))}:r instanceof Vg?{...Object.fromEntries(Object.entries(r.summaries).map((([e,t])=>[e,{count:t.countValue,sum:t.sumValue,percentiles:Object.fromEntries(t.percentiles.map((e=>[e,t.tdigest.percentile(e)])))}])))}:await r();this.onMetrics(structuredClone(e))})).catch((e=>{Rg.error("could not invoke onMetrics callback",e)}))}_incrementValue(e,t){const r=this.transferStats.get(e)??0;this.transferStats.set(e,r+t)}_track(e,t){const r=this,n=e.sink;e.sink=async function(e){await n(Hh(e,(e=>{r._incrementValue(`${t} sent`,e.byteLength)})))};const s=e.source;e.source=Hh(s,(e=>{r._incrementValue(`${t} received`,e.byteLength)}))}trackMultiaddrConnection(e){this._track(e,"global")}trackProtocolStream(e,t){null!=e.protocol&&this._track(e,e.protocol)}registerMetric(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Bg;return this.metrics.set(e,r),r}registerMetricGroup(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Lg;return this.metrics.set(e,r),r}registerCounter(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Bg;return this.metrics.set(e,r),r}registerCounterGroup(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Lg;return this.metrics.set(e,r),r}registerHistogram(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Og(t);return this.metrics.set(e,r),r}registerHistogramGroup(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Ug(t);return this.metrics.set(e,r),r}registerSummary(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Fg(t);return this.metrics.set(e,r),r}registerSummaryGroup(e,t={}){if(null==e||""===e.trim())throw new Error("Metric name is required");if(null!=t?.calculate)return void this.metrics.set(e,t.calculate);const r=new Vg(t);return this.metrics.set(e,r),r}}class Hg extends Error{constructor(e="Method not found"){super(e),this.name="MethodNotFoundError"}}class zg extends Error{constructor(e="Invocation target was not a function"){super(e),this.name="InvalidMethodError"}}class qg extends Error{constructor(e="Unsupported value type"){super(e),this.name="UnsupportedValueTypeError"}}class jg extends Error{constructor(e="Cannot reuse RPC target name"){super(e),this.name="DuplicateTargetNameError"}}class Wg extends Error{constructor(e="Duplicate scope"){super(e),this.name="DuplicateScopeError"}}class Kg extends Error{constructor(e="Invalid return type"){super(e),this.name="InvalidReturnTypeError"}}class Gg extends Error{constructor(e="Invocation target was not a function"){super(e),this.name="InvalidInvocationTypeError"}}class Yg extends Error{constructor(e="Parent invocation scope not found"){super(e),this.name="MissingParentScopeError"}}class Jg extends Error{constructor(e="Invocation not found"){super(e),this.name="MissingInvocationError"}}class Qg extends Error{constructor(e="Callback not found"){super(e),this.name="MissingCallbackError"}}var Zg,Xg,em,tm,rm,nm,sm,im,om,am,cm,lm;function um(e,t){if(function(e){return null!=e.parents}(e))return function(e,t){let r;for(const n of e)if(null!=r){if(r=r.children.get(n),null==r)throw new Yg}else if(r=t.get(n),null==r)throw new Yg;if(null==r)throw new Yg;return r}(e.parents,t);const r=t.get(e.scope);if(null==r)throw new Jg;return r}!function(e){e.invokeMethod="invokeMethod",e.methodResolved="methodResolved",e.methodRejected="methodRejected",e.invokeGeneratorMethod="invokeGeneratorMethod",e.abortMethodInvocation="abortMethodInvocation",e.invokeCallback="invokeCallback",e.callbackResolved="callbackResolved",e.callbackRejected="callbackRejected",e.abortCallbackInvocation="abortCallbackInvocation"}(Zg||(Zg={})),function(e){e[e.invokeMethod=0]="invokeMethod",e[e.methodResolved=1]="methodResolved",e[e.methodRejected=2]="methodRejected",e[e.invokeGeneratorMethod=3]="invokeGeneratorMethod",e[e.abortMethodInvocation=4]="abortMethodInvocation",e[e.invokeCallback=5]="invokeCallback",e[e.callbackResolved=6]="callbackResolved",e[e.callbackRejected=7]="callbackRejected",e[e.abortCallbackInvocation=8]="abortCallbackInvocation"}(Xg||(Xg={})),function(e){e.codec=()=>Ns(Xg)}(Zg||(Zg={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.type&&0!==e.type&&(t.uint32(8),t.uint32(e.type)),null!=e.value&&(t.uint32(18),t.bytes(e.value)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={type:0},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.type=e.uint32();break;case 2:n.value=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(em||(em={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.type&&0!==Xg[e.type]&&(t.uint32(8),Zg.codec().encode(e.type,t)),null!=e.message&&e.message.byteLength>0&&(t.uint32(18),t.bytes(e.message)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={type:Zg.invokeMethod,message:Xr(0)},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.type=Zg.codec().decode(e);break;case 2:n.message=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(tm||(tm={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),null!=e.path&&""!==e.path&&(t.uint32(18),t.string(e.path)),null!=e.args)for(const r of e.args)t.uint32(26),em.codec().encode(r,t);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:"",path:"",args:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.scope=e.string();break;case 2:n.path=e.string();break;case 3:if(null!=r.limits?.args&&n.args.length===r.limits.args)throw new Bs('Decode error - map field "args" had too many elements');n.args.push(em.codec().decode(e,e.uint32(),{limits:r.limits?.args$}));break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(rm||(rm={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();t>>>3==1?n.scope=e.string():e.skipType(7&t)}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(nm||(nm={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),null!=e.value&&(t.uint32(18),em.codec().encode(e.value,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.scope=e.string();break;case 2:n.value=em.codec().decode(e,e.uint32(),{limits:r.limits?.value});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(sm||(sm={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),null!=e.error&&(t.uint32(18),em.codec().encode(e.error,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.scope=e.string();break;case 2:n.error=em.codec().decode(e,e.uint32(),{limits:r.limits?.error});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(im||(im={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),null!=e.parents)for(const r of e.parents)t.uint32(18),t.string(r);if(null!=e.callback&&""!==e.callback&&(t.uint32(26),t.string(e.callback)),null!=e.args)for(const r of e.args)t.uint32(34),em.codec().encode(r,t);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:"",parents:[],callback:"",args:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.scope=e.string();break;case 2:if(null!=r.limits?.parents&&n.parents.length===r.limits.parents)throw new Bs('Decode error - map field "parents" had too many elements');n.parents.push(e.string());break;case 3:n.callback=e.string();break;case 4:if(null!=r.limits?.args&&n.args.length===r.limits.args)throw new Bs('Decode error - map field "args" had too many elements');n.args.push(em.codec().decode(e,e.uint32(),{limits:r.limits?.args$}));break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(om||(om={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),null!=e.parents)for(const r of e.parents)t.uint32(18),t.string(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:"",parents:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.scope=e.string();break;case 2:if(null!=r.limits?.parents&&n.parents.length===r.limits.parents)throw new Bs('Decode error - map field "parents" had too many elements');n.parents.push(e.string());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(am||(am={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),null!=e.parents)for(const r of e.parents)t.uint32(18),t.string(r);null!=e.value&&(t.uint32(26),em.codec().encode(e.value,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:"",parents:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.scope=e.string();break;case 2:if(null!=r.limits?.parents&&n.parents.length===r.limits.parents)throw new Bs('Decode error - map field "parents" had too many elements');n.parents.push(e.string());break;case 3:n.value=em.codec().decode(e,e.uint32(),{limits:r.limits?.value});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(cm||(cm={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.scope&&""!==e.scope&&(t.uint32(10),t.string(e.scope)),null!=e.parents)for(const r of e.parents)t.uint32(18),t.string(r);null!=e.error&&(t.uint32(26),em.codec().encode(e.error,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={scope:"",parents:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.scope=e.string();break;case 2:if(null!=r.limits?.parents&&n.parents.length===r.limits.parents)throw new Bs('Decode error - map field "parents" had too many elements');n.parents.push(e.string());break;case 3:n.error=em.codec().decode(e,e.uint32(),{limits:r.limits?.error});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(lm||(lm={}));const hm=["string","number","bigint","symbol"],dm=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class pm{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}pm.uint=new pm(0,"uint",!0),pm.negint=new pm(1,"negint",!0),pm.bytes=new pm(2,"bytes",!0),pm.string=new pm(3,"string",!0),pm.array=new pm(4,"array",!1),pm.map=new pm(5,"map",!1),pm.tag=new pm(6,"tag",!1),pm.float=new pm(7,"float",!0),pm.false=new pm(7,"false",!0),pm.true=new pm(7,"true",!0),pm.null=new pm(7,"null",!0),pm.undefined=new pm(7,"undefined",!0),pm.break=new pm(7,"break",!0);class fm{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const gm=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,mm=new TextDecoder,ym=new TextEncoder;function wm(e){return gm&&globalThis.Buffer.isBuffer(e)}function bm(e){return e instanceof Uint8Array?wm(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const vm=gm?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):Cm(e,t,r):(e,t,r)=>r-t>64?mm.decode(e.subarray(t,r)):Cm(e,t,r),Sm=gm?e=>e.length>64?globalThis.Buffer.from(e):_m(e):e=>e.length>64?ym.encode(e):_m(e),Em=e=>Uint8Array.from(e),km=gm?(e,t,r)=>wm(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r),Am=gm?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),bm(globalThis.Buffer.concat(e,t))):(e,t)=>{const r=new Uint8Array(t);let n=0;for(let t of e)n+t.length>r.length&&(t=t.subarray(0,r.length-n)),r.set(t,n),n+=t.length;return r},Im=gm?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function _m(e){const t=[];let r=0;for(let n=0;n<e.length;n++){let s=e.charCodeAt(n);s<128?t[r++]=s:s<2048?(t[r++]=s>>6|192,t[r++]=63&s|128):55296==(64512&s)&&n+1<e.length&&56320==(64512&e.charCodeAt(n+1))?(s=65536+((1023&s)<<10)+(1023&e.charCodeAt(++n)),t[r++]=s>>18|240,t[r++]=s>>12&63|128,t[r++]=s>>6&63|128,t[r++]=63&s|128):(t[r++]=s>>12|224,t[r++]=s>>6&63|128,t[r++]=63&s|128)}return t}function Cm(e,t,r){const n=[];for(;t<r;){const s=e[t];let i=null,o=s>239?4:s>223?3:s>191?2:1;if(t+o<=r){let r,n,a,c;switch(o){case 1:s<128&&(i=s);break;case 2:r=e[t+1],128==(192&r)&&(c=(31&s)<<6|63&r,c>127&&(i=c));break;case 3:r=e[t+1],n=e[t+2],128==(192&r)&&128==(192&n)&&(c=(15&s)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:r=e[t+1],n=e[t+2],a=e[t+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(c=(15&s)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,o=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=o}return function(e){const t=e.length;if(t<=xm)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=xm));return r}(n)}const xm=4096;class Tm{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const r=t.length-(this.maxCursor-this.cursor)-1;t.set(e,r)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=Im(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const r=this.chunks[0];e&&this.cursor>r.length/2?(t=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=km(r,0,this.cursor)}else t=Am(this.chunks,this.cursor);return e&&this.reset(),t}}const Mm="CBOR decode error:",Pm="CBOR encode error:",Dm=[];function Nm(e,t,r){if(e.length-t<r)throw new Error(`${Mm} not enough data for type`)}Dm[23]=1,Dm[24]=2,Dm[25]=3,Dm[26]=5,Dm[27]=9;const Rm=[24,256,65536,4294967296,BigInt("18446744073709551616")];function Bm(e,t,r){Nm(e,t,1);const n=e[t];if(!0===r.strict&&n<Rm[0])throw new Error(`${Mm} integer encoded in more bytes than necessary (strict decode)`);return n}function Lm(e,t,r){Nm(e,t,2);const n=e[t]<<8|e[t+1];if(!0===r.strict&&n<Rm[1])throw new Error(`${Mm} integer encoded in more bytes than necessary (strict decode)`);return n}function Om(e,t,r){Nm(e,t,4);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===r.strict&&n<Rm[2])throw new Error(`${Mm} integer encoded in more bytes than necessary (strict decode)`);return n}function Um(e,t,r){Nm(e,t,8);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],s=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(n)<<BigInt(32))+BigInt(s);if(!0===r.strict&&i<Rm[3])throw new Error(`${Mm} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===r.allowBigInt)return i;throw new Error(`${Mm} integers outside of the safe integer range are not supported`)}function Fm(e,t){return Vm(e,0,t.value)}function Vm(e,t,r){if(r<Rm[0]){const n=Number(r);e.push([t|n])}else if(r<Rm[1]){const n=Number(r);e.push([24|t,n])}else if(r<Rm[2]){const n=Number(r);e.push([25|t,n>>>8,255&n])}else if(r<Rm[3]){const n=Number(r);e.push([26|t,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<Rm[4]))throw new Error(`${Mm} encountered BigInt larger than allowable range`);{const r=[27|t,0,0,0,0,0,0,0];let s=Number(n&BigInt(4294967295)),i=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&s,s>>=8,r[7]=255&s,s>>=8,r[6]=255&s,s>>=8,r[5]=255&s,r[4]=255&i,i>>=8,r[3]=255&i,i>>=8,r[2]=255&i,i>>=8,r[1]=255&i,e.push(r)}}}Fm.encodedSize=function(e){return Vm.encodedSize(e.value)},Vm.encodedSize=function(e){return e<Rm[0]?1:e<Rm[1]?2:e<Rm[2]?3:e<Rm[3]?5:9},Fm.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const $m=BigInt(-1),Hm=BigInt(1);function zm(e,t){const r=t.value,n="bigint"==typeof r?r*$m-Hm:-1*r-1;Vm(e,t.type.majorEncoded,n)}function qm(e,t,r,n){Nm(e,t,r+n);const s=km(e,t+r,t+r+n);return new fm(pm.bytes,s,r+n)}function jm(e,t,r,n){return qm(e,t,1,r)}function Wm(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===pm.string?Sm(e.value):e.value),e.encodedBytes}function Km(e,t){const r=Wm(t);Vm(e,t.type.majorEncoded,r.length),e.push(r)}function Gm(e,t,r,n,s){const i=r+n;Nm(e,t,i);const o=new fm(pm.string,vm(e,t+r,t+i),i);return!0===s.retainStringBytes&&(o.byteValue=km(e,t+r,t+i)),o}function Ym(e,t,r,n){return Gm(e,t,1,r,n)}zm.encodedSize=function(e){const t=e.value,r="bigint"==typeof t?t*$m-Hm:-1*t-1;return r<Rm[0]?1:r<Rm[1]?2:r<Rm[2]?3:r<Rm[3]?5:9},zm.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},Km.encodedSize=function(e){const t=Wm(e);return Vm.encodedSize(t.length)+t.length},Km.compareTokens=function(e,t){return r=Wm(e),n=Wm(t),r.length<n.length?-1:r.length>n.length?1:function(e,t){if(wm(e)&&wm(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}(r,n);var r,n};const Jm=Km;function Qm(e,t,r,n){return new fm(pm.array,n,r)}function Zm(e,t,r,n){return Qm(0,0,1,r)}function Xm(e,t){Vm(e,pm.array.majorEncoded,t.value)}function ey(e,t,r,n){return new fm(pm.map,n,r)}function ty(e,t,r,n){return ey(0,0,1,r)}function ry(e,t){Vm(e,pm.map.majorEncoded,t.value)}function ny(e,t,r,n){return new fm(pm.tag,r,1)}function sy(e,t){Vm(e,pm.tag.majorEncoded,t.value)}function iy(e,t,r){if(r){if(!1===r.allowNaN&&Number.isNaN(e))throw new Error(`${Mm} NaN values are not supported`);if(!1===r.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${Mm} Infinity values are not supported`)}return new fm(pm.float,e,t)}function oy(e,t,r){const n=t.value;if(!1===n)e.push([20|pm.float.majorEncoded]);else if(!0===n)e.push([21|pm.float.majorEncoded]);else if(null===n)e.push([22|pm.float.majorEncoded]);else if(void 0===n)e.push([23|pm.float.majorEncoded]);else{let t,i=!1;r&&!0===r.float64||(uy(n),t=hy(ly,1),n===t||Number.isNaN(n)?(ly[0]=249,e.push(ly.slice(0,3)),i=!0):(dy(n),t=py(ly,1),n===t&&(ly[0]=250,e.push(ly.slice(0,5)),i=!0))),i||(s=n,cy.setFloat64(0,s,!1),t=fy(ly,1),ly[0]=251,e.push(ly.slice(0,9)))}var s}Xm.compareTokens=Fm.compareTokens,Xm.encodedSize=function(e){return Vm.encodedSize(e.value)},ry.compareTokens=Fm.compareTokens,ry.encodedSize=function(e){return Vm.encodedSize(e.value)},sy.compareTokens=Fm.compareTokens,sy.encodedSize=function(e){return Vm.encodedSize(e.value)},oy.encodedSize=function(e,t){const r=e.value;if(!1===r||!0===r||null==r)return 1;if(!t||!0!==t.float64){uy(r);let e=hy(ly,1);if(r===e||Number.isNaN(r))return 3;if(dy(r),e=py(ly,1),r===e)return 5}return 9};const ay=new ArrayBuffer(9),cy=new DataView(ay,1),ly=new Uint8Array(ay,0);function uy(e){if(e===1/0)cy.setUint16(0,31744,!1);else if(e===-1/0)cy.setUint16(0,64512,!1);else if(Number.isNaN(e))cy.setUint16(0,32256,!1);else{cy.setFloat32(0,e);const t=cy.getUint32(0),r=(2139095040&t)>>23,n=8388607&t;if(255===r)cy.setUint16(0,31744,!1);else if(0===r)cy.setUint16(0,(2147483648&e)>>16|n>>13,!1);else{const e=r-127;e<-24?cy.setUint16(0,0):e<-14?cy.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):cy.setUint16(0,(2147483648&t)>>16|e+15<<10|n>>13,!1)}}}function hy(e,t){if(e.length-t<2)throw new Error(`${Mm} not enough data for float16`);const r=(e[t]<<8)+e[t+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,s=1023&r;let i;return i=0===n?s*2**-24:31!==n?(s+1024)*2**(n-25):0===s?1/0:NaN,32768&r?-i:i}function dy(e){cy.setFloat32(0,e,!1)}function py(e,t){if(e.length-t<4)throw new Error(`${Mm} not enough data for float32`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,4).getFloat32(0,!1)}function fy(e,t){if(e.length-t<8)throw new Error(`${Mm} not enough data for float64`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,8).getFloat64(0,!1)}function gy(e,t,r){throw new Error(`${Mm} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function my(e){return()=>{throw new Error(`${Mm} ${e}`)}}oy.compareTokens=Fm.compareTokens;const yy=[];for(let e=0;e<=23;e++)yy[e]=gy;yy[24]=function(e,t,r,n){return new fm(pm.uint,Bm(e,t+1,n),2)},yy[25]=function(e,t,r,n){return new fm(pm.uint,Lm(e,t+1,n),3)},yy[26]=function(e,t,r,n){return new fm(pm.uint,Om(e,t+1,n),5)},yy[27]=function(e,t,r,n){return new fm(pm.uint,Um(e,t+1,n),9)},yy[28]=gy,yy[29]=gy,yy[30]=gy,yy[31]=gy;for(let e=32;e<=55;e++)yy[e]=gy;yy[56]=function(e,t,r,n){return new fm(pm.negint,-1-Bm(e,t+1,n),2)},yy[57]=function(e,t,r,n){return new fm(pm.negint,-1-Lm(e,t+1,n),3)},yy[58]=function(e,t,r,n){return new fm(pm.negint,-1-Om(e,t+1,n),5)},yy[59]=function(e,t,r,n){const s=Um(e,t+1,n);if("bigint"!=typeof s){const e=-1-s;if(e>=Number.MIN_SAFE_INTEGER)return new fm(pm.negint,e,9)}if(!0!==n.allowBigInt)throw new Error(`${Mm} integers outside of the safe integer range are not supported`);return new fm(pm.negint,$m-BigInt(s),9)},yy[60]=gy,yy[61]=gy,yy[62]=gy,yy[63]=gy;for(let e=64;e<=87;e++)yy[e]=jm;yy[88]=function(e,t,r,n){return qm(e,t,2,Bm(e,t+1,n))},yy[89]=function(e,t,r,n){return qm(e,t,3,Lm(e,t+1,n))},yy[90]=function(e,t,r,n){return qm(e,t,5,Om(e,t+1,n))},yy[91]=function(e,t,r,n){const s=Um(e,t+1,n);if("bigint"==typeof s)throw new Error(`${Mm} 64-bit integer bytes lengths not supported`);return qm(e,t,9,s)},yy[92]=gy,yy[93]=gy,yy[94]=gy,yy[95]=my("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)yy[e]=Ym;yy[120]=function(e,t,r,n){return Gm(e,t,2,Bm(e,t+1,n),n)},yy[121]=function(e,t,r,n){return Gm(e,t,3,Lm(e,t+1,n),n)},yy[122]=function(e,t,r,n){return Gm(e,t,5,Om(e,t+1,n),n)},yy[123]=function(e,t,r,n){const s=Um(e,t+1,n);if("bigint"==typeof s)throw new Error(`${Mm} 64-bit integer string lengths not supported`);return Gm(e,t,9,s,n)},yy[124]=gy,yy[125]=gy,yy[126]=gy,yy[127]=my("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)yy[e]=Zm;yy[152]=function(e,t,r,n){return Qm(0,0,2,Bm(e,t+1,n))},yy[153]=function(e,t,r,n){return Qm(0,0,3,Lm(e,t+1,n))},yy[154]=function(e,t,r,n){return Qm(0,0,5,Om(e,t+1,n))},yy[155]=function(e,t,r,n){const s=Um(e,t+1,n);if("bigint"==typeof s)throw new Error(`${Mm} 64-bit integer array lengths not supported`);return Qm(0,0,9,s)},yy[156]=gy,yy[157]=gy,yy[158]=gy,yy[159]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${Mm} indefinite length items not allowed`);return Qm(0,0,1,1/0)};for(let e=160;e<=183;e++)yy[e]=ty;yy[184]=function(e,t,r,n){return ey(0,0,2,Bm(e,t+1,n))},yy[185]=function(e,t,r,n){return ey(0,0,3,Lm(e,t+1,n))},yy[186]=function(e,t,r,n){return ey(0,0,5,Om(e,t+1,n))},yy[187]=function(e,t,r,n){const s=Um(e,t+1,n);if("bigint"==typeof s)throw new Error(`${Mm} 64-bit integer map lengths not supported`);return ey(0,0,9,s)},yy[188]=gy,yy[189]=gy,yy[190]=gy,yy[191]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${Mm} indefinite length items not allowed`);return ey(0,0,1,1/0)};for(let e=192;e<=215;e++)yy[e]=ny;yy[216]=function(e,t,r,n){return new fm(pm.tag,Bm(e,t+1,n),2)},yy[217]=function(e,t,r,n){return new fm(pm.tag,Lm(e,t+1,n),3)},yy[218]=function(e,t,r,n){return new fm(pm.tag,Om(e,t+1,n),5)},yy[219]=function(e,t,r,n){return new fm(pm.tag,Um(e,t+1,n),9)},yy[220]=gy,yy[221]=gy,yy[222]=gy,yy[223]=gy;for(let e=224;e<=243;e++)yy[e]=my("simple values are not supported");yy[244]=gy,yy[245]=gy,yy[246]=gy,yy[247]=function(e,t,r,n){if(!1===n.allowUndefined)throw new Error(`${Mm} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new fm(pm.null,null,1):new fm(pm.undefined,void 0,1)},yy[248]=my("simple values are not supported"),yy[249]=function(e,t,r,n){return iy(hy(e,t+1),3,n)},yy[250]=function(e,t,r,n){return iy(py(e,t+1),5,n)},yy[251]=function(e,t,r,n){return iy(fy(e,t+1),9,n)},yy[252]=gy,yy[253]=gy,yy[254]=gy,yy[255]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${Mm} indefinite length items not allowed`);return new fm(pm.break,void 0,1)};const wy=[];for(let e=0;e<24;e++)wy[e]=new fm(pm.uint,e,1);for(let e=-1;e>=-24;e--)wy[31-e]=new fm(pm.negint,e,1);wy[64]=new fm(pm.bytes,new Uint8Array(0),1),wy[96]=new fm(pm.string,"",1),wy[128]=new fm(pm.array,0,1),wy[160]=new fm(pm.map,0,1),wy[244]=new fm(pm.false,!1,1),wy[245]=new fm(pm.true,!0,1),wy[246]=new fm(pm.null,null,1);const by={float64:!1,mapSorter:function(e,t){const r=Array.isArray(e[0])?e[0][0]:e[0],n=Array.isArray(t[0])?t[0][0]:t[0];if(r.type!==n.type)return r.type.compare(n.type);const s=r.type.major,i=vy[s].compareTokens(r,n);return 0===i&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i},quickEncodeToken:function(e){switch(e.type){case pm.false:return Em([244]);case pm.true:return Em([245]);case pm.null:return Em([246]);case pm.bytes:return e.value.length?void 0:Em([64]);case pm.string:return""===e.value?Em([96]):void 0;case pm.array:return 0===e.value?Em([128]):void 0;case pm.map:return 0===e.value?Em([160]):void 0;case pm.uint:return e.value<24?Em([Number(e.value)]):void 0;case pm.negint:if(e.value>=-24)return Em([31-Number(e.value)])}}},vy=function(){const e=[];return e[pm.uint.major]=Fm,e[pm.negint.major]=zm,e[pm.bytes.major]=Km,e[pm.string.major]=Jm,e[pm.array.major]=Xm,e[pm.map.major]=ry,e[pm.tag.major]=sy,e[pm.float.major]=oy,e}(),Sy=new Tm;class Ey{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${Pm} object contains circular references`);return new Ey(t,e)}}const ky={null:new fm(pm.null,null),undefined:new fm(pm.undefined,void 0),true:new fm(pm.true,!0),false:new fm(pm.false,!1),emptyArray:new fm(pm.array,0),emptyMap:new fm(pm.map,0)},Ay={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new fm(e>=0?pm.uint:pm.negint,e):new fm(pm.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new fm(pm.uint,e):new fm(pm.negint,e),Uint8Array:(e,t,r,n)=>new fm(pm.bytes,e),string:(e,t,r,n)=>new fm(pm.string,e),boolean:(e,t,r,n)=>e?ky.true:ky.false,null:(e,t,r,n)=>ky.null,undefined:(e,t,r,n)=>ky.undefined,ArrayBuffer:(e,t,r,n)=>new fm(pm.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new fm(pm.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[ky.emptyArray,new fm(pm.break)]:ky.emptyArray;n=Ey.createCheck(n,e);const s=[];let i=0;for(const t of e)s[i++]=Iy(t,r,n);return r.addBreakTokens?[new fm(pm.array,e.length),s,new fm(pm.break)]:[new fm(pm.array,e.length),s]},Object(e,t,r,n){const s="Object"!==t,i=s?e.keys():Object.keys(e),o=s?e.size:i.length;if(!o)return!0===r.addBreakTokens?[ky.emptyMap,new fm(pm.break)]:ky.emptyMap;n=Ey.createCheck(n,e);const a=[];let c=0;for(const t of i)a[c++]=[Iy(t,r,n),Iy(s?e.get(t):e[t],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,r),r.addBreakTokens?[new fm(pm.map,o),a,new fm(pm.break)]:[new fm(pm.map,o),a]}};Ay.Map=Ay.Object,Ay.Buffer=Ay.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Ay[`${e}Array`]=Ay.DataView;function Iy(e,t={},r){const n=function(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(hm.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";return function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(dm.includes(t))return t}(e)||"Object"}(e),s=t&&t.typeEncoders&&t.typeEncoders[n]||Ay[n];if("function"==typeof s){const i=s(e,n,t,r);if(null!=i)return i}const i=Ay[n];if(!i)throw new Error(`${Pm} unsupported type: ${n}`);return i(e,n,t,r)}function _y(e,t,r,n){if(Array.isArray(t))for(const s of t)_y(e,s,r,n);else r[t.type.major](e,t,n)}function Cy(e,t,r){const n=Iy(e,r);if(!Array.isArray(n)&&r.quickEncodeToken){const e=r.quickEncodeToken(n);if(e)return e;const s=t[n.type.major];if(s.encodedSize){const e=s.encodedSize(n,r),t=new Tm(e);if(s(t,n,r),1!==t.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return bm(t.chunks[0])}}return Sy.reset(),_y(Sy,n,t,r),Sy.toBytes(!0)}function xy(e,t){return t=Object.assign({},by,t),Cy(e,vy,t)}const Ty={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class My{constructor(e,t={}){this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=wy[e];if(void 0===t){const r=yy[e];if(!r)throw new Error(`${Mm} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const n=31&e;t=r(this.data,this._pos,n,this.options)}return this._pos+=t.encodedLength,t}}const Py=Symbol.for("DONE"),Dy=Symbol.for("BREAK");function Ny(e,t){if(e.done())return Py;const r=e.next();if(r.type===pm.break)return Dy;if(r.type.terminal)return r.value;if(r.type===pm.array)return function(e,t,r){const n=[];for(let s=0;s<e.value;s++){const i=Ny(t,r);if(i===Dy){if(e.value===1/0)break;throw new Error(`${Mm} got unexpected break to lengthed array`)}if(i===Py)throw new Error(`${Mm} found array but not enough entries (got ${s}, expected ${e.value})`);n[s]=i}return n}(r,e,t);if(r.type===pm.map)return function(e,t,r){const n=!0===r.useMaps,s=n?void 0:{},i=n?new Map:void 0;for(let o=0;o<e.value;o++){const a=Ny(t,r);if(a===Dy){if(e.value===1/0)break;throw new Error(`${Mm} got unexpected break to lengthed map`)}if(a===Py)throw new Error(`${Mm} found map but not enough entries (got ${o} [no key], expected ${e.value})`);if(!0!==n&&"string"!=typeof a)throw new Error(`${Mm} non-string keys not supported (got ${typeof a})`);if(!0===r.rejectDuplicateMapKeys&&(n&&i.has(a)||!n&&a in s))throw new Error(`${Mm} found repeat map key "${a}"`);const c=Ny(t,r);if(c===Py)throw new Error(`${Mm} found map but not enough entries (got ${o} [no value], expected ${e.value})`);n?i.set(a,c):s[a]=c}return n?i:s}(r,e,t);if(r.type===pm.tag){if(t.tags&&"function"==typeof t.tags[r.value]){const n=Ny(e,t);return t.tags[r.value](n)}throw new Error(`${Mm} tag not supported (${r.value})`)}throw new Error("unsupported")}function Ry(e,t){const[r,n]=function(e,t){if(!(e instanceof Uint8Array))throw new Error(`${Mm} data to decode must be a Uint8Array`);const r=(t=Object.assign({},Ty,t)).tokenizer||new My(e,t),n=Ny(r,t);if(n===Py)throw new Error(`${Mm} did not find any content to decode`);if(n===Dy)throw new Error(`${Mm} got unexpected break`);return[n,e.subarray(r.pos())]}(e,t);if(n.length>0)throw new Error(`${Mm} too many terminals, data makes no sense`);return r}const By={type:1029,canEncode:e=>Array.isArray(e),encode:(e,t,r,n)=>xy(e.map((e=>t.toValue(e,r,n)))),decode:(e,t,r,n)=>Ry(e).map((e=>t.fromValue(e,r,n)))},Ly={type:1030,canEncode:e=>"function"==typeof e,encode:(e,t,r,n)=>{const s=ag();return n?.callbacks.set(s,{context:r,fn:e}),xy(s)},decode:(e,t,r,n)=>async(...s)=>new Promise(((i,o)=>{const a=Ry(e),c=ag(),l={scope:c,result:bc(),callbacks:new Map,children:new Map,parents:[...n.parents,n.scope],abortControllers:[],abortSignals:[]};n.children.set(c,l),s=s.map((e=>t.toValue(e,null,l)));const u=Ad(l.abortSignals);u.addEventListener("abort",(()=>{r.push(tm.encode({type:Zg.abortCallbackInvocation,message:am.encode({scope:c,parents:l.parents})}))})),r.push(tm.encode({type:Zg.invokeCallback,message:om.encode({scope:c,parents:l.parents,callback:a,args:s})})),l.result.promise.then((e=>{i(e)}),(e=>{o(e)})).finally((()=>{n.children.delete(c),u.clear()}))}))},Oy=["__defineGetter__","__defineSetter__","hasOwnProperty","__lookupGetter__","__lookupSetter__","isPrototypeOf","propertyIsEnumerable","toString","valueOf","__proto__","toLocaleString","constructor"],Uy={type:2147483647,canEncode:e=>"object"==typeof e,encode:(e,t,r,n)=>{const s={};for(const t in e)Oy.includes(t)||Object.hasOwn(e,t)&&(s[t]=e[t]);for(const t of Object.getOwnPropertyNames(Object.getPrototypeOf(e)))Oy.includes(t)||(s[t]=e[t]);return xy([...Object.entries(s)].map((([r,s])=>[t.toValue(r,e,n),t.toValue(s,e,n)])))},decode:(e,t,r,n)=>{const s={};return Ry(e).forEach((([e,i])=>{s[t.fromValue(e,r,n)]=t.fromValue(i,r,n)})),s}},Fy=Uy,Vy={type:1034,canEncode:e=>"function"==typeof e.next&&"function"==typeof e.throw&&"function"==typeof e.return,encode:(e,t,r,n)=>Fy.encode({next:e.next.bind(e),throw:e.throw.bind(e),return:e.return.bind(e)},t,r,n),decode:(e,t,r,n)=>{const s=Fy.decode(e,t,r,n);return s[Symbol.asyncIterator]=()=>s,s}},$y={type:1036,canEncode:e=>e instanceof Map,encode:(e,t,r,n)=>xy([...e.entries()].map((([e,s])=>[t.toValue(e,r,n),t.toValue(s,r,n)]))),decode:(e,t,r,n)=>{const s=new Map;return Ry(e).forEach((([e,i])=>{const o=t.fromValue(e,r,n),a=t.fromValue(i,r,n);s.set(o,a)})),s}},Hy={type:1037,canEncode:e=>e instanceof Set,encode:(e,t,r,n)=>xy([...e.values()].map((e=>t.toValue(e,r,n)))),decode:(e,t,r,n)=>{const s=new Set;return Ry(e).forEach((e=>{s.add(t.fromValue(e,r,n))})),s}},zy=[{type:1024,canEncode:e=>void 0===e,decode:()=>{}},{type:1025,canEncode:e=>null===e,decode:()=>null},{type:1026,canEncode:e=>!0===e||!1===e,encode:e=>xy(e),decode:e=>Ry(e)},{type:1027,canEncode:e=>"number"==typeof e&&!isNaN(e),encode:e=>xy(e),decode:e=>Ry(e)},{type:1028,canEncode:e=>"string"==typeof e,encode:e=>xy(e),decode:e=>Ry(e)},By,Ly,{type:1031,canEncode:e=>"NaN"===e.toString()&&isNaN(e),decode:()=>NaN},{type:1032,canEncode:e=>e instanceof Error,encode:e=>xy({message:e.message,name:e.name,code:e.code,type:e.type,stack:e.stack}),decode:e=>{const t=Ry(e),r=new Error(t.message);return r.name=t.name,r.stack=t.stack,r.code=t.code,r.type=t.type,r}},{type:1033,canEncode:e=>Array.isArray(e),encode:(e,t,r,n)=>{throw new Error("Promises are not supported")},decode:(e,t,r,n)=>{throw new Error("Promises are not supported")}},Vy,{type:1035,canEncode:e=>"bigint"==typeof e,encode:e=>xy(e),decode:e=>BigInt(Ry(e))},$y,Hy,{type:1038,canEncode:e=>e instanceof Uint8Array,encode:e=>e,decode:e=>e},{type:1039,canEncode:e=>e instanceof AbortSignal,encode:(e,t,r,n)=>(n?.abortSignals.push(e),new Uint8Array(0)),decode:(e,t,r,n)=>{const s=new AbortController;return n.abortControllers.push(s),s.signal}},{type:1040,canEncode:e=>e instanceof Date,encode:e=>xy(e.toString()),decode:e=>new Date(Ry(e))},{type:1041,canEncode:e=>e instanceof RegExp,encode:e=>xy({source:e.source,flags:e.flags}),decode:e=>{const{source:t,flags:r}=Ry(e);return new RegExp(t,r)}},Fy];class qy{transformersMap;transformersList;constructor(e){this.transformersList=[...zy,...e?.valueCodecs??[]].sort(((e,t)=>e.type<t.type?-1:e.type>t.type?1:0)),this.transformersMap={},this.transformersList.forEach((e=>{if(null!=this.transformersMap[e.type])throw new Error(`Duplicate transformer type ${e.type}`);this.transformersMap[e.type]=e}))}toValue(e,t,r){for(let n=0;n<this.transformersList.length;n++){const s=this.transformersList[n];if(s.canEncode(e))return{type:s.type,value:s.encode?.(e,this,t,r)}}throw new qg(`Unsupported value type "${e}"`)}fromValue(e,t,r){const n=this.transformersMap[e.type];if(null==n)throw new qg(`Unsupported value type "${e.type}"`);return n.decode(e.value??new Uint8Array(0),this,t,r)}}function jy(e){return e.type===Zg.invokeMethod||e.type===Zg.invokeGeneratorMethod||e.type===Zg.invokeCallback}class Wy{source;output;targets;invocations;values;messageHandlers;constructor(e){this.output=kc(),this.source=hc(this.output),this.targets=new Map,this.invocations=new Map,this.values=new qy(e),this.sink=this.sink.bind(this),this.messageHandlers={[Zg.invokeMethod]:{decoder:rm,handler:this.handleInvokeMethod.bind(this)},[Zg.invokeGeneratorMethod]:{decoder:rm,handler:this.handleInvokeGeneratorMethod.bind(this)},[Zg.abortMethodInvocation]:{decoder:nm,handler:this.handleAbortMethod.bind(this),isScope:!0},[Zg.methodResolved]:{decoder:sm,handler:this.handleMethodResolved.bind(this),isScope:!0},[Zg.methodRejected]:{decoder:im,handler:this.handleMethodRejected.bind(this),isScope:!0,isError:!0},[Zg.invokeCallback]:{decoder:om,handler:this.handleInvokeCallback.bind(this),isScope:!0},[Zg.abortCallbackInvocation]:{decoder:am,handler:this.handleAbortCallback.bind(this),isScope:!0},[Zg.callbackResolved]:{decoder:cm,handler:this.handleCallbackResolved.bind(this),isScope:!0},[Zg.callbackRejected]:{decoder:lm,handler:this.handleCallbackRejected.bind(this),isScope:!0,isError:!0}}}async sink(e){for await(const t of wc(e))try{const e=tm.decode(t),r=this.messageHandlers[e.type];if(null==r)continue;const n=r.decoder.decode(e.message);let s;if(!0===r.isScope)try{s=um(n,this.invocations)}catch(e){continue}r.handler(n,s).catch((t=>{jy(e)&&this.sendError(n,t),this.invocations.delete(n.scope)})).finally((()=>{e.type===Zg.invokeMethod&&this.invocations.delete(n.scope)}))}catch{continue}}sendError(e,t){null!=e.parents?this.output.push(tm.encode({type:Zg.callbackRejected,message:lm.encode({scope:e.scope,parents:e.parents,error:this.values.toValue(t)})})):this.output.push(tm.encode({type:Zg.methodRejected,message:im.encode({scope:e.scope,error:this.values.toValue(t)})}))}createClient(e){return this.proxy(e)}createTarget(e,t){if(this.targets.has(e))throw new jg(`Cannot reuse RPC target name "${e}"`);this.targets.set(e,t)}async handleInvokeMethod(e){if(this.invocations.has(e.scope))throw new Wg;const t=new Map,r=new Map,n={scope:e.scope,result:bc(),callbacks:t,children:r,parents:[],abortControllers:[],abortSignals:[]};this.invocations.set(e.scope,n);const s=this.lookupInvocationTarget(e.path),i=await s.fn.apply(s.context,e.args.map((e=>this.values.fromValue(e,this.output,n))));this.output.push(tm.encode({type:Zg.methodResolved,message:sm.encode({scope:e.scope,value:this.values.toValue(i)})}))}async handleAbortMethod(e,t){t.abortControllers.forEach((e=>{e.abort()}))}async handleInvokeGeneratorMethod(e){if(this.invocations.has(e.scope))throw new Wg;const t=new Map,r=new Map,n={scope:e.scope,result:bc(),callbacks:t,children:r,parents:[],abortControllers:[],abortSignals:[]};this.invocations.set(e.scope,n);const s=this.lookupInvocationTarget(e.path),i=s.fn.apply(s.context,e.args.map((e=>this.values.fromValue(e,this.output,n))));if("function"!=typeof i.next)throw new Kg(`${e.path} did not return an async generator`);const o={next:async()=>{const t=await i.next();return!0===t.done&&this.invocations.delete(e.scope),t},throw:async t=>{try{const r=await i.throw(t);return!0===r.done&&this.invocations.delete(e.scope),r}catch(t){throw this.invocations.delete(e.scope),t}},return:async t=>{const r=await i.return(t);return!0===r.done&&this.invocations.delete(e.scope),r},[Symbol.asyncIterator]:()=>o};this.output.push(tm.encode({type:Zg.methodResolved,message:sm.encode({scope:e.scope,value:this.values.toValue(o,null,n)})}))}lookupInvocationTarget(e){const t=e.split(".");let r=this.targets.get(t[0]),n=r;for(let e=1;e<t.length;e++)n=r,r=r?.[t[e]];if(null==r){if(null!=n&&e.endsWith(".then"))throw new zg(`"${e.substring(0,e.length-5)}" was not a function`);throw new Hg(`Could not find "${e}" on target`)}if("function"!=typeof r)throw new Gg("Invocation target was not a function");return{context:n,fn:r}}async handleMethodResolved(e,t){let r;null!=e.value&&(r=this.values.fromValue(e.value,this.output,t)),t.result.resolve(r)}async handleMethodRejected(e,t){let r;null!=e.error&&(r=this.values.fromValue(e.error,this.output,t)),t.result.reject(r)}async handleInvokeCallback(e,t){const r=t.callbacks.get(e.callback);if(null==r)throw new Qg;const n=await r.fn.apply(r.context,e.args.map((e=>this.values.fromValue(e,this.output,t))));this.output.push(tm.encode({type:Zg.callbackResolved,message:cm.encode({scope:e.scope,parents:e.parents,value:this.values.toValue(n)})}))}async handleAbortCallback(e,t){t.abortControllers.forEach((e=>{e.abort()}))}async handleCallbackResolved(e,t){let r;null!=e.value&&(r=this.values.fromValue(e.value,this.output,t)),t.children.get(e.scope)?.result.resolve(r),t.children.delete(e.scope)}async handleCallbackRejected(e,t){let r;null!=e.error&&(r=this.values.fromValue(e.error,this.output,t)),t.children.get(e.scope)?.result.reject(r),t.children.delete(e.scope)}proxy(e){const t=()=>{},r=this;return new Proxy(t,{get:(t,n,s)=>r.proxy(`${null==e?"":`${e}.`}${n.toString()}`),apply(n,s,i){let o,a;function c(){return null==a&&(a=new Promise(((t,n)=>{const s=ag(),o={scope:s,result:bc(),callbacks:new Map,children:new Map,parents:[],abortControllers:[],abortSignals:[]};r.invocations.set(s,o),r.output.push(tm.encode({type:Zg.invokeMethod,message:rm.encode({scope:s,path:e,args:i.map((e=>r.values.toValue(e,null,o)))})}));const a=Ad(o.abortSignals);a.addEventListener("abort",(()=>{r.output.push(tm.encode({type:Zg.abortMethodInvocation,message:nm.encode({scope:s})}))})),o.result.promise.then((e=>{t(e)}),(e=>{n(e)})).finally((()=>{r.invocations.delete(s),a.clear()}))}))),a}function l(){if(null==o){const t=ag(),n={scope:t,result:bc(),callbacks:new Map,children:new Map,parents:[],abortControllers:[],abortSignals:[]};let s;r.invocations.set(t,n),r.output.push(tm.encode({type:Zg.invokeGeneratorMethod,message:rm.encode({scope:t,path:e,args:i.map((e=>r.values.toValue(e,null,n)))})})),o={async next(){if(null!=s)throw s;const e=await n.result.promise,i=await e.next();return!0===i.done&&r.invocations.delete(t),i},async throw(e){if(null!=s)throw s;try{const s=await n.result.promise,i=await s.throw(e);return!0===i.done&&r.invocations.delete(t),i}catch(n){throw r.invocations.delete(t),s=e,n}},async return(e){if(null!=s)throw s;const i=await n.result.promise,o=await i.return(e);return!0===o.done&&r.invocations.delete(t),o},[Symbol.asyncIterator]:()=>o}}return o}return new Proxy(t,{get(e,t,r){if("then"===t)return c().then.bind(a);if("catch"===t)return c().catch.bind(a);if("finally"===t)return c().finally.bind(a);if(t===Symbol.asyncIterator)return()=>l();if("next"===t)return l().next.bind(o);if("return"===t)return l().return.bind(o);if("throw"===t)return l().throw.bind(o);if(t===Symbol.toStringTag)return"[object Object]";if("constructor"===t)return()=>{};throw new Gg(`Property ${t.toString()} was not used as a promise or async generator`)}})}})}}const Ky={type:4096,canEncode:e=>null!=e.code&&null!=e.version&&null!=e.multihash&&null!=e["/"],encode:e=>e.bytes,decode:e=>Ke.decode(e)},Gy={type:4099,canEncode:e=>e instanceof ng,encode:(e,t,r,n)=>xy({type:e.type,detail:t.toValue(e.detail,r,n)}),decode:(e,t,r,n)=>{const{type:s,detail:i}=Ry(e);return new ng(s,t.fromValue(i,r,n))}},Yy={type:4097,canEncode:e=>Od(e),encode:e=>e.bytes,decode:e=>Ud(e)},Jy={type:4098,canEncode:e=>Ka(e),encode:e=>e.toMultihash().bytes,decode:e=>rc(He(e))},Qy=[Ky,Yy,Jy,Gy];function Zy(e){const t={},r=e.components??e;return Object.entries(r).forEach((([e,r])=>{null!=r?.[I]&&Array.isArray(r[I])&&(t[e]=r[I])})),t}function Xy(e,t){const r={};for(const[n,s]of e.entries())r[n]=t(s);return r}async function ew(e,t){const r=[],n=e.connectionManager.getConnectionsMap(),s=[...n.values()].flatMap((e=>e)).map((e=>e.remoteAddr.toString()));for(const[i,o]of n.entries())try{const t=await e.peerStore.get(i);r.push({id:i,addresses:t.addresses.map((({isCertified:e,multiaddr:t})=>({multiaddr:t,isCertified:e,isConnected:s.includes(t.toString())}))),protocols:[...t.protocols],tags:Xy(t.tags,(e=>e.value)),metadata:Xy(t.metadata,(e=>Vn.encode(e)))})}catch(e){t.error("could not load peer data from peer store",e),r.push({id:i,addresses:o.map((e=>({multiaddr:e.remoteAddr,isConnected:s.includes(e.remoteAddr.toString())}))),protocols:[],tags:{},metadata:{}})}return r}function tw(e,t){const r=t[e];if(!A(r))throw new M(`Component ${e} did not implement the PubSub interface`);return r}async function rw(e){const t=await e.peerStore.get(e.peerId);return{id:t.id,addresses:t.addresses,protocols:[...t.protocols],tags:Xy(t.tags,(e=>e.value)),metadata:Xy(t.metadata,(e=>Vn.encode(e)))}}function nw(e,t=100){let r,n;return()=>{if(null==n&&(n=Date.now()),null!=r&&Date.now()-n>t)return clearTimeout(r),n=void 0,void e();clearTimeout(r),r=setTimeout((()=>{n=void 0,e()}),t)}}Object.defineProperty(globalThis,"________libp2p_devtools_metrics",{value:!0,enumerable:!1,writable:!1});class sw{log;components;simpleMetrics;intervalMs;rpcQueue;rpc;devTools;constructor(e,t){this.log=e.logger.forComponent("libp2p:devtools-metrics"),this.intervalMs=t?.intervalMs,this.components=e,this.rpcQueue=kc(),this.rpc=function(e){return new Wy(e)}({valueCodecs:Qy}),this.devTools=this.rpc.createClient("devTools"),this.onPeersUpdate=nw(this.onPeersUpdate.bind(this),1e3),this.onSelfUpdate=nw(this.onSelfUpdate.bind(this),1e3),this.onIncomingMessage=this.onIncomingMessage.bind(this),this.onPubSubMessage=this.onPubSubMessage.bind(this),this.onPubSubSubscriptionChange=this.onPubSubSubscriptionChange.bind(this),this.simpleMetrics=function(e){return t=>new $g(t,e)}({intervalMs:this.intervalMs,onMetrics:e=>{this.devTools.safeDispatchEvent("metrics",{detail:e}).catch((e=>{this.log.error("error sending metrics",e)}))}})({})}[Symbol.toStringTag]="@libp2p/devtools-metrics";[I]=["@libp2p/metrics"];trackMultiaddrConnection(e){this.simpleMetrics.trackMultiaddrConnection(e)}trackProtocolStream(e,t){this.simpleMetrics.trackProtocolStream(e,t)}registerMetric(e,t){return this.simpleMetrics.registerMetric(e,t)}registerMetricGroup(e,t){return this.simpleMetrics.registerMetricGroup(e,t)}registerCounter(e,t){return this.simpleMetrics.registerCounter(e,t)}registerCounterGroup(e,t){return this.simpleMetrics.registerCounterGroup(e,t)}registerHistogram(e,t){return this.simpleMetrics.registerHistogram(e,t)}registerHistogramGroup(e,t){return this.simpleMetrics.registerHistogramGroup(e,t)}registerSummary(e,t){return this.simpleMetrics.registerSummary(e,t)}registerSummaryGroup(e,t){return this.simpleMetrics.registerSummaryGroup(e,t)}async start(){this.components.events.addEventListener("peer:connect",this.onPeersUpdate),this.components.events.addEventListener("peer:disconnect",this.onPeersUpdate),this.components.events.addEventListener("peer:identify",this.onPeersUpdate),this.components.events.addEventListener("peer:update",this.onPeersUpdate),this.components.events.addEventListener("self:peer:update",this.onSelfUpdate),window.addEventListener("message",this.onIncomingMessage),this.rpc.createTarget("metrics",function(e){const t=e.logger.forComponent("libp2p:devtools-metrics:metrics-rpc");return{init:async()=>({self:await rw(e),peers:await ew(e,t),debug:localStorage.getItem("debug")??"",capabilities:Zy(e)}),setDebug:async e=>{var t;null!=e?.length&&e?.length>0?(t=e,Tg.enable(t),localStorage.setItem("debug",e)):(Tg.disable(),localStorage.removeItem("debug"))},openConnection:async(t,r)=>{let n;try{n=ec(t)}catch{n=Ud(t)}await e.connectionManager.openConnection(n,r)},closeConnection:async(t,r)=>{await Promise.all(e.connectionManager.getConnections(t).map((async e=>{try{await e.close(r)}catch(t){e.abort(t)}})))},contentRouting:e.contentRouting,peerRouting:e.peerRouting,pubsub:{getTopics:async t=>tw(t,e).getTopics(),async subscribe(t,r){tw(t,e).subscribe(r)},async unsubscribe(t,r){tw(t,e).unsubscribe(r)},async publish(t,r,n){await tw(t,e).publish(r,n)},getSubscribers:async(t,r)=>tw(t,e).getSubscribers(r)}}}(this.components)),await Zf(this.simpleMetrics),Promise.resolve().then((async()=>{await Ic(this.rpcQueue,this.rpc,(async e=>{for await(const t of e)window.postMessage({source:"@libp2p/devtools-metrics:metrics",type:"libp2p-rpc",message:Vn.encode(t)})}))})).catch((e=>{this.log.error("error while reading RPC messages",e)}));const e=function(e,t){for(const[e,r]of Object.entries(Zy(t)))if(r.includes("@libp2p/pubsub"))return t[e]}(0,this.components);A(e)&&(e.addEventListener("message",this.onPubSubMessage),e.addEventListener("subscription-change",this.onPubSubSubscriptionChange))}async stop(){window.removeEventListener("message",this.onIncomingMessage),this.components.events.removeEventListener("self:peer:update",this.onSelfUpdate),this.components.events.removeEventListener("peer:connect",this.onPeersUpdate),this.components.events.removeEventListener("peer:disconnect",this.onPeersUpdate),this.components.events.removeEventListener("peer:identify",this.onPeersUpdate),this.components.events.removeEventListener("peer:update",this.onPeersUpdate),await Xf(this.simpleMetrics)}onIncomingMessage(e){if(e.source!==window)return;const t=e.data;"@libp2p/devtools-metrics:devtools"===t?.source&&"libp2p-rpc"===t.type&&this.rpcQueue.push(Vn.decode(t.message))}onPubSubMessage(e){this.devTools.safeDispatchEvent("pubsub:message",{detail:e.detail}).catch((e=>{this.log.error("error relaying pubsub message",e)}))}onPubSubSubscriptionChange(e){this.devTools.safeDispatchEvent("pubsub:subscription-change",{detail:e.detail}).catch((e=>{this.log.error("error relaying pubsub subscription change",e)}))}onSelfUpdate(){Promise.resolve().then((async()=>{await this.devTools.safeDispatchEvent("self",{detail:await rw(this.components)})})).catch((e=>{this.log.error("error sending peers message",e)}))}onPeersUpdate(){Promise.resolve().then((async()=>{await this.devTools.safeDispatchEvent("peers",{detail:await ew(this.components,this.log)})})).catch((e=>{this.log.error("error sending peers message",e)}))}}function iw(e){return t=>new sw(t,e)}const ow=Uint8Array.from([3,1]);var aw,cw;!function(e){let t,r;!function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={multiaddr:Xr(0)},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();t>>>3==1?n.multiaddr=e.bytes():e.skipType(7&t)}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(t=e.AddressInfo||(e.AddressInfo={})),e.codec=()=>(null==r&&(r=Rs(((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.peerId&&t.peerId.byteLength>0&&(r.uint32(10),r.bytes(t.peerId)),null!=t.seq&&0n!==t.seq&&(r.uint32(16),r.uint64(t.seq)),null!=t.addresses)for(const n of t.addresses)r.uint32(26),e.AddressInfo.codec().encode(n,r);!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={peerId:Xr(0),seq:0n,addresses:[]},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.peerId=t.bytes();break;case 2:s.seq=t.uint64();break;case 3:if(null!=n.limits?.addresses&&s.addresses.length===n.limits.addresses)throw new Bs('Decode error - map field "addresses" had too many elements');s.addresses.push(e.AddressInfo.codec().decode(t,t.uint32(),{limits:n.limits?.addresses$}));break;default:t.skipType(7&r)}}return s}))),r),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(aw||(aw={}));class lw{static createFromProtobuf=e=>{const t=aw.decode(e),r=rc(He(t.peerId)),n=(t.addresses??[]).map((e=>Ud(e.multiaddr))),s=t.seq;return new lw({peerId:r,multiaddrs:n,seqNumber:s})};static DOMAIN="libp2p-peer-record";static CODEC=ow;peerId;multiaddrs;seqNumber;domain=lw.DOMAIN;codec=lw.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:r,seqNumber:n}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=n??BigInt(Date.now())}marshal(){return null==this.marshaled&&(this.marshaled=aw.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map((e=>({multiaddr:e.bytes})))})),this.marshaled}equals(e){return e instanceof lw&&!!this.peerId.equals(e.peerId)&&this.seqNumber===e.seqNumber&&!!function(e,t){const r=(e,t)=>e.toString().localeCompare(t.toString());return e.length===t.length&&(t.sort(r),e.sort(r).every(((e,r)=>t[r].equals(e))))}(this.multiaddrs,e.multiaddrs)}}!function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.protocolVersion&&(t.uint32(42),t.string(e.protocolVersion)),null!=e.agentVersion&&(t.uint32(50),t.string(e.agentVersion)),null!=e.publicKey&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.listenAddrs)for(const r of e.listenAddrs)t.uint32(18),t.bytes(r);if(null!=e.observedAddr&&(t.uint32(34),t.bytes(e.observedAddr)),null!=e.protocols)for(const r of e.protocols)t.uint32(26),t.string(r);null!=e.signedPeerRecord&&(t.uint32(66),t.bytes(e.signedPeerRecord)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={listenAddrs:[],protocols:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 5:n.protocolVersion=e.string();break;case 6:n.agentVersion=e.string();break;case 1:n.publicKey=e.bytes();break;case 2:if(null!=r.limits?.listenAddrs&&n.listenAddrs.length===r.limits.listenAddrs)throw new Bs('Decode error - map field "listenAddrs" had too many elements');n.listenAddrs.push(e.bytes());break;case 4:n.observedAddr=e.bytes();break;case 3:if(null!=r.limits?.protocols&&n.protocols.length===r.limits.protocols)throw new Bs('Decode error - map field "protocols" had too many elements');n.protocols.push(e.string());break;case 8:n.signedPeerRecord=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(cw||(cw={}));var uw=r(4866);const hw="object"==typeof window&&"object"==typeof document&&9===document.nodeType,dw=uw(),pw=hw&&!dw,fw=dw&&!hw,gw=dw&&hw,mw=void 0!==globalThis.process&&void 0!==globalThis.process.release&&"node"===globalThis.process.release.name&&!dw,yw="function"==typeof importScripts&&"undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,ww=(void 0!==globalThis.process&&void 0!==globalThis.process.env&&globalThis.process.env.NODE_ENV,"undefined"!=typeof navigator&&"ReactNative"===navigator.product),bw="ipfs",vw=5e3,Sw=1,Ew=1,kw=10,Aw=8192,Iw=!0,_w=!0;class Cw{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){var r,n;this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??vw,this.maxInboundStreams=t.maxInboundStreams??Sw,this.maxOutboundStreams=t.maxOutboundStreams??Ew,this.maxMessageSize=t.maxMessageSize??Aw,this.maxObservedAddresses=t.maxObservedAddresses??kw,this.runOnLimitedConnection=t.runOnLimitedConnection??_w,this.host={protocolVersion:`${t.protocolPrefix??bw}/0.1.0`,agentVersion:(r=e.nodeInfo,n=t.agentVersion,null!=n||(n=`${r.name}/${r.version}`,mw||fw?n+=` UserAgent=${globalThis.process.version}`:(pw||yw||gw||ww)&&(n+=` UserAgent=${globalThis.navigator.userAgent}`)),n)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:ds(this.host.agentVersion),ProtocolVersion:ds(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,(e=>{this.handleProtocol(e).catch((e=>{this.log.error(e)}))}),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class xw extends Cw{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??bw}/id/1.0.0`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??Iw)&&e.events.addEventListener("connection:open",(e=>{const t=e.detail;this.identify(t).catch((e=>{e.name!==q.name&&this.log.error("error during identify trigged by connection:open",e)}))}))}[I]=["@libp2p/identify"];async _identify(e,t={}){let r;if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{r=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const n=Fd(r,{maxDataLength:this.maxMessageSize}).pb(cw),s=await n.read(t);return await r.close(t),s}catch(e){throw r?.abort(e),e}}async identify(e,t={}){const r=await this._identify(e,t),{publicKey:n,protocols:s,observedAddr:i}=r;if(null==n)throw new j("public key was missing from identify message");const o=nc(qa(n).toCID());if(!e.remotePeer.equals(o))throw new j("identified peer does not match the expected peer");if(this.peerId.equals(o))throw new j("identified peer is our own peer id?");return this.maybeAddObservedAddress(i),this.log("identify completed for peer %p and protocols %o",o,s),async function(e,t,r,n,s){if(r("received identify from %p",n.remotePeer),null==s)throw new j("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map((e=>({isCertified:!1,multiaddr:Ud(e)})))),s.protocols.length>0&&(i.protocols=s.protocols),null!=s.publicKey){const e=qa(s.publicKey);if(!tc(e).equals(n.remotePeer))throw new j("public key did not match remote PeerId");i.publicKey=e}let o;if(null!=s.signedPeerRecord){r.trace("received signedPeerRecord from %p",n.remotePeer);let t=s.signedPeerRecord;const a=await Ip.openAndCertify(t,lw.DOMAIN);let c=lw.createFromProtobuf(a.payload);const l=nc(a.publicKey.toCID());if(!c.peerId.equals(l))throw new j("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(c.peerId))throw new j("signing key does not match remote PeerId");let u;try{u=await e.get(c.peerId)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=u&&(i.metadata=u.metadata,null!=u.peerRecordEnvelope)){const e=await Ip.createFromProtobuf(u.peerRecordEnvelope),n=lw.createFromProtobuf(e.payload);n.seqNumber>=c.seqNumber&&(r("sequence number was lower or equal to existing sequence number - stored: %d received: %d",n.seqNumber,c.seqNumber),c=n,t=u.peerRecordEnvelope)}i.peerRecordEnvelope=t,i.addresses=c.multiaddrs.map((e=>({isCertified:!0,multiaddr:e}))),o={seq:c.seqNumber,addresses:c.multiaddrs}}else r("%p did not send a signed peer record",n.remotePeer);if(r.trace("patching %p with",n.remotePeer,i),await e.patch(n.remotePeer,i),null!=s.agentVersion||null!=s.protocolVersion){const t={};null!=s.agentVersion&&(t.AgentVersion=ds(s.agentVersion)),null!=s.protocolVersion&&(t.ProtocolVersion=ds(s.protocolVersion)),r.trace("merging %p metadata",n.remotePeer,t),await e.merge(n.remotePeer,{metadata:t})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map((e=>Ud(e))),observedAddr:null==s.observedAddr?void 0:Ud(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return t.safeDispatchEvent("peer:identify",{detail:a}),a}(this.peerStore,this.events,this.log,e,r)}maybeAddObservedAddress(e){const t=function(e){if(null!=e&&e.length>0)try{return Ud(e)}catch{}}(e);null!=t&&(this.log.trace("our observed address was %a",t),gd(t)?this.log.trace("our observed address was private"):41!==t.stringTuples()[0][0]||ud(t)?pf.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t)):this.log.trace("our observed address was IPv6 but not a global unicast address"))}async handleProtocol(e){const{connection:t,stream:r}=e,n=AbortSignal.timeout(this.timeout);try{const e=await this.peerStore.get(this.peerId),s=this.addressManager.getAddresses().map((e=>e.decapsulateCode(Fl("p2p").code)));let i=e.peerRecordEnvelope;if(s.length>0&&null==i){const e=new lw({peerId:this.peerId,multiaddrs:s});i=(await Ip.seal(e,this.privateKey)).marshal().subarray()}let o=t.remoteAddr.bytes;lf.matches(t.remoteAddr)||(o=void 0);const a=Fd(r).pb(cw);await a.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:ja(this.privateKey.publicKey),listenAddrs:s.map((e=>e.bytes)),signedPeerRecord:i,observedAddr:o,protocols:e.protocols},{signal:n}),await r.close({signal:n})}catch(e){this.log.error("could not respond to identify request",e),r.abort(e)}}}function Tw(e={}){return t=>new xw(t,e)}var Mw;!function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.publicKey&&e.publicKey.byteLength>0&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.addrs)for(const r of e.addrs)t.uint32(18),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={publicKey:Xr(0),addrs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.publicKey=e.bytes();break;case 2:if(null!=r.limits?.addrs&&n.addrs.length===r.limits.addrs)throw new Bs('Decode error - map field "addrs" had too many elements');n.addrs.push(e.bytes());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Mw||(Mw={}));class Pw extends b{[zd]=!0;[Symbol.toStringTag]="@libp2p/pubsub-peer-discovery";interval;listenOnly;topics;intervalId;components;log;constructor(e,t={}){super();const{interval:r,topics:n,listenOnly:s}=t;this.components=e,this.interval=r??1e4,this.listenOnly=s??!1,this.log=e.logger.forComponent("libp2p:discovery:pubsub"),Array.isArray(n)&&n.length>0?this.topics=n:this.topics=["_peer-discovery._p2p._pubsub"],this._onMessage=this._onMessage.bind(this)}isStarted(){return null!=this.intervalId}start(){}afterStart(){if(null!=this.intervalId)return;const e=this.components.pubsub;if(null==e)throw new Error("PubSub not configured");for(const t of this.topics)e.subscribe(t),e.addEventListener("message",this._onMessage);this.listenOnly||(this._broadcast(),this.intervalId=setInterval((()=>{this._broadcast()}),this.interval))}beforeStop(){const e=this.components.pubsub;if(null==e)throw new Error("PubSub not configured");for(const t of this.topics)e.unsubscribe(t),e.removeEventListener("message",this._onMessage)}stop(){null!=this.intervalId&&(clearInterval(this.intervalId),this.intervalId=void 0)}_broadcast(){const e=this.components.peerId;if(null==e.publicKey)throw new Error("PeerId was missing public key");const t={publicKey:ja(e.publicKey),addrs:this.components.addressManager.getAddresses().map((e=>e.bytes))},r=Mw.encode(t),n=this.components.pubsub;if(null==n)throw new Error("PubSub not configured");for(const e of this.topics)0!==n.getSubscribers(e).length?(this.log("broadcasting our peer data on topic %s",e),n.publish(e,r)):this.log("skipping broadcasting our peer data on topic %s because there are no peers present",e)}_onMessage(e){if(!this.isStarted())return;const t=e.detail;if(this.topics.includes(t.topic))try{const e=Mw.decode(t.data),r=tc(qa(e.publicKey));if(r.equals(this.components.peerId))return;this.log("discovered peer %p on %s",r,t.topic),this.safeDispatchEvent("peer",{detail:{id:r,multiaddrs:e.addrs.map((e=>Ud(e)))}})}catch(e){this.log.error("error handling incoming message",e)}}}var Dw=r(5606),Nw=function(e,t,r){if(r||2===arguments.length)for(var n,s=0,i=t.length;s<i;s++)!n&&s in t||(n||(n=Array.prototype.slice.call(t,0,s)),n[s]=t[s]);return e.concat(n||Array.prototype.slice.call(t))},Rw=function(e,t,r){this.name=e,this.version=t,this.os=r,this.type="browser"},Bw=function(e){this.version=e,this.type="node",this.name="node",this.os=Dw.platform},Lw=function(e,t,r,n){this.name=e,this.version=t,this.os=r,this.bot=n,this.type="bot-device"},Ow=function(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null},Uw=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Fw=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]],Vw=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function $w(e){var t=function(e){return""!==e&&Fw.reduce((function(t,r){var n=r[0],s=r[1];if(t)return t;var i=s.exec(e);return!!i&&[n,i]}),!1)}(e);if(!t)return null;var r=t[0],n=t[1];if("searchbot"===r)return new Ow;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<3&&(s=Nw(Nw([],s,!0),function(e){for(var t=[],r=0;r<e;r++)t.push("0");return t}(3-s.length),!0)):s=[];var i=s.join("."),o=function(e){for(var t=0,r=Vw.length;t<r;t++){var n=Vw[t],s=n[0];if(n[1].exec(e))return s}return null}(e),a=Uw.exec(e);return a&&a[1]?new Lw(r,i,o,a[1]):new Rw(r,i,o)}class Hw extends Error{constructor(e){super(e),this.name="TimeoutError"}}class zw extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const qw=e=>void 0===globalThis.DOMException?new zw(e):new DOMException(e),jw=e=>{const t=void 0===e.reason?qw("This operation was aborted."):e.reason;return t instanceof Error?t:qw(t)};function Ww(e,t){const{milliseconds:r,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=t;let o;const a=new Promise(((a,c)=>{if("number"!=typeof r||1!==Math.sign(r))throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${r}\``);if(t.signal){const{signal:r}=t;r.aborted&&c(jw(r));const n=()=>{c(jw(r))};r.addEventListener("abort",n,{once:!0}),e.finally((()=>{r.removeEventListener("abort",n)}))}if(r===Number.POSITIVE_INFINITY)return void e.then(a,c);const l=new Hw;o=i.setTimeout.call(void 0,(()=>{if(n)try{a(n())}catch(e){c(e)}else"function"==typeof e.cancel&&e.cancel(),!1===s?a():s instanceof Error?c(s):(l.message=s??`Promise timed out after ${r} milliseconds`,c(l))}),r),(async()=>{try{a(await e)}catch(e){c(e)}})()})).finally((()=>{a.clear()}));return a.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},a}const Kw=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"],Gw="undefined"==typeof document&&"undefined"!=typeof navigator&&"ReactNative"===navigator.product?new function(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}:"undefined"!=typeof navigator?$w(navigator.userAgent):void 0!==Dw&&Dw.version?new Bw(Dw.version.slice(1)):null;const Yw=null!=Gw&&"firefox"===Gw.name,Jw=async function*(){},Qw=async e=>{};async function Zw(e){return"function"==typeof(e=e??{})&&(e=await e()),e.iceServers=e.iceServers??Kw.map((e=>({urls:[e]}))),e}class Xw{log;peerConnection;remoteAddr;timeline;metrics;source=Jw();sink=Qw;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const r=this.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",this.peerConnection.connectionState,"initial state",r),"disconnected"!==this.peerConnection.connectionState&&"failed"!==this.peerConnection.connectionState&&"closed"!==this.peerConnection.connectionState||(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}function eb(e,t,r){"function"==typeof r&&(r={filter:r});const n=function(e,t,r){let n;const s=new Promise(((s,i)=>{if(!((r={rejectionEvents:["error"],multiArgs:!1,resolveImmediately:!1,...r}).count>=0)||r.count!==Number.POSITIVE_INFINITY&&!Number.isInteger(r.count))throw new TypeError("The `count` option should be at least 0 or more");r.signal?.throwIfAborted();const o=[t].flat(),a=[],{addListener:c,removeListener:l}=(e=>{const t=e.addEventListener||e.on||e.addListener,r=e.removeEventListener||e.off||e.removeListener;if(!t||!r)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(e),removeListener:r.bind(e)}})(e),u=(...e)=>{const t=r.multiArgs?e:e[0];r.filter&&!r.filter(t)||(a.push(t),r.count===a.length&&(n(),s(a)))},h=e=>{n(),i(e)};n=()=>{for(const e of o)l(e,u);for(const e of r.rejectionEvents)l(e,h)};for(const e of o)c(e,u);for(const e of r.rejectionEvents)c(e,h);r.signal&&r.signal.addEventListener("abort",(()=>{h(r.signal.reason)}),{once:!0}),r.resolveImmediately&&s(a)}));if(s.cancel=n,"number"==typeof r.timeout){const e=Ww(s,{milliseconds:r.timeout});return e.cancel=n,e}return s}(e,t,r={...r,count:1,resolveImmediately:!1}),s=n.then((e=>e[0]));return s.cancel=n.cancel,s}var tb;!function(e){let t,r,n;!function(e){e.FIN="FIN",e.STOP_SENDING="STOP_SENDING",e.RESET="RESET",e.FIN_ACK="FIN_ACK"}(t=e.Flag||(e.Flag={})),function(e){e[e.FIN=0]="FIN",e[e.STOP_SENDING=1]="STOP_SENDING",e[e.RESET=2]="RESET",e[e.FIN_ACK=3]="FIN_ACK"}(r||(r={})),function(e){e.codec=()=>Ns(r)}(t=e.Flag||(e.Flag={})),e.codec=()=>(null==n&&(n=Rs(((t,r,n={})=>{!1!==n.lengthDelimited&&r.fork(),null!=t.flag&&(r.uint32(8),e.Flag.codec().encode(t.flag,r)),null!=t.message&&(r.uint32(18),r.bytes(t.message)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.flag=e.Flag.codec().decode(t);break;case 2:s.message=t.bytes();break;default:t.skipType(7&r)}}return s}))),n),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(tb||(tb={}));const rb=function(e=16384){const t=hn(e-hn(e)),r=1+hn(Object.keys(tb.Flag).length-1);return t+r+1+hn(e-t-r-1)}();class nb extends Fh{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;constructor(e){const t=e.onEnd;switch(e.onEnd=e=>{this.log.trace("readable and writeable ends closed",this.status),Promise.resolve((async()=>{if(null==this.timeline.abort&&null===this.timeline.reset)try{await Ww(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(e){this.log.error("error receiving FIN_ACK",e)}})).then((()=>{this.incomingData.end(),t?.(e)})).catch((e=>{this.log.error("error ending stream",e)}))},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=kc(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??3e4,this.maxBufferedAmount=e.maxBufferedAmount??2097152,this.maxMessageSize=(e.maxMessageSize??16384)-rb,this.receiveFinAck=bc(),this.finAckTimeout=e.closeTimeout??5e3,this.openTimeout=e.openTimeout??5e3,this.channel.readyState){case"open":this.timeline.open=(new Date).getTime();break;case"closed":case"closing":void 0!==this.timeline.close&&0!==this.timeline.close||(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new U("Unknown datachannel state")}this.channel.onopen=e=>{this.timeline.open=(new Date).getTime()},this.channel.onclose=e=>{this.receiveFinAck.resolve(),this.close().catch((e=>{this.log.error("error closing stream after channel closed",e)}))},this.channel.onerror=e=>{const t=e.error;this.abort(t)},this.channel.onmessage=async e=>{const{data:t}=e;null!==t&&0!==t.byteLength&&this.incomingData.push(new Uint8Array(t,0,t.byteLength))};const r=this;Promise.resolve().then((async()=>{for await(const e of wc(this.incomingData)){const t=r.processIncomingProtobuf(e);null!=t&&r.sourcePush(new cc(t))}})).catch((e=>{this.log.error("error processing incoming data channel messages",e)}))}sendNewStream(){}async _sendMessage(e,t=!0){if(t&&this.channel.bufferedAmount>this.maxBufferedAmount)try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await eb(this.channel,"bufferedamountlow",{timeout:this.bufferedAmountLowEventTimeout})}catch(e){if(e instanceof W)throw new W(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`);throw e}if("closed"===this.channel.readyState||"closing"===this.channel.readyState)throw new U(`Invalid datachannel state - ${this.channel.readyState}`);"open"!==this.channel.readyState&&(this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await eb(this.channel,"open",{timeout:this.openTimeout}),this.log('channel state is now "%s", sending data',this.channel.readyState)),this.channel.send(e.subarray())}async sendData(e){for(e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxMessageSize),r=e.subarray(0,t),n=tb.encode({message:r}),s=hc.single(n);await this._sendMessage(s),e.consume(t)}}async sendReset(){try{await this._sendFlag(tb.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}}async sendCloseWrite(e){if(await this._sendFlag(tb.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await nu(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(e){this.log.error("failed to await FIN_ACK",e)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){await this._sendFlag(tb.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=tb.decode(e);if(void 0!==t.flag&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===tb.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(tb.Flag.FIN_ACK).catch((e=>{this.log.error("error sending FIN_ACK immediately",e)}))),t.flag===tb.Flag.RESET&&this.reset(),t.flag===tb.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===tb.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),"ready"===this.readStatus)return t.message}async _sendFlag(e){if("open"!==this.channel.readyState)return this.log.trace('not sending flag %s because channel is "%s" and not "open"',this.channel.readyState,e.toString()),!1;this.log.trace("sending flag %s",e.toString());const t=tb.encode({flag:e}),r=hc.single(t);try{return await this._sendMessage(r,!1),!0}catch(t){this.log.error("could not send flag %s - %e",e.toString(),t)}return!1}}function sb(e){const{channel:t,direction:r}=e;return new nb({id:"inbound"===r?`i${t.id}`:`r${t.id}`,log:e.logger.forComponent(`libp2p:webrtc:stream:${r}:${t.id}`),...e})}const ib="/webrtc";class ob{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??ib,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:datachannelmuxerfactory"),this.peerConnection.ondatachannel=({channel:t})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',t.id),"init"===t.label)return this.log.trace("closing early init channel"),void t.close();const r={},n=sb({channel:t,direction:"inbound",onEnd:e=>{r.onEnd(e)},logger:e.logger,...this.dataChannelOptions});r.stream=n,r.channel=t,r.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter((e=>e.stream.id!==n.id))},this.bufferedStreams.push(r)}}createStreamMuxer(e){return new ab(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class ab{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map((e=>e.stream)),this.peerConnection=t.peerConnection,this.protocol=t.protocol??ib,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:e})=>{if(this.log.trace("incoming datachannel with channel id %d",e.id),"init"===e.label)return this.log.trace("closing init channel"),void e.close();const r=e.id,n=sb({channel:e,direction:"inbound",onEnd:()=>{this.#c(n,e),this.log("incoming channel %s ended",r)},logger:this.logger,...this.dataChannelOptions});this.streams.push(n),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(n)},this.init.streams.length>0&&queueMicrotask((()=>{this.init.streams.forEach((e=>{e.onEnd=()=>{this.log("incoming early channel %s ended with state %s",e.channel.id,e.channel.readyState),this.#c(e.stream,e.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(e.stream)}))}))}#c(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),function(e,t,r=3e4,n){"open"===e.readyState&&Promise.resolve().then((async()=>{if(e.bufferedAmount>0){n.log("%s drain channel with %d buffered bytes",t,e.bufferedAmount);const s=bc();let i=!1;e.bufferedAmountLowThreshold=0;const o=()=>{i||(n.log("%s drain channel closed before drain",t),s.resolve())};e.addEventListener("close",o,{once:!0}),e.addEventListener("bufferedamountlow",(()=>{i=!0,e.removeEventListener("close",o),s.resolve()})),await Ww(s.promise,{milliseconds:r})}})).then((async()=>{"open"===e.readyState&&e.close()})).catch((e=>{n.log.error("error closing outbound stream",e)}))}(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter((t=>t.id!==e.id)),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map((async t=>t.close(e))))}catch(e){this.abort(e)}}abort(e){for(const t of this.streams)t.abort(e)}source=Jw();sink=Qw;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const r=sb({channel:e,direction:"outbound",onEnd:()=>{this.#c(r,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(r),this.metrics?.increment({outgoing_stream:!0}),r}}const cb=globalThis.RTCPeerConnection,lb=globalThis.RTCSessionDescription,ub=globalThis.RTCIceCandidate;class hb extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class db extends hb{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}class pb extends hb{constructor(e,t){super(`[stream: ${e}] data channel error: ${t}`),this.name="WebRTC/DataChannelError"}}class fb extends hb{constructor(e,t){super(`Invalid fingerprint "${e}" within ${t}`),this.name="WebRTC/InvalidFingerprintError"}}class gb extends hb{constructor(e){super(`A method (${e}) was called though it has been intentionally left unimplemented.`),this.name="WebRTC/UnimplementedError"}}class mb extends hb{constructor(e){super(`unsupported hash algorithm code: ${e} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `),this.name="WebRTC/UnsupportedHashAlgorithmError"}}var yb;!function(e){let t,r,n;!function(e){e.SDP_OFFER="SDP_OFFER",e.SDP_ANSWER="SDP_ANSWER",e.ICE_CANDIDATE="ICE_CANDIDATE"}(t=e.Type||(e.Type={})),function(e){e[e.SDP_OFFER=0]="SDP_OFFER",e[e.SDP_ANSWER=1]="SDP_ANSWER",e[e.ICE_CANDIDATE=2]="ICE_CANDIDATE"}(r||(r={})),function(e){e.codec=()=>Ns(r)}(t=e.Type||(e.Type={})),e.codec=()=>(null==n&&(n=Rs(((t,r,n={})=>{!1!==n.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.Type.codec().encode(t.type,r)),null!=t.data&&(r.uint32(18),r.string(t.data)),!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.type=e.Type.codec().decode(t);break;case 2:s.data=t.string();break;default:t.skipType(7&r)}}return s}))),n),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(yb||(yb={}));const wb=async(e,t,r)=>{try{const n=bc();for(function(e,t){e[Yw?"oniceconnectionstatechange":"onconnectionstatechange"]=r=>{switch(bb(e)){case"connected":t.resolve();break;case"failed":case"disconnected":case"closed":t.reject(new B("RTCPeerConnection was closed"))}}}(e,n);;){const s=await Promise.race([n.promise,t.read({signal:r.signal}).catch((()=>{}))]);if(null==s){r.signal?.throwIfAborted();break}if(s.type!==yb.Type.ICE_CANDIDATE)throw new j("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(""===i||null===i){r.onProgress?.(new ng("webrtc:end-of-ice-candidates")),r.log.trace("end-of-candidates received");continue}const o=new ub(i);r.log.trace("%s received new ICE candidate %o",r.direction,i);try{r.onProgress?.(new ng("webrtc:add-ice-candidate",o.candidate)),await e.addIceCandidate(o)}catch(e){r.log.error("%s bad candidate received",r.direction,i,e)}}}catch(t){if(r.log.error("%s error parsing ICE candidate",r.direction,t),!0===r.signal?.aborted&&"connected"!==bb(e))throw t}};function bb(e){return Yw?e.iceConnectionState:e.connectionState}const vb=Zp(Cf.matchers[0],qp("p2p-circuit"));class Sb extends b{transportManager;shutdownController;constructor(e,t){super(),this.transportManager=e.transportManager,this.shutdownController=t.shutdownController}async listen(){queueMicrotask((()=>{this.safeDispatchEvent("listening")}))}getAddrs(){return this.transportManager.getListeners().filter((e=>e!==this)).map((e=>e.getAddrs().filter((e=>vb.exactMatch(e))).map((e=>e.encapsulate("/webrtc"))))).flat()}async close(){this.shutdownController.abort(),queueMicrotask((()=>{this.safeDispatchEvent("close")}))}}const Eb="/webrtc",kb="/p2p-circuit",Ab="/webrtc-signaling/0.0.1";class Ib{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[Yf]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[I]=["@libp2p/transport"];[_]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(Ab,(e=>{this._onProtocol(e).catch((t=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,t)}))}),{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Ab),this._started=!1}createListener(e){return new Sb(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(Tf.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:r,peerConnection:n,muxerFactory:s}=await async function({rtcConfiguration:e,dataChannel:t,signal:r,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=function(e){const t=e.toString().split(Eb+"/");if(2!==t.length)throw new M("webrtc protocol was not present in multiaddr");if(!t[0].includes(kb))throw new M("p2p-circuit protocol was not present in multiaddr");let r=Ud(t[0]);const n=Ud("/"+t[1]).getPeerId();if(null==n)throw new M("destination peer id was missing");const s=r.protos().pop();if(void 0===s)throw new M("invalid multiaddr");return"p2p"!==s.name&&(r=r.encapsulate(`/p2p/${n}`)),{baseAddr:r,peerId:ec(n)}}(s);n?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const h=u.getPeerId();if(null==h)throw new M("Relay peer was missing");const d=i.getConnections(ec(h));let p,f=!1;0===d.length?(l?.(new ng("webrtc:dial-relay")),p=await o.dial(u,{signal:r,onProgress:l}),f=!0):(l?.(new ng("webrtc:reuse-relay-connection")),p=d[0]);try{l?.(new ng("webrtc:open-signaling-stream"));const n=await p.newStream(Ab,{signal:r,runOnLimitedConnection:!0}),i=Fd(n).pb(yb),o=new cb(e),u=new ob({logger:c},{peerConnection:o,dataChannelOptions:t});try{const e=o.createDataChannel("init");o.onicecandidate=({candidate:e})=>{const t=JSON.stringify(e?.toJSON()??null);a.trace("initiator sending ICE candidate %o",e),i.write({type:yb.Type.ICE_CANDIDATE,data:t},{signal:r}).catch((e=>{a.error("error sending ICE candidate",e)}))},o.onicecandidateerror=e=>{a.error("initiator ICE candidate error",e)};const t=await o.createOffer().catch((e=>{throw a.error("could not execute createOffer",e),new db("Failed to set createOffer")}));a.trace("initiator send SDP offer %s",t.sdp),l?.(new ng("webrtc:send-sdp-offer")),await i.write({type:yb.Type.SDP_OFFER,data:t.sdp},{signal:r}),await o.setLocalDescription(t).catch((e=>{throw a.error("could not execute setLocalDescription",e),new db("Failed to set localDescription")})),l?.(new ng("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const c=await i.read({signal:r});if(c.type!==yb.Type.SDP_ANSWER)throw new db("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",c.data);const h=new lb({type:"answer",sdp:c.data});return await o.setRemoteDescription(h).catch((e=>{throw a.error("could not execute setRemoteDescription",e),new db("Failed to set remoteDescription")})),a.trace("initiator read candidates until connected"),l?.(new ng("webrtc:read-ice-candidates")),await wb(o,i,{direction:"initiator",signal:r,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),e.close(),l?.(new ng("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await n.close({signal:r}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:o,muxerFactory:u}}catch(e){throw a.error("outgoing signaling error",e),o.close(),n.abort(e),e}finally{o.onicecandidate=null,o.onicecandidateerror=null}}finally{if(f)try{await p.close({signal:r})}catch(e){p.abort(e)}}}({rtcConfiguration:await Zw(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),i=new Xw(this.components,{peerConnection:n,timeline:{open:Date.now()},remoteAddr:r,metrics:this.metrics?.dialerEvents}),o=await t.upgrader.upgradeOutbound(i,{skipProtection:!0,skipEncryption:!0,muxerFactory:s,onProgress:t.onProgress});return this._closeOnShutdown(n,i),o}async _onProtocol({connection:e,stream:t}){const r=AbortSignal.timeout(this.init.inboundConnectionTimeout??3e4),n=new cb(await Zw(this.init.rtcConfiguration)),s=new ob(this.components,{peerConnection:n,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:i}=await async function({peerConnection:e,stream:t,signal:r,connection:n,log:s}){s.trace("new inbound signaling stream");const i=Fd(t).pb(yb);try{e.onicecandidate=({candidate:e})=>{const t=JSON.stringify(e?.toJSON()??null);s.trace("recipient sending ICE candidate %s",t),i.write({type:yb.Type.ICE_CANDIDATE,data:t},{signal:r}).catch((e=>{s.error("error sending ICE candidate",e)}))},s.trace("recipient read SDP offer");const t=await i.read({signal:r});if(t.type!==yb.Type.SDP_OFFER)throw new db(`expected message type SDP_OFFER, received: ${t.type??"undefined"} `);s.trace("recipient received SDP offer %s",t.data);const n=new lb({type:"offer",sdp:t.data});await e.setRemoteDescription(n).catch((e=>{throw s.error("could not execute setRemoteDescription",e),new db("Failed to set remoteDescription")}));const o=await e.createAnswer().catch((e=>{throw s.error("could not execute createAnswer",e),new db("Failed to create answer")}));s.trace("recipient send SDP answer %s",o.sdp),await i.write({type:yb.Type.SDP_ANSWER,data:o.sdp},{signal:r}),await e.setLocalDescription(o).catch((e=>{throw s.error("could not execute setLocalDescription",e),new db("Failed to set localDescription")})),s.trace("recipient read candidates until connected"),await wb(e,i,{direction:"recipient",signal:r,log:s})}catch(t){if("connected"!==bb(e))throw s.error("error while handling signaling stream from peer %a",n.remoteAddr,t),e.close(),t;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",n.remoteAddr,t)}const o=Ud(`/webrtc/p2p/${n.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}({peerConnection:n,connection:e,stream:t,signal:r,log:this.log});await t.close({signal:r});const o=new Xw(this.components,{peerConnection:n,timeline:{open:(new Date).getTime()},remoteAddr:i,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(o,{skipEncryption:!0,skipProtection:!0,muxerFactory:s}),this._closeOnShutdown(n,o)}catch(e){throw this.log.error("incoming signaling error",e),n.close(),t.abort(e),e}}_closeOnShutdown(e,t){const r=()=>{t.close().catch((e=>{this.log.error("could not close WebRTCMultiaddrConnection",e)}))};this.shutdownController.signal.addEventListener("abort",r),e.addEventListener("close",(()=>{this.shutdownController.signal.removeEventListener("abort",r)}))}}const _b=Object.values(as).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)));const Cb=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function xb(e){const t=e.stringTuples().filter((e=>e[0]===Nb)).map((e=>e[1]))[0];if(void 0===t||""===t)throw new M(`Couldn't find a certhash component of multiaddr: ${e.toString()}`);return t}function Tb(e){return He(_b.decode(e))}function Mb(e){switch(e){case 17:return"SHA-1";case 18:return"SHA-256";case 19:return"SHA-512";default:throw new mb(e)}}function Pb(e,t){const{host:r,port:n}=e.toOptions(),s=function(e){for(const t of e.protoNames())if(t.startsWith("ip"))return t.toUpperCase();return"IP6"}(e),[i]=function(e){const t=Tb(xb(e)),r=Mb(t.code),n=t.digest.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),s=n.match(/.{1,2}/g);if(null==s)throw new fb(n,e.toString());return[`${r} ${s.join(":").toUpperCase()}`,n]}(e);return`v=0\no=- 0 0 IN ${s} ${r}\ns=-\nc=IN ${s} ${r}\nt=0 0\na=ice-lite\nm=application ${n} UDP/DTLS/SCTP webrtc-datachannel\na=mid:0\na=setup:passive\na=ice-ufrag:${t}\na=ice-pwd:${t}\na=fingerprint:${i}\na=sctp-port:5000\na=max-message-size:16384\na=candidate:1467250027 1 UDP 1467250027 ${r} ${n} typ host\r\n`}const Db=Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),Nb=(Fl("webrtc-direct").code,Fl("certhash").code);class Rb{log;metrics;components;init;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:webrtc-direct"),this.components=e,this.init=t,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total",{label:"event",help:"Total count of WebRTC-direct dial events by type"})})}[Yf]=!0;[Symbol.toStringTag]="@libp2p/webrtc-direct";[I]=["@libp2p/transport"];async dial(e,t){const r=await this._connect(e,t);return this.log("dialing address: %a",e),r}createListener(e){throw new gb("WebRTCTransport.createListener")}listenFilter(e){return e.filter(kf.exactMatch)}dialFilter(e){return this.listenFilter(e)}async _connect(e,t){const r=new AbortController,n=r.signal;let s;const i=e.getPeerId();null!=i&&(s=ec(i));const o=Tb(xb(e)),a=await cb.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:Mb(o.code)}),c=new cb({...await Zw(this.init.rtcConfiguration),certificates:[a]});try{const i=new Promise(((e,t)=>{const r=c.createDataChannel("",{negotiated:!0,id:0}),n=setTimeout((()=>{const e=`Data channel was never opened: state: ${r.readyState}`;this.log.error(e),this.metrics?.dialerEvents.increment({open_error:!0}),t(new pb("data",e))}),1e4);r.onopen=t=>{clearTimeout(n),e(r)},r.onerror=e=>{clearTimeout(n);const r=`Error opening a data channel for handshaking: ${e.target?.toString()??"not specified"}`;this.log.error(r),this.metrics?.dialerEvents.increment({unknown_error:!0}),t(new pb("data",r))}})),a="libp2p+webrtc+v1/"+[...Array(32)].map((()=>Db.at(Math.floor(Math.random()*Db.length)))).join(""),l=function(e,t){if(void 0===e.sdp)throw new M("Can't munge a missing SDP");return e.sdp=e.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,"\na=ice-ufrag:"+t+"\n").replace(/\na=ice-pwd:[^\n]*\n/,"\na=ice-pwd:"+t+"\n"),e}(await c.createOffer(),a);await c.setLocalDescription(l);const u=function(e,t){return{type:"answer",sdp:Pb(e,t)}}(e,a);await c.setRemoteDescription(u);const h=await i,d=bh({prologueBytes:this.generateNoisePrologue(c,o.code,e)})(this.components),p=sb({channel:h,direction:"inbound",logger:this.components.logger,...this.init.dataChannel??{}}),f={...p,sink:p.sink.bind(p),source:async function*(){for await(const e of p.source)for(const t of e)yield t}()},g=new Xw(this.components,{peerConnection:c,remoteAddr:e,timeline:{open:Date.now()},metrics:this.metrics?.dialerEvents}),m=Yw?"iceconnectionstatechange":"connectionstatechange";c.addEventListener(m,(()=>{switch(c.connectionState){case"failed":case"disconnected":case"closed":g.close().catch((e=>{this.log.error("error closing connection",e)})).finally((()=>{r.abort()}))}}),{signal:n}),this.metrics?.dialerEvents.increment({peer_connection:!0});const y=new ob(this.components,{peerConnection:c,metrics:this.metrics?.dialerEvents,dataChannelOptions:this.init.dataChannel});return await d.secureInbound(f,{signal:n,remotePeer:s}),await t.upgrader.upgradeOutbound(g,{skipProtection:!0,skipEncryption:!0,muxerFactory:y})}catch(e){throw c.close(),e}}generateNoisePrologue(e,t,r){if(0===e.getConfiguration().certificates?.length)throw new M("no local certificate");const n=function(e,t){const r=e.getConfiguration().certificates?.at(0);if(null==r?.getFingerprints){t.log.trace("fetching fingerprint from local SDP");const r=e.localDescription;if(null==r)return;return function(e){const t=e.match(Cb);return t?.groups?.fingerprint}(r.sdp)}if(t.log.trace("fetching fingerprint from local certificate"),0===r.getFingerprints().length)return;const n=r.getFingerprints()[0].value;if(null==n)throw new fb("","no fingerprint on local certificate");return n}(e,{log:this.log});if(null==n)throw new M("no local fingerprint found");const s=$e(t,ds(n.trim().toLowerCase().replaceAll(":",""),"hex")),i=_b.decode(xb(r));return sc([ds("libp2p-webrtc-noise:"),s.bytes,i])}}function Bb(e){return t=>new Rb(t,e)}function Lb(e){return t=>new Ib(t,e)}const Ob=[Fl("tcp").code,Fl("dns").code,Fl("dnsaddr").code,Fl("dns4").code,Fl("dns6").code];function Ub(e){return Vb("sni",e)?.[1]}function Fb(e){const t=Vb("tcp",e)?.[1];return null==t?"":`:${t}`}function Vb(e,t){let r;try{r=Fl(e).code}catch(e){return}for(const[e,n]of t)if(e===r&&null!=n)return[e,n]}function $b(e){return e.some((([e,t])=>e===Fl("tls").code))}function Hb(e,t,r){const n=zb[Fl(e).name];if(null==n)throw new Error(`Can't interpret protocol ${Fl(e).name}`);const s=n(t,r);return e===Fl("ip6").code?`[${s}]`:s}const zb={ip4:(e,t)=>e,ip6:(e,t)=>0===t.length?e:`[${e}]`,tcp:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");return`tcp://${Hb(r[0],r[1]??"",t)}:${e}`},udp:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");return`udp://${Hb(r[0],r[1]??"",t)}:${e}`},dnsaddr:(e,t)=>e,dns4:(e,t)=>e,dns6:(e,t)=>e,dns:(e,t)=>e,ipfs:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");return`${Hb(r[0],r[1]??"",t)}`},p2p:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");return`${Hb(r[0],r[1]??"",t)}`},http:(e,t)=>{const r=$b(t),n=Ub(t),s=Fb(t);if(r&&null!=n)return`https://${n}${s}`;const i=r?"https://":"http://",o=t.pop();if(null==o)throw new Error("Unexpected end of multiaddr");let a=Hb(o[0],o[1]??"",t);return a=a.replace("tcp://",""),`${i}${a}`},"http-path":(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");return`${Hb(r[0],r[1]??"",t)}/${decodeURIComponent(e)}`},tls:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");return Hb(r[0],r[1]??"",t)},sni:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");return Hb(r[0],r[1]??"",t)},https:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");let n=Hb(r[0],r[1]??"",t);return n=n.replace("tcp://",""),`https://${n}`},ws:(e,t)=>{const r=$b(t),n=Ub(t),s=Fb(t);if(r&&null!=n)return`wss://${n}${s}`;const i=r?"wss://":"ws://",o=t.pop();if(null==o)throw new Error("Unexpected end of multiaddr");let a=Hb(o[0],o[1]??"",t);return a=a.replace("tcp://",""),`${i}${a}`},wss:(e,t)=>{const r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");let n=Hb(r[0],r[1]??"",t);return n=n.replace("tcp://",""),`wss://${n}`}},qb=async e=>{if(e.readyState>=2)throw new Error("socket closed");1!==e.readyState&&await new Promise(((t,r)=>{function n(){e.removeEventListener("open",s),e.removeEventListener("error",i)}function s(){n(),t()}function i(t){n(),r(t.error??new Error(`connect ECONNREFUSED ${e.url}`))}e.addEventListener("open",s),e.addEventListener("error",i)}))},jb=(e,t)=>((t=t??{}).closeOnEnd=!1!==t.closeOnEnd,async r=>{for await(const t of r){try{await qb(e)}catch(e){if("socket closed"===e.message)break;throw e}if(e.readyState===e.CLOSING||e.readyState===e.CLOSED)break;e.send(t)}null!=t.closeOnEnd&&e.readyState<=1&&await new Promise(((t,r)=>{e.addEventListener("close",(e=>{if(e.wasClean||1006===e.code)t();else{const t=Object.assign(new Error("ws error"),{event:e});r(t)}})),setTimeout((()=>{e.close()}))}))});var Wb=r(544);function Kb(e){return e instanceof ArrayBuffer||"ArrayBuffer"===e?.constructor?.name&&"number"==typeof e?.byteLength}const Gb=WebSocket,Yb={"http:":"ws:","https:":"wss:"};function Jb(e,t){t=t??{};const r=((e,t)=>{if(e.startsWith("//")&&(e=`${t?.protocol??"ws:"}${e}`),e.startsWith("/")&&null!=t){const r=t.protocol??"ws:",n=t.host,s=null!=t.port&&!0!==n?.endsWith(`:${t.port}`)?`:${t.port}`:"";e=`${r}//${n}${s}${e}`}const r=new URL(e);for(const[e,t]of Object.entries(Yb))r.protocol===e&&(r.protocol=t);return r})(e,"undefined"==typeof window?void 0:window.location);return((e,t)=>{t=t??{};const r=(e=>{e.binaryType="arraybuffer";const t=async()=>{await new Promise(((t,r)=>{if(s)return void t();if(null!=n)return void r(n);const i=t=>{e.removeEventListener("open",o),e.removeEventListener("error",a),t()},o=()=>{i(t)},a=t=>{i((()=>{r(t.error??new Error(`connect ECONNREFUSED ${e.url}`))}))};e.addEventListener("open",o),e.addEventListener("error",a)}))},r=async function*(){const r=new Wb.PP((({push:t,stop:r,fail:n})=>{const s=e=>{let r=null;"string"==typeof e.data&&(r=ds(e.data)),Kb(e.data)&&(r=new Uint8Array(e.data)),e.data instanceof Uint8Array&&(r=e.data),null!=r&&t(r)},i=e=>{n(e.error??new Error("Socket error"))};return e.addEventListener("message",s),e.addEventListener("error",i),e.addEventListener("close",r),()=>{e.removeEventListener("message",s),e.removeEventListener("error",i),e.removeEventListener("close",r)}}),{highWaterMark:1/0});await t();for await(const e of r)yield Kb(e)?new Uint8Array(e):e}();let n,s=1===e.readyState;return e.addEventListener("open",(()=>{s=!0,n=null})),e.addEventListener("close",(()=>{s=!1,n=null})),e.addEventListener("error",(t=>{s||(n=t.error??new Error(`connect ECONNREFUSED ${e.url}`))})),Object.assign(r,{connected:t})})(e);let n=t.remoteAddress,s=t.remotePort;if(null!=e.url)try{const t=new URL(e.url);n=t.hostname,s=parseInt(t.port,10)}catch{}if(null==n||null==s)throw new Error("Remote connection did not have address and/or port");return{sink:jb(e,t),source:r,connected:async()=>{await r.connected()},close:async()=>{e.readyState!==e.CONNECTING&&e.readyState!==e.OPEN||await new Promise((t=>{e.addEventListener("close",(()=>{t()})),e.close()}))},destroy:()=>{null!=e.terminate?e.terminate():e.close()},remoteAddress:n,remotePort:s,socket:e}})(new Gb(r.toString(),t.websocket),t)}function Qb(e){return e.filter((e=>Sf.exactMatch(e)||bf.exactMatch(e)))}class Zb{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[Yf]=!0;[Symbol.toStringTag]="@libp2p/websockets";[I]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const r=function(e,t,r){const n=r.logger.forComponent("libp2p:websockets:maconn"),s=r.metrics,i=r.metricPrefix??"",o={log:n,async sink(t){try{await e.sink(async function*(){for await(const e of t)e instanceof Uint8Array?yield e:yield e.subarray()}())}catch(e){"aborted"!==e.type&&n.error(e)}},source:e.source,remoteAddr:t,timeline:{open:Date.now()},async close(t={}){const r=Date.now();if(null==t.signal){const e=AbortSignal.timeout(500);t={...t,signal:e}}const s=()=>{const{host:e,port:t}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",e,t,Date.now()-r),this.abort(new C("Socket close timeout"))};t.signal?.addEventListener("abort",s);try{await e.close()}catch(e){n.error("error closing WebSocket gracefully",e),this.abort(e)}finally{t.signal?.removeEventListener("abort",s),o.timeline.close=Date.now()}},abort(t){const{host:r,port:a}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",r,a,t),e.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return e.socket.addEventListener("close",(()=>{s?.increment({[`${i}close`]:!0}),null==o.timeline.close&&(o.timeline.close=Date.now())}),{once:!0}),o}(await this._connect(e,t),e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",r.remoteAddr);const n=await t.upgrader.upgradeOutbound(r,t);return this.log("outbound connection %s upgraded",r.remoteAddr),n}async _connect(e,t){t?.signal?.throwIfAborted();const r=e.toOptions();this.log("dialing %s:%s",r.host,r.port);const n=bc(),s=Jb(function(e){const t=Ud(e).stringTuples(),r=t.pop();if(null==r)throw new Error("Unexpected end of multiaddr");const n=Fl(r[0]),s=zb[n.name];if(null==s)throw new Error(`No interpreter found for ${n.name}`);let i=s(r[1]??"",t);return Ob.includes(r[0])&&(i=i.replace(/^.*:\/\//,""),i="443"===r[1]?`https://${i}`:`http://${i}`),(i.startsWith("http://")||i.startsWith("https://")||i.startsWith("ws://")||i.startsWith("wss://"))&&(i=new URL(i).toString(),i.endsWith("/")&&(i=i.substring(0,i.length-1))),i}(e),this.init);s.socket.addEventListener("error",(()=>{const t=new B(`Could not connect to ${e.toString()}`);this.log.error("connection error:",t),this.metrics?.dialerEvents.increment({error:!0}),n.reject(t)}));try{t.onProgress?.(new ng("websockets:open-connection")),await nu(Promise.race([s.connected(),n.promise]),t.signal)}catch(e){throw!0===t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),s.close().catch((e=>{this.log.error("error closing raw socket",e)})),e}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),s}createListener(e){return function(){throw new Error("WebSocket Servers can not be created in the browser!")}((this.logger,this.components.events,this.components.metrics),this.init)}listenFilter(e){return e=Array.isArray(e)?e:[e],null!=this.init?.filter?this.init?.filter(e):Qb(e)}dialFilter(e){return this.listenFilter(e)}}function Xb(e={}){return t=>new Zb(t,e)}class ev extends Fh{writer;reader;constructor(e){super(e),this.writer=e.bidiStream.writable.getWriter(),this.reader=e.bidiStream.readable.getReader(),Promise.resolve().then((async()=>{for(;;){const t=await this.reader.read();if(t.done)return void e.log("remote closed write");null!=t.value&&this.sourcePush(new cc(t.value))}})).catch((t=>{e.log.error("error reading from stream",t),this.abort(t)})).finally((()=>{this.remoteCloseWrite()})),this.writer.closed.then((()=>{e.log("writer closed")})).catch((t=>{e.log("writer close promise rejected",t)})).finally((()=>{this.remoteCloseRead()}))}sendNewStream(e){}async sendData(e,t){for await(const r of e)this.log("sendData waiting for writer to be ready"),await nu(this.writer.ready,t?.signal),this.writer.write(r).catch((e=>{this.log.error("error sending stream data",e)}))}async sendReset(e){this.log("sendReset aborting writer"),await nu(this.writer.abort(),e?.signal),this.log("sendReset aborted writer")}async sendCloseWrite(e){this.log("sendCloseWrite closing writer"),await nu(this.writer.close(),e?.signal),this.log("sendCloseWrite closed writer")}async sendCloseRead(e){this.log("sendCloseRead cancelling reader"),await nu(this.reader.cancel(),e?.signal),this.log("sendCloseRead cancelled reader")}}async function tv(e,t,r,n,s,i){const o=i.forComponent(`libp2p:webtransport:stream:${r}:${t}`),a=new ev({bidiStream:e,id:t,direction:r,log:o,onEnd:()=>{const e=n.findIndex((e=>e===a));-1!==e&&n.splice(e,1),s?.(a)}});return a}function rv(){return{source:{[Symbol.asyncIterator]:()=>({next:async()=>new Promise((()=>{}))})},sink:async e=>new Promise((()=>{}))}}function nv(e,t,r,n){let s=0;const i=r.forComponent("libp2p:webtransport:muxer");return{protocol:"webtransport",createStreamMuxer:o=>{"function"==typeof o&&(o={onIncomingStream:o});const a=[];Promise.resolve().then((async()=>{for(;;){const{done:e,value:c}=await t.read();if(e)break;if(a.length>=n.maxInboundStreams)i(`too many inbound streams open - ${a.length}/${n.maxInboundStreams}, closing new incoming stream`),c.writable.close().catch((e=>{i.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${e.message}`)})),c.readable.cancel().catch((e=>{i.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${e.message}`)}));else{const e=await tv(c,String(s++),"inbound",a,o?.onStreamEnd,r);a.push(e),o?.onIncomingStream?.(e)}}})).catch((e=>{i.error("could not create a new stream",e)}));const c={protocol:"webtransport",streams:a,newStream:async t=>{i("new outgoing stream",t);const n=await e.createBidirectionalStream(),c=await tv(n,String(s++),o?.direction??"outbound",a,o?.onStreamEnd,r);return a.push(c),c},close:async()=>{i("closing webtransport muxer gracefully");try{e.close()}catch(e){c.abort(e)}},abort:t=>{i("closing webtransport muxer with err:",t);try{e.close()}catch(t){i.error("webtransport session threw error during close",t)}},...rv()};return c}}}const sv=Object.values(as).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)));function iv(e){if(!If.matches(e))throw new $("Invalid multiaddr, was not a WebTransport address");const t=e.stringTuples(),r=t.filter((([e,t])=>e===Fl("certhash").code)).map((([e,t])=>function(e){return He(sv.decode(e))}(t??""))),n=t.filter((([e,t])=>e===Fl("p2p").code)).map((([e,t])=>ec(t??"")))[0],s=e.toOptions();let i=s.host;return 6===s.family&&i?.includes(":")&&(i=`[${i}]`),{url:`https://${i}:${s.port}`,certhashes:r,remotePeer:n}}const ov=globalThis.WebTransport;class av{log;components;config;metrics;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:webtransport"),this.components=e,this.config={...t,maxInboundStreams:t.maxInboundStreams??1e3,certificates:t.certificates??[]},null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total",{label:"event",help:"Total count of WebTransport dialer events by type"})})}[Symbol.toStringTag]="@libp2p/webtransport";[Yf]=!0;[I]=["@libp2p/transport"];async dial(e,t){t?.signal?.throwIfAborted(),this.log("dialing %s",e),t=t??{};const{url:r,certhashes:n,remotePeer:s}=iv(e);let i,o,a=()=>{},c=!1,l=!1,u=!1;try{this.metrics?.dialerEvents.increment({pending:!0});const h=new ov(`${r}/.well-known/libp2p-webtransport?type=noise`,{serverCertificateHashes:n.map((e=>({algorithm:"sha-256",value:e.digest})))});if(a=e=>{if(!c)try{this.metrics?.dialerEvents.increment({[e]:!0}),h.close()}catch(e){this.log.error("error closing wt session",e)}finally{null!=o&&(o.timeline.close=Date.now()),c=!0}},i=()=>{a(l?"noise_timeout":"ready_timeout")},t.signal?.addEventListener("abort",i,{once:!0}),this.log("wait for session to be ready"),t.onProgress?.(new ng("webtransport:wait-for-session")),await Promise.race([h.closed,h.ready]),this.log("session became ready"),l=!0,this.metrics?.dialerEvents.increment({ready:!0}),h.closed.catch((e=>{this.log.error("error on remote wt session close",e)})).finally((()=>{a("remote_close")})),u=await nu(this.authenticateWebTransport({wt:h,remotePeer:s,certhashes:n,...t}),t.signal),!u)throw new T("Failed to authenticate webtransport");return this.metrics?.dialerEvents.increment({open:!0}),o={close:async()=>{this.log("closing webtransport"),a("close")},abort:e=>{this.log("aborting webtransport due to passed err",e),a("abort")},remoteAddr:e,timeline:{open:Date.now()},log:this.components.logger.forComponent("libp2p:webtransport:maconn"),...rv()},await t.upgrader.upgradeOutbound(o,{skipEncryption:!0,muxerFactory:nv(h,h.incomingBidirectionalStreams.getReader(),this.components.logger,this.config),skipProtection:!0,onProgress:t.onProgress})}catch(e){throw this.log.error("caught wt session err",e),a(u?"upgrade_error":l?"noise_error":"ready_error"),e}finally{null!=i&&t.signal?.removeEventListener("abort",i)}}async authenticateWebTransport({wt:e,remotePeer:t,certhashes:r,onProgress:n,signal:s}){s?.throwIfAborted(),n?.(new ng("webtransport:open-authentication-stream"));const i=await e.createBidirectionalStream(),o=i.writable.getWriter(),a=i.readable.getReader(),c={source:async function*(){for(;;){const e=await a.read();if(null!=e.value&&(yield e.value),e.done)break}}(),sink:async e=>{for await(const t of e){await nu(o.ready,s);const e=t instanceof Uint8Array?t:t.subarray();o.write(e).catch((e=>{this.log.error("could not write chunk during authentication of WebTransport stream",e)}))}}},l=bh()(this.components);n?.(new ng("webtransport:secure-outbound-connection"));const{remoteExtensions:u}=await l.secureOutbound(c,{signal:s,remotePeer:t});if(n?.(new ng("webtransport:close-authentication-stream")),o.close().catch((e=>{this.log.error(`Failed to close authentication stream writer: ${e.message}`)})),a.cancel().catch((e=>{this.log.error(`Failed to close authentication stream reader: ${e.message}`)})),h=u?.webtransportCerthashes??[],(d=r.map((e=>e.bytes))).filter((e=>Boolean(h.find((t=>et(e,t)))))).length!==d.length)throw new M("Our certhashes are not a subset of the remote's reported certhashes");var h,d;return!0}createListener(e){return function(){throw new Error("Not implemented")}(this.components,(this.config.certificates,this.config.maxInboundStreams))}listenFilter(){return[]}dialFilter(e){return null==globalThis.WebTransport?[]:e.filter((e=>{if(!If.exactMatch(e))return!1;const{url:t,certhashes:r}=iv(e);return null!=t&&r.length>0}))}}function cv(e={}){return t=>new av(t,e)}var lv=r(228);class uv{#l=[];enqueue(e,t){const r={priority:(t={priority:0,...t}).priority,run:e};if(this.size&&this.#l[this.size-1].priority>=t.priority)return void this.#l.push(r);const n=function(e,t){let r=0,n=e.length;for(;n>0;){const i=Math.trunc(n/2);let o=r+i;s=e[o],t.priority-s.priority<=0?(r=++o,n-=i+1):n=i}var s;return r}(this.#l,r);this.#l.splice(n,0,r)}dequeue(){const e=this.#l.shift();return e?.run}filter(e){return this.#l.filter((t=>t.priority===e.priority)).map((e=>e.run))}get size(){return this.#l.length}}class hv extends lv{#u;#h;#d=0;#p;#f;#g=0;#m;#y;#l;#w;#b=0;#v;#S;#E;timeout;constructor(e){if(super(),!("number"==typeof(e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:uv,...e}).intervalCap&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(void 0===e.interval||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#u=e.carryoverConcurrencyCount,this.#h=e.intervalCap===Number.POSITIVE_INFINITY||0===e.interval,this.#p=e.intervalCap,this.#f=e.interval,this.#l=new e.queueClass,this.#w=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#E=!0===e.throwOnTimeout,this.#S=!1===e.autoStart}get#k(){return this.#h||this.#d<this.#p}get#A(){return this.#b<this.#v}#I(){this.#b--,this.#_(),this.emit("next")}#C(){this.#x(),this.#T(),this.#y=void 0}get#M(){const e=Date.now();if(void 0===this.#m){const t=this.#g-e;if(!(t<0))return void 0===this.#y&&(this.#y=setTimeout((()=>{this.#C()}),t)),!0;this.#d=this.#u?this.#b:0}return!1}#_(){if(0===this.#l.size)return this.#m&&clearInterval(this.#m),this.#m=void 0,this.emit("empty"),0===this.#b&&this.emit("idle"),!1;if(!this.#S){const e=!this.#M;if(this.#k&&this.#A){const t=this.#l.dequeue();return!!t&&(this.emit("active"),t(),e&&this.#T(),!0)}}return!1}#T(){this.#h||void 0!==this.#m||(this.#m=setInterval((()=>{this.#x()}),this.#f),this.#g=Date.now()+this.#f)}#x(){0===this.#d&&0===this.#b&&this.#m&&(clearInterval(this.#m),this.#m=void 0),this.#d=this.#u?this.#b:0,this.#P()}#P(){for(;this.#_(););}get concurrency(){return this.#v}set concurrency(e){if(!("number"==typeof e&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#v=e,this.#P()}async#D(e){return new Promise(((t,r)=>{e.addEventListener("abort",(()=>{r(e.reason)}),{once:!0})}))}async add(e,t={}){return t={timeout:this.timeout,throwOnTimeout:this.#E,...t},new Promise(((r,n)=>{this.#l.enqueue((async()=>{this.#b++,this.#d++;try{t.signal?.throwIfAborted();let n=e({signal:t.signal});t.timeout&&(n=Ww(Promise.resolve(n),{milliseconds:t.timeout})),t.signal&&(n=Promise.race([n,this.#D(t.signal)]));const s=await n;r(s),this.emit("completed",s)}catch(e){if(e instanceof Hw&&!t.throwOnTimeout)return void r();n(e),this.emit("error",e)}finally{this.#I()}}),t),this.emit("add"),this.#_()}))}async addAll(e,t){return Promise.all(e.map((async e=>this.add(e,t))))}start(){return this.#S?(this.#S=!1,this.#P(),this):this}pause(){this.#S=!0}clear(){this.#l=new this.#w}async onEmpty(){0!==this.#l.size&&await this.#N("empty")}async onSizeLessThan(e){this.#l.size<e||await this.#N("next",(()=>this.#l.size<e))}async onIdle(){0===this.#b&&0===this.#l.size||await this.#N("idle")}async#N(e,t){return new Promise((r=>{const n=()=>{t&&!t()||(this.off(e,n),r())};this.on(e,n)}))}get size(){return this.#l.size}sizeBy(e){return this.#l.filter(e).length}get pending(){return this.#b}get isPaused(){return this.#S}}function dv(e){const t=[gv.A];return null==e?t:Array.isArray(e)?0===e.length?t:e:[e]}function pv(e){return{Status:e.Status??0,TC:e.TC??e.flag_tc??!1,RD:e.RD??e.flag_rd??!1,RA:e.RA??e.flag_ra??!1,AD:e.AD??e.flag_ad??!1,CD:e.CD??e.flag_cd??!1,Question:(e.Question??e.questions??[]).map((e=>({name:e.name,type:gv[e.type]}))),Answer:(e.Answer??e.answers??[]).map((e=>({name:e.name,type:gv[e.type],TTL:e.TTL??e.ttl??60,data:e.data instanceof Uint8Array?ia(e.data):e.data})))}}function fv(e,t={}){const r=new hv({concurrency:t.queryConcurrency??4});return async(t,n={})=>{const s=new URLSearchParams;s.set("name",t),dv(n.types).forEach((e=>{s.append("type",gv[e])})),n.onProgress?.(new ng("dns:query",{detail:t}));const i=await r.add((async()=>{const t=await fetch(`${e}?${s}`,{headers:{accept:"application/dns-json"},signal:n?.signal});if(200!==t.status)throw new Error(`Unexpected HTTP status: ${t.status} - ${t.statusText}`);const r=pv(await t.json());return n.onProgress?.(new ng("dns:response",{detail:r})),r}),{signal:n.signal});if(null==i)throw new Error("No DNS response received");return i}}var gv,mv=r(194);class yv{lru;constructor(e){this.lru=mv(e)}get(e,t){let r=!0;const n=[];for(const s of t){const t=this.getAnswers(e,s);if(0===t.length){r=!1;break}n.push(...t)}if(r)return pv({answers:n})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,n=this.lru.get(r);if(null!=n){const e=n.filter((e=>e.expires>Date.now())).map((({expires:e,value:t})=>({...t,TTL:Math.round((e-Date.now())/1e3),type:gv[t.type]})));return 0===e.length&&this.lru.remove(r),e}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,n=this.lru.get(r)??[];n.push({expires:Date.now()+1e3*(t.TTL??60),value:t}),this.lru.set(r,n)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}class wv{resolvers;cache;constructor(e){var t;this.resolvers={},this.cache=(t=e.cacheSize??1e3,new yv(t)),Object.entries(e.resolvers??{}).forEach((([e,t])=>{Array.isArray(t)||(t=[t]),e.endsWith(".")||(e=`${e}.`),this.resolvers[e]=t})),null==this.resolvers["."]&&(this.resolvers["."]=[fv("https://cloudflare-dns.com/dns-query"),fv("https://dns.google/resolve")])}async query(e,t={}){const r=dv(t.types),n=!1!==t.cached?this.cache.get(e,r):void 0;if(null!=n)return t.onProgress?.(new ng("dns:cache",{detail:n})),n;const s=`${e.split(".").pop()}.`,i=(this.resolvers[s]??this.resolvers["."]).sort((()=>Math.random()>.5?-1:1)),o=[];for(const n of i){if(!0===t.signal?.aborted)break;try{const s=await n(e,{...t,types:r});for(const t of s.Answer)this.cache.add(e,t);return s}catch(e){o.push(e),t.onProgress?.(new ng("dns:error",{detail:e}))}}if(1===o.length)throw o[0];throw new AggregateError(o,`DNS lookup of ${e} ${r} failed`)}}!function(e){e[e.A=1]="A",e[e.CNAME=5]="CNAME",e[e.TXT=16]="TXT",e[e.AAAA=28]="AAAA"}(gv||(gv={}));const{code:bv}=Fl("dnsaddr");class vv extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const Sv=async function(e,t={}){const r=t.maxRecursiveDepth??32;if(0===r)throw new vv("Max recursive depth reached");const[,n]=e.stringTuples().find((([e])=>e===bv))??[],s=t?.dns??function(e={}){return new wv(e)}(),i=await s.query(`_dnsaddr.${n}`,{signal:t?.signal,types:[gv.TXT]}),o=e.getPeerId(),a=[];for(const e of i.Answer){const n=e.data.replace(/["']/g,"").trim().split("=")[1];if(null==n)continue;if(null!=o&&!n.includes(o))continue;const s=Ud(n);if(n.startsWith("/dnsaddr")){const e=await s.resolve({...t,maxRecursiveDepth:r-1});a.push(...e.map((e=>e.toString())))}else a.push(s.toString())}return a},Ev=r(6864),kv={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:e=>e},connectionManager:{resolvers:{dnsaddr:Sv}},transportManager:{faultTolerance:Jf.FATAL_ALL}};async function Av(e){const t=Ev(kv,e);if(null===t.connectionProtector&&null!=globalThis.process?.env?.LIBP2P_FORCE_PNET)throw new M("Private network is enforced, but no protector was provided");return t}const Iv=Symbol.for("@libp2p/content-routing"),_v=Symbol.for("@libp2p/peer-routing"),Cv=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const r of e)t.push(r);return t})();const t=[];for(const r of e)t.push(r);return t},xv={},Tv=e=>{e.addEventListener("message",(t=>{Tv.dispatchEvent("message",e,t)})),null!=e.port&&e.port.addEventListener("message",(t=>{Tv.dispatchEvent("message",e,t)}))};Tv.addEventListener=(e,t)=>{null==xv[e]&&(xv[e]=[]),xv[e].push(t)},Tv.removeEventListener=(e,t)=>{null!=xv[e]&&(xv[e]=xv[e].filter((e=>e===t)))},Tv.dispatchEvent=function(e,t,r){null!=xv[e]&&xv[e].forEach((e=>e(t,r)))};const Mv=Tv,Pv="lock:worker:request-read",Dv="lock:worker:release-read",Nv="lock:master:grant-read",Rv="lock:worker:request-write",Bv="lock:worker:release-write",Lv="lock:master:grant-write",Ov=(e,t,r,n,s)=>(i,o)=>{if(o.data.type!==r)return;const a={type:o.data.type,name:o.data.name,identifier:o.data.identifier};e.dispatchEvent(new MessageEvent(t,{data:{name:a.name,handler:async()=>{i.postMessage({type:s,name:a.name,identifier:a.identifier}),await new Promise((e=>{const t=r=>{if(null==r?.data)return;const s=r.data.type,o=(r.data.name,r.data.identifier);s===n&&o===a.identifier&&(i.removeEventListener("message",t),e())};i.addEventListener("message",t)}))}}}))},Uv=(e,t,r,n)=>async()=>{const s=Math.random().toString().substring(2);return globalThis.postMessage({type:t,identifier:s,name:e}),new Promise((t=>{const i=o=>{if(null==o?.data)return;const a=o.data.type,c=o.data.identifier;a===r&&c===s&&(globalThis.removeEventListener("message",i),t((()=>{globalThis.postMessage({type:n,identifier:s,name:e})})))};globalThis.addEventListener("message",i)}))},Fv={singleProcess:!1},Vv={};let $v;async function Hv(e,t){let r;const n=new Promise((e=>{r=e}));return e.add((async()=>Ww((async()=>{await new Promise((e=>{r((()=>{e()}))}))})(),{milliseconds:t.timeout}))),n}const zv={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};var qv,jv,Wv;function Kv(e,t){const r=qv.decode(t);null!=r.publicKey&&null==e.publicKey&&(e=tc(qa(r.publicKey)));const n=new Map,s=BigInt(Date.now());for(const[e,t]of r.tags.entries())null!=t.expiry&&t.expiry<s||n.set(e,t);return{...r,id:e,addresses:r.addresses.map((({multiaddr:e,isCertified:t})=>({multiaddr:Ud(e),isCertified:t??!1}))),metadata:r.metadata,peerRecordEnvelope:r.peerRecordEnvelope??void 0,tags:n}}!function(e){let t,r,n;!function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&e.value.byteLength>0&&(t.uint32(18),t.bytes(e.value)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={key:"",value:Xr(0)},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.key=e.string();break;case 2:n.value=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(t=e.Peer$metadataEntry||(e.Peer$metadataEntry={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&(t.uint32(18),Wv.codec().encode(e.value,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={key:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.key=e.string();break;case 2:n.value=Wv.codec().decode(e,e.uint32(),{limits:r.limits?.value});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(r=e.Peer$tagsEntry||(e.Peer$tagsEntry={})),e.codec=()=>(null==n&&(n=Rs(((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.addresses)for(const e of t.addresses)r.uint32(10),jv.codec().encode(e,r);if(null!=t.protocols)for(const e of t.protocols)r.uint32(18),r.string(e);if(null!=t.publicKey&&(r.uint32(34),r.bytes(t.publicKey)),null!=t.peerRecordEnvelope&&(r.uint32(42),r.bytes(t.peerRecordEnvelope)),null!=t.metadata&&0!==t.metadata.size)for(const[n,s]of t.metadata.entries())r.uint32(50),e.Peer$metadataEntry.codec().encode({key:n,value:s},r);if(null!=t.tags&&0!==t.tags.size)for(const[n,s]of t.tags.entries())r.uint32(58),e.Peer$tagsEntry.codec().encode({key:n,value:s},r);!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:if(null!=n.limits?.addresses&&s.addresses.length===n.limits.addresses)throw new Bs('Decode error - map field "addresses" had too many elements');s.addresses.push(jv.codec().decode(t,t.uint32(),{limits:n.limits?.addresses$}));break;case 2:if(null!=n.limits?.protocols&&s.protocols.length===n.limits.protocols)throw new Bs('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break;case 4:s.publicKey=t.bytes();break;case 5:s.peerRecordEnvelope=t.bytes();break;case 6:{if(null!=n.limits?.metadata&&s.metadata.size===n.limits.metadata)throw new Ls('Decode error - map field "metadata" had too many elements');const r=e.Peer$metadataEntry.codec().decode(t,t.uint32());s.metadata.set(r.key,r.value);break}case 7:{if(null!=n.limits?.tags&&s.tags.size===n.limits.tags)throw new Ls('Decode error - map field "tags" had too many elements');const r=e.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:n.limits?.tags$value}});s.tags.set(r.key,r.value);break}default:t.skipType(7&r)}}return s}))),n),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(qv||(qv={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),null!=e.isCertified&&(t.uint32(16),t.bool(e.isCertified)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={multiaddr:Xr(0)},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.multiaddr=e.bytes();break;case 2:n.isCertified=e.bool();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(jv||(jv={})),function(e){let t;e.codec=()=>(null==t&&(t=Rs(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.value&&0!==e.value&&(t.uint32(8),t.uint32(e.value)),null!=e.expiry&&(t.uint32(16),t.uint64(e.expiry)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={value:0},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.value=e.uint32();break;case 2:n.expiry=e.uint64();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>_s(t,e.codec()),e.decode=(t,r)=>Pn(t,e.codec(),r)}(Wv||(Wv={}));const Gv="/",Yv=(new TextEncoder).encode(Gv),Jv=Yv[0];class Qv{_buf;constructor(e,t){if("string"==typeof e)this._buf=ds(e);else{if(!(e instanceof Uint8Array))throw new Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==Jv)throw new Error("Invalid key")}toString(e="utf8"){return ia(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Qv(e.join(Gv))}static random(){return new Qv(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||"string"==typeof e?new Qv(e):"function"==typeof e.uint8Array?new Qv(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=Yv),this._buf[0]!==Jv){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Jv,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Jv;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let e=0;e<t.length;e++){if(r.length<e+1)return!1;const n=t[e],s=r[e];if(n<s)return!0;if(n>s)return!1}return t.length<r.length}reverse(){return Qv.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Gv).slice(1)}type(){return function(e){const t=e.split(":");return t.length<2?"":t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new Qv(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Gv)||(e+=Gv),e+=this.type(),new Qv(e)}parent(){const e=this.list();return 1===e.length?new Qv(Gv):new Qv(e.slice(0,-1).join(Gv))}child(e){return this.toString()===Gv?e:e.toString()===Gv?this:new Qv(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(...e){return Qv.withNamespaces([...this.namespaces(),...(t=e.map((e=>e.namespaces())),[].concat(...t))]);var t}}const Zv="/peers/";function Xv(e){if(!Ka(e)||null==e.type)throw new M("Invalid PeerId");const t=e.toCID().toString();return new Qv(`${Zv}${t}`)}async function eS(e,t,r){const n=new Map;for(const s of r){if(null==s)continue;if(s.multiaddr instanceof Uint8Array&&(s.multiaddr=Ud(s.multiaddr)),!Od(s.multiaddr))throw new M("Multiaddr was invalid");if(!await t(e,s.multiaddr))continue;const r=s.isCertified??!1,i=s.multiaddr.toString(),o=n.get(i);null!=o?s.isCertified=o.isCertified||r:n.set(i,{multiaddr:s.multiaddr,isCertified:r})}return[...n.values()].sort(((e,t)=>e.multiaddr.toString().localeCompare(t.multiaddr.toString()))).map((({isCertified:e,multiaddr:t})=>({isCertified:e,multiaddr:t.bytes})))}async function tS(e,t,r,n){if(null==t)throw new M("Invalid PeerData");if(null!=t.publicKey&&null!=e.publicKey&&!t.publicKey.equals(e.publicKey))throw new M("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer;if(null!=s&&!e.equals(s.id))throw new M("peer id did not match existing peer id");let i,o=s?.addresses??[],a=new Set(s?.protocols??[]),c=s?.metadata??new Map,l=s?.tags??new Map,u=s?.peerRecordEnvelope;if("patch"===r&&(null==t.multiaddrs&&null==t.addresses||(o=[],null!=t.multiaddrs&&o.push(...t.multiaddrs.map((e=>({isCertified:!1,multiaddr:e})))),null!=t.addresses&&o.push(...t.addresses)),null!=t.protocols&&(a=new Set(t.protocols)),null!=t.metadata&&(c=rS(t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata),{validate:nS})),null!=t.tags&&(l=rS(t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),{validate:sS,map:iS})),null!=t.peerRecordEnvelope&&(u=t.peerRecordEnvelope)),"merge"===r){if(null!=t.multiaddrs&&o.push(...t.multiaddrs.map((e=>({isCertified:!1,multiaddr:e})))),null!=t.addresses&&o.push(...t.addresses),null!=t.protocols&&(a=new Set([...a,...t.protocols])),null!=t.metadata){const e=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[t,r]of e)null==r?c.delete(t):c.set(t,r);c=rS([...c.entries()],{validate:nS})}if(null!=t.tags){const e=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),r=new Map(l);for(const[t,n]of e)null==n?r.delete(t):r.set(t,n);l=rS([...r.entries()],{validate:sS,map:iS})}null!=t.peerRecordEnvelope&&(u=t.peerRecordEnvelope)}null!=s?.id.publicKey?i=ja(s.id.publicKey):null!=t.publicKey?i=ja(t.publicKey):null!=e.publicKey&&(i=ja(e.publicKey));const h={addresses:await eS(e,n.addressFilter??(async()=>!0),o),protocols:[...a.values()].sort(((e,t)=>e.localeCompare(t))),metadata:c,tags:l,publicKey:i,peerRecordEnvelope:u};return"RSA"!==e.type&&delete h.publicKey,h}function rS(e,t){const r=new Map;for(const[r,n]of e)null!=n&&t.validate(r,n);for(const[n,s]of e.sort((([e],[t])=>e.localeCompare(t))))null!=s&&r.set(n,t.map?.(n,s)??s);return r}function nS(e,t){if("string"!=typeof e)throw new M("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new M("Metadata value must be a Uint8Array")}function sS(e,t){if("string"!=typeof e)throw new M("Tag name must be a string");if(null!=t.value){if(parseInt(`${t.value}`,10)!==t.value)throw new M("Tag value must be an integer");if(t.value<0||t.value>100)throw new M("Tag value must be between 0-100")}if(null!=t.ttl){if(parseInt(`${t.ttl}`,10)!==t.ttl)throw new M("Tag ttl must be an integer");if(t.ttl<0)throw new M("Tag ttl must be between greater than 0")}}function iS(e,t){let r;return null!=t.expiry&&(r=t.expiry),null!=t.ttl&&(r=BigInt(Date.now()+Number(t.ttl))),{value:t.value??0,expiry:r}}function oS(e,t){const r=e.toString().split("/")[2];return Kv(nc(Ke.parse(r,de)),t)}class aS{peerId;datastore;lock;addressFilter;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=function(e){const t=Object.assign({},zv,e);return null==$v&&($v=(e=>{if(e=Object.assign({},Fv,e),Boolean(globalThis.document)||e.singleProcess){const e=new EventTarget;return Mv.addEventListener("message",Ov(e,"requestReadLock",Pv,Dv,Nv)),Mv.addEventListener("message",Ov(e,"requestWriteLock",Rv,Bv,Lv)),e}return{isWorker:!0,readLock:e=>Uv(e,Pv,Nv,Dv),writeLock:e=>Uv(e,Rv,Lv,Bv)}})(t),!0!==$v.isWorker&&($v.addEventListener("requestReadLock",(e=>{null!=Vv[e.data.name]&&Vv[e.data.name].readLock().then((async t=>e.data.handler().finally((()=>{t()}))))})),$v.addEventListener("requestWriteLock",(async e=>{null!=Vv[e.data.name]&&Vv[e.data.name].writeLock().then((async t=>e.data.handler().finally((()=>{t()}))))})))),null==Vv[t.name]&&(Vv[t.name]=((e,t)=>{if(!0===$v.isWorker)return{readLock:$v.readLock(e,t),writeLock:$v.writeLock(e,t)};const r=new hv({concurrency:1});let n;return{async readLock(){if(null!=n)return Hv(n,t);n=new hv({concurrency:t.concurrency,autoStart:!1});const e=n,s=Hv(n,t);return r.add((async()=>{e.start(),await e.onIdle().then((()=>{n===e&&(n=null)}))})),s},writeLock:async()=>(n=null,Hv(r,t))}})(t.name,t)),Vv[t.name]}({name:"peer-store",singleProcess:!0})}async has(e){return this.datastore.has(Xv(e))}async delete(e){if(this.peerId.equals(e))throw new M("Cannot delete self peer");await this.datastore.delete(Xv(e))}async load(e){return Kv(e,await this.datastore.get(Xv(e)))}async save(e,t){const{existingBuf:r,existingPeer:n}=await this.#R(e),s=await tS(e,t,"patch",{addressFilter:this.addressFilter});return this.#B(e,s,r,n)}async patch(e,t){const{existingBuf:r,existingPeer:n}=await this.#R(e),s=await tS(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:n});return this.#B(e,s,r,n)}async merge(e,t){const{existingBuf:r,existingPeer:n}=await this.#R(e),s=await tS(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#B(e,s,r,n)}async*all(e){for await(const{key:t,value:r}of this.datastore.query(function(e){return null==e?{}:{prefix:Zv,filters:(e.filters??[]).map((e=>({key:t,value:r})=>e(oS(t,r)))),orders:(e.orders??[]).map((e=>(t,r)=>e(oS(t.key,t.value),oS(r.key,r.value))))}}(e??{}))){const e=oS(t,r);e.id.equals(this.peerId)||(yield e)}}async#R(e){try{const t=await this.datastore.get(Xv(e));return{existingBuf:t,existingPeer:Kv(e,t)}}catch(e){"NotFoundError"!==e.name&&this.log.error("invalid peer data found in peer store - %e",e)}return{}}async#B(e,t,r,n){const s=qv.encode(t);return null!=r&&et(s,r)?{peer:Kv(e,s),previous:n,updated:!1}:(await this.datastore.put(Xv(e),s),{peer:Kv(e,s),previous:n,updated:!0})}}class cS{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new aS(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){this.log.trace("forEach await read lock");const r=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const r of this.store.all(t))e(r)}finally{this.log.trace("forEach release read lock"),r()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await Cv(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async save(e,t){this.log.trace("save await write lock");const r=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const r=await this.store.save(e,t);return this.#L(e,r),r.peer}finally{this.log.trace("save release write lock"),r()}}async patch(e,t){this.log.trace("patch await write lock");const r=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const r=await this.store.patch(e,t);return this.#L(e,r),r.peer}finally{this.log.trace("patch release write lock"),r()}}async merge(e,t){this.log.trace("merge await write lock");const r=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const r=await this.store.merge(e,t);return this.#L(e,r),r.peer}finally{this.log.trace("merge release write lock"),r()}}async consumePeerRecord(e,t){const r=await Ip.openAndCertify(e,lw.DOMAIN),n=nc(r.publicKey.toCID());if(!1===t?.equals(n))return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,n),!1;const s=lw.createFromProtobuf(r.payload);let i;try{i=await this.get(n)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=i?.peerRecordEnvelope){const e=await Ip.createFromProtobuf(i.peerRecordEnvelope),t=lw.createFromProtobuf(e.payload);if(t.seqNumber>=s.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",t.seqNumber,s.seqNumber),!1}return await this.patch(s.peerId,{peerRecordEnvelope:e,addresses:s.multiaddrs.map((e=>({isCertified:!0,multiaddr:e})))}),!0}#L(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}Error,Error,Error,Error,Error,Error;class lS extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=lS.name;code=lS.code;constructor(e="Not Found"){super(e)}}Error;const uS=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);},hS=function(e,t){let r=0;if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)await t(n,r++)&&(yield n)}();const n=Vh(e),{value:s,done:i}=n.next();if(!0===i)return function*(){}();const o=t(s,r++);if("function"==typeof o.then)return async function*(){await o&&(yield s);for await(const e of n)await t(e,r++)&&(yield e)}();const a=t;return function*(){!0===o&&(yield s);for(const e of n)a(e,r++)&&(yield e)}()},dS=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){const r=await Cv(e);yield*r.sort(t)}():function*(){const r=Cv(e);yield*r.sort(t)}()},pS=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let r=0;if(!(t<1))for await(const n of e)if(yield n,r++,r===t)return}():function*(){let r=0;if(!(t<1))for(const n of e)if(yield n,r++,r===t)return}()};class fS{put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:n}of e)await this.put(r,n,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(t,r){e.push({key:t,value:r})},delete(e){t.push(e)},commit:async r=>{await uS(this.putMany(e,r)),e=[],await uS(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(null!=e.prefix){const t=e.prefix;r=hS(r,(e=>e.key.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>hS(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>dS(e,t)),r)),null!=e.offset){let t=0;const n=e.offset;r=hS(r,(()=>t++>=n))}return null!=e.limit&&(r=pS(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;r=hS(r,(e=>e.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>hS(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>dS(e,t)),r)),null!=e.offset){const t=e.offset;let n=0;r=hS(r,(()=>n++>=t))}return null!=e.limit&&(r=pS(r,e.limit)),r}}class gS extends fS{data;constructor(){super(),this.data=new Map}put(e,t){return this.data.set(e.toString(),t),e}get(e){const t=this.data.get(e.toString());if(null==t)throw new lS;return t}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,t]of this.data.entries())yield{key:new Qv(e),value:t}}*_allKeys(){for(const e of this.data.keys())yield new Qv(e)}}const mS=864e13;class yS{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(e){const t=this.findHost(e);for(const e of this.mappings.values())if(e.domain===t)return!0;return!1}add(e,t){t.forEach((t=>{this.log("add DNS mapping %s to %s",t,e);const r=!0===fd(t);this.mappings.set(t,{domain:e,verified:r,expires:r?mS-Date.now():0,lastVerified:r?mS-Date.now():void 0})}))}remove(e){const t=this.findHost(e);let r=!1;for(const[e,n]of this.mappings.entries())n.domain===t&&(this.log("removing %s to %s DNS mapping %e",e,n.domain,new Error("where")),this.mappings.delete(e),r=r||n.verified);return r}getAll(e){const t=[];for(let r=0;r<e.length;r++){const n=e[r].multiaddr.stringTuples(),s=n[0][1];if(null!=s)for(const[i,o]of this.mappings.entries())s===i&&this.maybeAddSNITuple(n,o.domain)&&(e.splice(r,1),r--,t.push({multiaddr:Ud(`/${n.map((e=>[Fl(e[0]).name,e[1]].join("/"))).join("/")}`),verified:o.verified,type:"dns-mapping",expires:o.expires,lastVerified:o.lastVerified}))}return t}maybeAddSNITuple(e,t){for(let r=0;r<e.length;r++)if(448===e[r][0]&&449!==e[r+1]?.[0])return e.splice(r+1,0,[449,t]),!0;return!1}confirm(e,t){const r=this.findHost(e);let n=!1;for(const[e,s]of this.mappings.entries())s.domain===r&&(this.log("marking %s to %s DNS mapping as verified",e,s.domain),n=s.verified,s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now());return n}unconfirm(e,t){const r=this.findHost(e);let n=!1;for(const[e,s]of this.mappings.entries())s.domain===r&&(this.log("removing verification of %s to %s DNS mapping",e,s.domain),n=n||s.verified,s.verified=!1,s.expires=Date.now()+t);return n}findHost(e){for(const t of e.stringTuples()){if(449===t[0])return t[1];if(53===t[0]||54===t[0]||55===t[0]||56===t[0])return t[1]}}}class wS{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(e){const t=e.stringTuples();for(const e of this.mappings.values())for(const r of e)if(r.externalIp===t[0][1])return!0;return!1}add(e,t,r,n=t,s="tcp"){const i=`${e}-${t}-${s}`,o=this.mappings.get(i)??[],a={internalIp:e,internalPort:t,externalIp:r,externalPort:n,externalFamily:Ml(r)?4:6,protocol:s,verified:!1,expires:0};o.push(a),this.mappings.set(i,o)}remove(e){const t=e.stringTuples(),r=t[0][1]??"",n=6===t[1][0]?"tcp":"udp",s=parseInt(t[1][1]??"0");let i=!1;for(const[e,t]of this.mappings.entries()){for(let e=0;e<t.length;e++){const o=t[e];o.externalIp===r&&o.externalPort===s&&o.protocol===n&&(this.log("removing %s:%s to %s:%s %s IP mapping",o.externalIp,o.externalPort,r,s,n),i=i||o.verified,t.splice(e,1),e--)}0===t.length&&this.mappings.delete(e)}return i}getAll(e){const t=[];for(const{multiaddr:r}of e){const e=r.stringTuples();let n;if(4!==e[0][0]&&41!==e[0][0]||6!==e[1][0]?4!==e[0][0]&&41!==e[0][0]||273!==e[1][0]||(n=`${e[0][1]}-${e[1][1]}-udp`):n=`${e[0][1]}-${e[1][1]}-tcp`,null==n)continue;const s=this.mappings.get(n);if(null!=s)for(const r of s)e[0][0]=4===r.externalFamily?4:41,e[0][1]=r.externalIp,e[1][1]=`${r.externalPort}`,t.push({multiaddr:Ud(`/${e.map((e=>[Fl(e[0]).name,e[1]].join("/"))).join("/")}`),verified:r.verified,type:"ip-mapping",expires:r.expires,lastVerified:r.lastVerified})}return t}confirm(e,t){const r=e.stringTuples()[0][1];let n=!1;for(const e of this.mappings.values())for(const s of e)s.externalIp===r&&(this.log("marking %s to %s IP mapping as verified",s.internalIp,s.externalIp),n=s.verified,s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now());return n}unconfirm(e,t){const r=e.stringTuples(),n=r[0][1]??"",s=6===r[1][0]?"tcp":"udp",i=parseInt(r[1][1]??"0");let o=!1;for(const e of this.mappings.values())for(let r=0;r<e.length;r++){const a=e[r];a.externalIp===n&&a.externalPort===i&&a.protocol===s&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n,i,s),o=o||a.verified,a.verified=!1,a.expires=Date.now()+t)}return o}}class bS{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??10}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(gd(e)||function(e){try{const[[t,r]]=e.stringTuples();if(null==r)return!1;if(4===t)return r.startsWith("169.254.");if(41===t)return r.toLowerCase().startsWith("fe80")}catch{}return!1}(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map((([e,t])=>({multiaddr:Ud(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified})))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const r=e.toString(),n=this.addresses.get(r)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},s=n.verified;return n.verified=!0,n.lastVerified=Date.now(),this.log("marking observed address %a as verified",r),this.addresses.set(r,n),s}}class vS{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??10}get(e,t){if(gd(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const r=this.toKey(e);let n=this.addresses.get(r);return null==n&&(n={verified:!1,expires:0},this.addresses.set(r,n)),{multiaddr:e,verified:n.verified,type:"transport",expires:n.expires,lastVerified:n.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),r=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),r}confirm(e,t){const r=this.toKey(e),n=this.addresses.get(r)??{verified:!1,expires:0,lastVerified:0},s=n.verified;return n.verified=!0,n.expires=Date.now()+t,n.lastVerified=Date.now(),this.addresses.set(r,n),s}unconfirm(e,t){const r=this.toKey(e),n=this.addresses.get(r)??{verified:!1,expires:0},s=n.verified;return n.verified=!1,n.expires=Date.now()+t,this.addresses.set(r,n),s}toKey(e){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}}const SS=6e5,ES=3e5,kS=e=>e;function AS(e,t){const r=e.getPeerId();return null!=r&&ec(r).equals(t)&&(e=e.decapsulate(Ud(`/p2p/${t.toString()}`))),e}class IS{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:r=[],announce:n=[],appendAnnounce:s=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map((e=>e.toString())),this.announce=new Set(n.map((e=>e.toString()))),this.appendAnnounce=new Set(s.map((e=>e.toString()))),this.observed=new bS(e,t),this.dnsMappings=new yS(e,t),this.ipMappings=new wS(e,t),this.transportAddresses=new vS(e,t),this.announceFilter=t.announceFilter??kS,this.observedAddressFilter=ld(1024),this.addressVerificationTTL=t.addressVerificationTTL??SS,this.addressVerificationRetry=t.addressVerificationRetry??ES,this._updatePeerStoreAddresses=function(e){let t;const r=function(){clearTimeout(t),t=setTimeout((function(){t=void 0,e()}),1e3)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}(this._updatePeerStoreAddresses.bind(this)),e.events.addEventListener("transport:listening",(()=>{this._updatePeerStoreAddresses()})),e.events.addEventListener("transport:close",(()=>{this._updatePeerStoreAddresses()}))}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map((e=>e.getPeerId()===this.components.peerId.toString()?e.decapsulate(`/p2p/${this.components.peerId.toString()}`):e));this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch((e=>{this.log.error("error updating addresses",e)}))}getListenAddrs(){return Array.from(this.listen).map((e=>Ud(e)))}getAnnounceAddrs(){return Array.from(this.announce).map((e=>Ud(e)))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map((e=>Ud(e)))}getObservedAddrs(){return this.observed.getAll().map((e=>e.multiaddr))}addObservedAddr(e){const t=e.stringTuples(),r=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(r)||(this.observedAddressFilter.add(r),e=AS(e,this.components.peerId),this.ipMappings.has(e)||this.dnsMappings.has(e)||this.observed.add(e))}confirmObservedAddr(e,t){e=AS(e,this.components.peerId);let r=!0;("observed"===t?.type||this.observed.has(e))&&(r=this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)),("transport"===t?.type||this.transportAddresses.has(e))&&(r=this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)),("dns-mapping"===t?.type||this.dnsMappings.has(e))&&(r=this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)),("ip-mapping"===t?.type||this.ipMappings.has(e))&&(r=this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)),r||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=AS(e,this.components.peerId);let r=!1;this.observed.has(e)&&(r=this.observed.remove(e)),this.transportAddresses.has(e)&&(r=this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry)),this.dnsMappings.has(e)&&(r=this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)),this.ipMappings.has(e)&&(r=this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)),r&&this._updatePeerStoreAddresses()}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter((t=>{if(!t.verified)return!1;const r=t.multiaddr.toString();return!e.has(r)&&(e.add(r),!0)})).map((e=>e.multiaddr));return this.announceFilter(t.map((e=>{const t=Ud(e);return!0===t.protos().pop()?.path||t.getPeerId()===this.components.peerId.toString()?t:t.encapsulate(`/p2p/${this.components.peerId.toString()}`)})))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return e.map((e=>({multiaddr:e,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})));let t=[];return t=t.concat(this.components.transportManager.getAddrs().map((e=>this.transportAddresses.get(e,this.addressVerificationTTL)))),t=t.concat(this.getAppendAnnounceAddrs().map((e=>({multiaddr:e,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(Ud(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,r,n=t,s="tcp"){this.ipMappings.add(e,t,r,n,s),this.observed.removePrefixed(`/ip${Ml(r)?4:6}/${r}/${s}/${n}`)}removePublicAddressMapping(e,t,r,n=t,s="tcp"){this.ipMappings.remove(Ud(`/ip${Ml(r)?4:6}/${r}/${s}/${n}`))&&this._updatePeerStoreAddresses()}}var _S;!function(e){e.NOT_STARTED_YET="The libp2p node is not started yet",e.NOT_FOUND="Not found"}(_S||(_S={}));class CS extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class xS extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class TS extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class MS extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class PS extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class DS extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class NS extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class RS extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class BS extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class LS extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class OS extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class US extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class FS extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class VS extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class $S{components={};_started=!1;constructor(e={}){this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;null==this.components.logger&&(this.components.logger=Mg())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter((e=>Qf(e))).map((async t=>{await(t[e]?.())})))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const HS=["metrics","connectionProtector","dns"],zS=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function qS(e){return Array.isArray(e?.[I])?e[I]:[]}function jS(e){return Array.isArray(e?.[_])?e[_]:[]}function WS(e){return e?.[Symbol.toStringTag]??e?.toString()??"unknown"}function KS(e={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(bf.matches(e))return!1;const t=e.stringTuples();return(4===t[0][0]||41===t[0][0])&&Boolean(fd(`${t[0][1]}`))},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...e}}class GS{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??1e3*this.duration/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new YS}async consume(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r);let i=this.memoryStorage.incrby(n,t,s);if(i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i.consumedPoints>this.points)throw this.blockDuration>0&&i.consumedPoints<=this.points+t&&(i=this.memoryStorage.set(n,i.consumedPoints,this.blockDuration)),new wd("Rate limit exceeded",i);if(this.execEvenly&&i.msBeforeNext>0&&!i.isFirstInDuration){let e=Math.ceil(i.msBeforeNext/(i.remainingPoints+2));e<this.execEvenlyMinDelayMs&&(e=i.consumedPoints*this.execEvenlyMinDelayMs),await pg(e)}return i}penalty(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r),i=this.memoryStorage.incrby(n,t,s);return i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i}reward(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r),i=this.memoryStorage.incrby(n,-t,s);return i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i}block(e,t){const r=1e3*t,n=this.points+1;return this.memoryStorage.set(this.getKey(e),n,t),{remainingPoints:0,msBeforeNext:0===r?-1:r,consumedPoints:n,isFirstInDuration:!1}}set(e,t,r=0){const n=1e3*(r>=0?r:this.duration);return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return null!=t&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return null!=e?.customDuration&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class YS{storage;constructor(){this.storage=new Map}incrby(e,t,r){const n=this.storage.get(e);if(null!=n){const s=null!=n.expiresAt?n.expiresAt.getTime()-(new Date).getTime():-1;return null==n.expiresAt||s>0?(n.value+=t,{remainingPoints:0,msBeforeNext:s,consumedPoints:n.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const n=1e3*r,s=this.storage.get(e);null!=s&&clearTimeout(s.timeoutId);const i={value:t,expiresAt:n>0?new Date(Date.now()+n):void 0};return this.storage.set(e,i),n>0&&(i.timeoutId=setTimeout((()=>{this.storage.delete(e)}),n),null!=i.timeoutId.unref&&i.timeoutId.unref()),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:i.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(null!=t)return{remainingPoints:0,msBeforeNext:null!=t.expiresAt?t.expiresAt.getTime()-(new Date).getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return null!=t&&(null!=t.timeoutId&&clearTimeout(t.timeoutId),this.storage.delete(e),!0)}}function JS(e){if(Ka(e))return{peerId:e,multiaddrs:[]};let t;if(Array.isArray(e)||(e=[e]),e.length>0){const r=e[0].getPeerId();t=null==r?void 0:ec(r),e.forEach((e=>{if(!Od(e))throw new $("Invalid multiaddr");const r=e.getPeerId();if(null==r){if(null!=t)throw new M("Multiaddrs must all have the same peer id or have no peer id")}else{const e=ec(r);if(!0!==t?.equals(e))throw new M("Multiaddrs must all have the same peer id or have no peer id")}}))}return{peerId:t,multiaddrs:e}}const QS=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];function ZS(e){try{let t;if(t="string"==typeof e?Ud(e):e,!t.protoNames().includes("ipcidr")){const e=t.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";t=t.encapsulate(e)}return function(e){let t,r;if(e.stringTuples().forEach((([e,n])=>{e!==Vl.code&&e!==$l.code||(r=n),e===Hl.code&&(t=n)})),null==t||null==r)throw new Error("Invalid multiaddr");return new Tl(r,t)}(t)}catch(t){throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${e}`)}}class XS{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??100,this.allow=(t.allow??[]).map((e=>ZS(e))),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch((e=>{this.log.error("error while pruning connections %e",e)}))}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const r=new Vf;for(const t of e){const e=t.remotePeer;if(!r.has(e)){r.set(e,0);try{const t=await this.peerStore.get(e);r.set(e,[...t.tags.values()].reduce(((e,t)=>e+t.value),0))}catch(e){"NotFoundError"!==e.name&&this.log.error("error loading peer tags",e)}}}const n=this.sortConnections(e,r),s=Math.max(t-this.maxConnections,0),i=[];for(const e of n)if(this.log("too many connections open - closing a connection to %p",e.remotePeer),this.allow.some((t=>t.contains(e.remoteAddr.nodeAddress().address)))||i.push(e),i.length===s)break;await Promise.all(i.map((async e=>{await async function(e,t){const r=e?.streams?.map((e=>e.protocol))??[],n=t?.closableProtocols??QS;if(!(r.filter((e=>null!=e&&!n.includes(e))).length>0))try{await(e?.close(t))}catch(t){e?.abort(t)}}(e,{signal:AbortSignal.timeout(1e3)})}))),this.events.safeDispatchEvent("connection:prune",{detail:i})}sortConnections(e,t){return e.sort(((e,t)=>{const r=e.timeline.open,n=t.timeline.open;return r<n?1:r>n?-1:0})).sort(((e,t)=>"outbound"===e.direction&&"inbound"===t.direction?1:"inbound"===e.direction&&"outbound"===t.direction?-1:0)).sort(((e,t)=>e.streams.length>t.streams.length?1:e.streams.length<t.streams.length?-1:0)).sort(((e,r)=>{const n=t.get(e.remotePeer)??0,s=t.get(r.remotePeer)??0;return n>s?1:n<s?-1:0}))}}const eE="last-dial-failure",tE="last-dial-success";class rE extends Ed{constructor(e={}){super({...e,sort:(e,t)=>e.options.priority>t.options.priority?-1:e.options.priority<t.options.priority?1:0})}}function nE(e,t){const r=pf.exactMatch(e.multiaddr),n=pf.exactMatch(t.multiaddr);if(r&&!n)return-1;if(!r&&n)return 1;const s=Sf.exactMatch(e.multiaddr),i=Sf.exactMatch(t.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=bf.exactMatch(e.multiaddr),a=bf.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=Tf.exactMatch(e.multiaddr),l=Tf.exactMatch(t.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=kf.exactMatch(e.multiaddr),h=kf.exactMatch(t.multiaddr);if(u&&!h)return-1;if(!u&&h)return 1;const d=If.exactMatch(e.multiaddr),p=If.exactMatch(t.multiaddr);return d&&!p?-1:!d&&p?1:0}function sE(e,t){const r=gd(e.multiaddr),n=gd(t.multiaddr);return r&&!n?1:!r&&n?-1:0}function iE(e,t){return e.isCertified&&!t.isCertified?-1:!e.isCertified&&t.isCertified?1:0}function oE(e,t){const r=xf.exactMatch(e.multiaddr),n=xf.exactMatch(t.multiaddr);return r&&!n?1:!r&&n?-1:0}class aE{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??25,this.maxDialQueueLength=t.maxDialQueueLength??500,this.dialTimeout=t.dialTimeout??5e3,this.connections=t.connections??new Vf,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[e,r]of Object.entries(t.resolvers??{}))Ld.set(e,r);this.queue=new rE({concurrency:t.maxParallelDials??50,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",(e=>{e.detail.name!==C.name&&this.log.error("error in dial queue - %e",e.detail)}))}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:r,multiaddrs:n}=JS(e),s=Array.from(this.connections.values()).flat().find((e=>!0!==t.force&&(!!e.remotePeer.equals(r)||n.find((t=>t.equals(e.remoteAddr))))));if("open"===s?.status)return this.log("already connected to %a",s.remoteAddr),t.onProgress?.(new ng("dial-queue:already-connected")),s;const i=this.queue.queue.find((e=>{if(!0===r?.equals(e.options.peerId))return!0;const t=e.options.multiaddrs;if(null==t)return!1;for(const e of n)if(t.has(e.toString()))return!0;return!1}));if(null!=i){this.log("joining existing dial target for %p",r);for(const e of n)i.options.multiaddrs.add(e.toString());return t.onProgress?.(new ng("dial-queue:already-in-dial-queue")),i.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new G("Dial queue is full");return this.log("creating dial target for %p",r,n.map((e=>e.toString()))),t.onProgress?.(new ng("dial-queue:add-to-dial-queue")),this.queue.add((async e=>{e?.onProgress?.(new ng("dial-queue:start-dial"));const t=Ad([this.shutDownController.signal,e.signal]);let n;try{n=await this.calculateMultiaddrs(r,e?.multiaddrs,{...e,signal:t}),e?.onProgress?.(new ng("dial-queue:calculated-addresses",n)),n.map((({multiaddr:e})=>e.toString())).forEach((t=>{e?.multiaddrs.add(t)}))}catch(e){throw t.clear(),e}try{let s=0;const i=[];for(const o of n){if(s===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",s,r),new G("Peer had more than maxPeerAddrsToDial");s++;try{const n=await this.components.transportManager.dial(o.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",o.multiaddr);try{await this.components.peerStore.merge(n.remotePeer,{multiaddrs:[n.remoteAddr],metadata:{[tE]:ds(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",r,e)}return n}catch(e){if(this.log.error("dial failed to %a",o.multiaddr,e),null!=r)try{await this.components.peerStore.merge(r,{metadata:{[eE]:ds(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",r,e)}if(t.aborted)throw new W(e.message);i.push(e)}}if(1===i.length)throw i[0];throw new AggregateError(i,"All multiaddr dials failed")}finally{t.clear()}}),{peerId:r,priority:t.priority??gE,multiaddrs:new Set(n.map((e=>e.toString()))),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async calculateMultiaddrs(e,t=new Set,r={}){const n=[...t].map((e=>({multiaddr:Ud(e),isCertified:!1})));if(null!=e){if(this.components.peerId.equals(e))throw new G("Tried to dial self");if(!0===await(this.components.connectionGater.denyDialPeer?.(e)))throw new RS("The dial request is blocked by gater.allowDialPeer");if(0===n.length){this.log("loading multiaddrs for %p",e);try{const t=await this.components.peerStore.get(e);n.push(...t.addresses),this.log("loaded multiaddrs for %p",e,n.map((({multiaddr:e})=>e.toString())))}catch(e){if("NotFoundError"!==e.name)throw e}}if(0===n.length){this.log("looking up multiaddrs for %p in the peer routing",e);try{const t=await this.components.peerRouting.findPeer(e,r);this.log("found multiaddrs for %p in the peer routing",e,n.map((({multiaddr:e})=>e.toString()))),n.push(...t.multiaddrs.map((e=>({multiaddr:e,isCertified:!1}))))}catch(t){"NoPeerRoutersError"!==t.name&&this.log.error("looking up multiaddrs for %p in the peer routing failed",e,t)}}}let s=(await Promise.all(n.map((async e=>{const t=await async function(e,t){let r=!1;for(const t of Ld.keys())if(r=e.protoNames().includes(t),r)break;if(!r)return[e];const n=await e.resolve(t);return t.log("resolved %s to",e,n.map((e=>e.toString()))),n}(e.multiaddr,{dns:this.components.dns,...r,log:this.log});return 1===t.length&&t[0].equals(e.multiaddr)?e:t.map((e=>({multiaddr:e,isCertified:!1})))})))).flat();if(null!=e){const t=`/p2p/${e.toString()}`;s=s.map((e=>{const r=e.multiaddr.protos().pop();return!0===r?.path?e:null==e.multiaddr.getPeerId()?{multiaddr:e.multiaddr.encapsulate(t),isCertified:e.isCertified}:e}))}const i=s.filter((t=>{if(null==this.components.transportManager.dialTransportForMultiaddr(t.multiaddr))return!1;const r=t.multiaddr.getPeerId();return null==e||null==r||e.equals(r)})),o=new Map;for(const e of i){const t=e.multiaddr.toString(),r=o.get(t);null==r?o.set(t,e):r.isCertified=r.isCertified||e.isCertified||!1}const a=[...o.values()];if(0===a.length)throw new BS("The dial request has no valid addresses");const c=[];for(const e of a)null!=this.components.connectionGater.denyDialMultiaddr&&await this.components.connectionGater.denyDialMultiaddr(e.multiaddr)||c.push(e);const l=null==this.addressSorter?c.sort(nE).sort(iE).sort(oE).sort(sE):c.sort(this.addressSorter);if(0===l.length)throw new RS("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",s.map((({multiaddr:e})=>e.toString()))),this.log.trace("addresses for %p after filtering",e??"unknown peer",l.map((({multiaddr:e})=>e.toString()))),l}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map((e=>e.toString()))),t);return!1!==t.runOnLimitedConnection||null!=r.find((e=>!xf.matches(e.multiaddr)))}catch(e){this.log.trace("error calculating if multiaddr(s) were dialable",e)}return!1}}var cE=r(5617);const lE=Object.prototype.toString,uE=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);class hE extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,({message:e}=e)):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const dE=(e,t,r)=>{const n=r.retries-(t-1);return e.attemptNumber=t,e.retriesLeft=n,e};class pE{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new kd({concurrency:t.maxParallelReconnects??5,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",(e=>{this.maybeReconnect(e.detail).catch((t=>{this.log.error("failed to maybe reconnect to %p - %e",e.detail,t)}))}))}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);fE(t)&&(this.queue.has(e)||this.queue.add((async t=>{await async function(e,t){return new Promise(((r,n)=>{t={...t},t.onFailedAttempt??=()=>{},t.shouldRetry??=()=>!0,t.retries??=10;const s=cE.operation(t),i=()=>{s.stop(),n(t.signal?.reason)};t.signal&&!t.signal.aborted&&t.signal.addEventListener("abort",i,{once:!0});const o=()=>{t.signal?.removeEventListener("abort",i),s.stop()};s.attempt((async i=>{try{const t=await e(i);o(),r(t)}catch(e){try{if(!(e instanceof Error))throw new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`);if(e instanceof hE)throw e.originalError;if(e instanceof TypeError&&!function(e){var t;return!(!e||(t=e,"[object Error]"!==lE.call(t))||"TypeError"!==e.name||"string"!=typeof e.message)&&("Load failed"===e.message?void 0===e.stack:uE.has(e.message))}(e))throw e;if(dE(e,i,t),await t.shouldRetry(e)||(s.stop(),n(e)),await t.onFailedAttempt(e),!s.retry(e))throw s.mainError()}catch(e){dE(e,i,t),o(),n(e)}}}))}))}((async r=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:t?.signal})}catch(t){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,r,this.retries,t),t}}),{signal:t?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})}),{peerId:e}).catch((async r=>{this.log.error("failed to reconnect to %p - %e",e,r);const n={};[...t.tags.keys()].forEach((e=>{e.startsWith(Cp)&&(n[e]=void 0)})),await this.peerStore.merge(e,{tags:n}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})})).catch((async t=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,t)})))}start(){this.started=!0}async afterStart(){Promise.resolve().then((async()=>{const e=await this.peerStore.all({filters:[e=>fE(e)]});await Promise.all(e.map((async e=>{await this.connectionManager.openConnection(e.id).catch((e=>{this.log.error(e)}))})))})).catch((e=>{this.log.error(e)}))}stop(){this.started=!1,this.queue.abort()}}function fE(e){for(const t of e.tags.keys())if(t.startsWith(Cp))return!0;return!1}const gE=50;class mE{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??100,this.maxConnections<1)throw new M("Connection Manager maxConnections must be greater than 0");this.connections=new Vf,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map((e=>ZS(e))),this.deny=(t.deny??[]).map((e=>ZS(e))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??10,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new GS({points:t.inboundConnectionThreshold??5,duration:1}),this.connectionPruner=new XS({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:t.allow?.map((e=>Ud(e)))}),this.dialQueue=new aE(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??50,maxDialQueueLength:t.maxDialQueueLength??500,maxPeerAddrsToDial:t.maxPeerAddrsToDial??25,dialTimeout:t.dialTimeout??5e3,resolvers:t.resolvers??{dnsaddr:Sv},connections:this.connections}),this.reconnectQueue=new pE({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const r of t)e[r.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t)for(const t of r.streams){const r=`${t.direction} ${t.protocol??"unnegotiated"}`;e[r]=(e[r]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t){const t={};for(const e of r.streams){const r=`${e.direction} ${e.protocol??"unnegotiated"}`;t[r]=(t[r]??0)+1}for(const[r,n]of Object.entries(t))e[r]=e[r]??[],e[r].push(n)}const t={};for(let[r,n]of Object.entries(e)){n=n.sort(((e,t)=>e-t));const e=Math.floor(.9*n.length);t[r]=n[e]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Zf(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Xf(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(e){this.log.error(e)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(e){this._onConnect(e).catch((e=>{this.log.error(e)}))}async _onConnect(e){const{detail:t}=e;if(!this.started)return void await t.close();if("open"!==t.status)return;const r=t.remotePeer,n=!this.connections.has(r),s=this.connections.get(r)??[];s.push(t),this.connections.set(r,s),null!=r.publicKey&&"RSA"===r.type&&await this.peerStore.patch(r,{publicKey:r.publicKey}),n&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,r=t.remotePeer,n=(this.connections.get(r)??[]).filter((e=>e.id!==t.id));this.connections.set(r,n),0===n.length&&(this.log("onDisconnect remove all connections for peer %p",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(null!=e)return this.connections.get(e)??[];let t=[];for(const e of this.connections.values())t=t.concat(e);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new K("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:r}=JS(e);if(this.peerId.equals(r))throw new V("Can not dial self");if(null!=r&&!0!==t.force){this.log("dial %p",r);const e=this.getConnections(r).find((e=>null==e.limits));if(null!=e)return this.log("had an existing non-limited connection to %p",r),t.onProgress?.(new ng("dial-queue:already-connected")),e}const n=await this.dialQueue.dial(e,{...t,priority:t.priority??gE});if("open"!==n.status)throw new R("Remote closed connection during opening");let s=this.connections.get(n.remotePeer);null==s&&(s=[],this.connections.set(n.remotePeer,s));let i=!1;for(const e of s)if(e.id===n.id&&(i=!0),!0!==t.force&&e.id!==n.id&&e.remoteAddr.equals(n.remoteAddr))return n.abort(new $("Duplicate multiaddr connection")),e;return i||s.push(n),n}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map((async e=>{try{await e.close(t)}catch(t){e.abort(t)}})))}async acceptIncomingConnection(e){if(this.deny.some((t=>t.contains(e.remoteAddr.nodeAddress().address))))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some((t=>t.contains(e.remoteAddr.nodeAddress().address))))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const t=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(t,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,t),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map((t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map((e=>Ud(e)))})))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class yE{movingAverage;variance;deviation;forecast;timespan;previousTime;constructor(e){this.timespan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timespan)}push(e,t=Date.now()){if(null!=this.previousTime){const r=this.alpha(t,this.previousTime),n=e-this.movingAverage,s=r*n;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+n*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*n}else this.movingAverage=e;this.previousTime=t}}class wE{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;constructor(e={}){this.success=new yE(e.interval??5e3),this.failure=new yE(e.interval??5e3),this.next=new yE(e.interval??5e3),this.failureMultiplier=e.failureMultiplier??2,this.timeoutMultiplier=e.timeoutMultiplier??1.2,this.minTimeout=e.minTimeout??2e3,null!=e.metricName&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){const t=Math.max(Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier)),this.minTimeout),r=AbortSignal.timeout(t),n=Ad([e.signal,r]);return n.start=Date.now(),n.timeout=t,n}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class bE{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??"ipfs"}/ping/1.0.0`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??1e4,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??!0,this.timeout=new wE({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[I]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval((()=>{this.components.connectionManager.getConnections().forEach((e=>{Promise.resolve().then((async()=>{let t=Date.now();try{const r=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),n=cu(await e.newStream(this.protocol,{signal:r,runOnLimitedConnection:!0}));t=Date.now(),await Promise.all([n.write(fl(32),{signal:r}),n.read(32,{signal:r})]),e.rtt=Date.now()-t,await n.unwrap().close({signal:r})}catch(r){if("UnsupportedProtocolError"!==r.name)throw r;e.rtt=(Date.now()-t)/2}})).catch((t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")}))}))}),this.pingIntervalMs)}stop(){this.abortController?.abort(),null!=this.heartbeatInterval&&clearInterval(this.heartbeatInterval)}}class vE{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(0===this.routers.length)throw new TS("No content routers available");const r=this,n=new Qh;for await(const s of Ac(...r.routers.map((r=>r.findProviders(e,t)))))null!=s&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs}),n.has(s.id)||(n.add(s.id),yield s))}async provide(e,t={}){if(0===this.routers.length)throw new TS("No content routers available");await Promise.all(this.routers.map((async r=>{await r.provide(e,t)})))}async cancelReprovide(e,t={}){if(0===this.routers.length)throw new TS("No content routers available");await Promise.all(this.routers.map((async r=>{await r.cancelReprovide(e,t)})))}async put(e,t,r){if(!this.isStarted())throw new K;await Promise.all(this.routers.map((async n=>{await n.put(e,t,r)})))}async get(e,t){if(!this.isStarted())throw new K;return Promise.any(this.routers.map((async r=>r.get(e,t))))}}const SE=globalThis.CustomEvent??Event;class EE{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[]}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(0===this.routers.length)throw new MS("No peer routers available");if(e.toString()===this.peerId.toString())throw new PS("Should not try to find self");const r=this,n=Ac(...this.routers.map((n=>async function*(){try{yield await n.findPeer(e,t)}catch(e){r.log.error(e)}}())));for await(const e of n)if(null!=e)return e.multiaddrs.length>0&&await this.peerStore.merge(e.id,{multiaddrs:e.multiaddrs}),e;throw new F}async*getClosestPeers(e,t={}){if(0===this.routers.length)throw new MS("No peer routers available");const r=this,n=ld(1024);for await(const s of async function*(e,t={}){let r=t.concurrency??1/0;r<1&&(r=1/0);const n=null!=t.ordered&&t.ordered,s=new EventTarget,i=[];let o,a=bc(),c=bc(),l=!1,u=!1;function h(){return n?i[0]?.done:Boolean(i.find((e=>e.done)))}function*d(){for(;i.length>0&&i[0].done;){const e=i[0];if(i.shift(),!e.ok)throw u=!0,a.resolve(),e.err;yield e.value,a.resolve()}}function*p(){for(;h();)for(let e=0;e<i.length;e++)if(i[e].done){const t=i[e];if(i.splice(e,1),e--,!t.ok)throw u=!0,a.resolve(),t.err;yield t.value,a.resolve()}}for(s.addEventListener("task-complete",(()=>{c.resolve()})),Promise.resolve().then((async()=>{try{for await(const t of e){if(i.length===r&&(a=bc(),await a.promise),u)break;const e={done:!1};i.push(e),t().then((t=>{e.done=!0,e.ok=!0,e.value=t,s.dispatchEvent(new SE("task-complete"))}),(t=>{e.done=!0,e.err=t,s.dispatchEvent(new SE("task-complete"))}))}l=!0,s.dispatchEvent(new SE("task-complete"))}catch(e){o=e,s.dispatchEvent(new SE("task-complete"))}}));;){if(h()||(c=bc(),await c.promise),null!=o)throw o;if(n?yield*d():yield*p(),l&&0===i.length)break}}(async function*(){const n=Ac(...r.routers.map((r=>r.getClosestPeers(e,t))));for await(let e of n)yield async()=>{if(0===e.multiaddrs.length)try{e=await r.findPeer(e.id,{...t,useCache:!1})}catch(e){return void r.log.error("could not find peer multiaddrs",e)}return e}}()))null!=s&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs}),n.has(s.id.toMultihash().bytes)||(n.add(s.id.toMultihash().bytes),yield s))}}class kE extends b{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Ad([this.shutdownController.signal,e?.signal]);try{for(;;){this.needNext?.resolve(),this.needNext=bc();const e=await yd(this,"walk:peer",t,{errorEvent:"walk:error"});yield e.detail}}finally{t.clear(),this.walkers--,0===this.walkers&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Ad([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let r=0;Promise.resolve().then((async()=>{for(this.log("start walk");this.walkers>0;)try{const t=fl(32);let n=Date.now();for await(const s of this.peerRouting.getClosestPeers(t,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",s.id,Date.now()-n,this.walkers),r++,this.safeDispatchEvent("walk:peer",{detail:s}),1===this.walkers&&null!=this.needNext&&(this.log("wait for need next"),await nu(this.needNext.promise,e)),n=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",t,this.walkers,r)}catch(e){this.log.error("randomwalk errored",e),this.safeDispatchEvent("walk:error",{detail:e})}this.log("no walkers left, ended walk")})).catch((e=>{this.log.error("randomwalk errored",e)})).finally((()=>{this.log("finished walk, found %d peers after %dms",r,Date.now()-t),this.walking=!1}))}}class AE{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(null==t)throw new DS(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return null==t?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e))throw new NS(`Handler already registered for protocol ${e}`);const n=Ev.bind({ignoreUndefined:!0})({maxInboundStreams:32,maxOutboundStreams:64},r);this.handlers.set(e,{handler:t,options:n}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach((e=>{this.handlers.delete(e)})),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(null==t)throw new M("invalid topology");const r=`${(1e9*Math.random()).toString(36)}${Date.now()}`;let n=this.topologies.get(e);return null==n&&(n=new Map,this.topologies.set(e,n)),n.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),0===r.size&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then((e=>{for(const r of e.protocols){const e=this.topologies.get(r);if(null!=e)for(const r of e.values())!1!==r.filter?.has(t)&&(r.filter?.remove(t),r.onDisconnect?.(t))}})).catch((e=>{"NotFoundError"!==e.name&&this.log.error("could not inform topologies of disconnecting peer %p",t,e)}))}_onPeerUpdate(e){const{peer:t,previous:r}=e.detail,n=(r?.protocols??[]).filter((e=>!t.protocols.includes(e)));for(const e of n){const r=this.topologies.get(e);if(null!=r)for(const e of r.values())!1!==e.filter?.has(t.id)&&(e.filter?.remove(t.id),e.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,r=e.detail.connection,n=e.detail.peerId;for(const e of t){const t=this.topologies.get(e);if(null!=t)for(const e of t.values())null!=r.limits&&!0!==e.notifyOnLimitedConnection||!0!==e.filter?.has(n)&&(e.filter?.add(n),e.onConnect?.(n,r))}}}class IE extends Map{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}class _E{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=function(e){const{name:t,metrics:r}=e;let n;return n=null!=r?new IE({name:t,metrics:r}):new Map,n}({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Jf.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(null==t)throw new M("Transport must have a valid tag");if(this.transports.has(t))throw new M(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const t=r.pop();null!=t&&e.push(t.close())}await Promise.all(e),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(e,t){const r=this.dialTransportForMultiaddr(e);if(null==r)throw new VS(`No transport available for address ${String(e)}`);return t?.onProgress?.(new ng("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new K("Not started");if(null==e||0===e.length)return void this.log("no addresses were provided for listening, this node is dial only");const t=[];for(const[r,n]of this.transports.entries()){const s=n.listenFilter(e),i=[];for(const e of s){this.log("creating listener for %s on %a",r,e);const t=n.createListener({upgrader:this.components.upgrader});let s=this.listeners.get(r)??[];null==s&&(s=[],this.listeners.set(r,s)),s.push(t),t.addEventListener("listening",(()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:t})})),t.addEventListener("close",(()=>{const e=s.findIndex((e=>e===t));s.splice(e,1),this.components.events.safeDispatchEvent("transport:close",{detail:t})})),i.push(t.listen(e))}if(0!==i.length){if(null==(await Promise.allSettled(i)).find((e=>"fulfilled"===e.status))&&this.faultTolerance!==Jf.NO_FATAL)throw new BS(`Transport (${r}) could not listen on any available address`)}else t.push(r)}if(t.length===this.transports.size){const e=`no valid addresses were provided for transports [${t.join(", ")}]`;if(this.faultTolerance===Jf.FATAL_ALL)throw new BS(e);this.log(`libp2p in dial mode only: ${e}`)}}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const e=t.pop();null!=e&&r.push(e.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const CE="/multistream/1.0.0",xE=1024,TE=ds("\n");async function ME(e,t,r){await e.write(t,r)}async function PE(e,t){const r=await async function(e,t){const r=await e.read(t);if(0===r.byteLength||r.get(r.byteLength-1)!==TE[0])throw t.log.error("Invalid mss message - missing newline",r),new j("Missing newline");return r.sublist(0,-1)}(e,t);return ia(r.subarray())}async function DE(e,t,r){t=Array.isArray(t)?t:[t],r.log.trace("handle: available protocols %s",t);const n=du(e,{...r,maxDataLength:xE,maxLengthLength:2});for(;;){r.log.trace("handle: reading incoming string");const e=await PE(n,r);if(r.log.trace('handle: read "%s"',e),e!==CE){if(t.includes(e))return r.log.trace('handle: respond with "%s" for "%s"',e,e),await ME(n,ds(`${e}\n`),r),r.log.trace('handle: responded with "%s" for "%s"',e,e),{stream:n.unwrap(),protocol:e};if("ls"!==e)r.log.trace('handle: respond with "na" for "%s"',e),await ME(n,ds("na\n"),r),r.log('handle: responded with "na" for "%s"',e);else{const s=new cc(...t.map((e=>hc.single(ds(`${e}\n`)))),ds("\n"));r.log.trace('handle: respond with "%s" for %s',t,e),await ME(n,s,r),r.log.trace('handle: responded with "%s" for %s',t,e)}}else r.log.trace('handle: respond with "%s" for "%s"',CE,e),await ME(n,ds(`${CE}\n`),r),r.log.trace('handle: responded with "%s" for "%s"',CE,e)}}async function NE(e,t,r){if(1===(t=Array.isArray(t)?[...t]:[t]).length&&!1===r.negotiateFully)return function(e,t,r){const n=e.sink.bind(e),s=e.source;let i=!1,o=!1;const a=bc();let c=!1,l=!1;const u=bc();let h=!1,d=!1;const p=bc(),f=du({sink:n,source:s},{...r,maxDataLength:xE});async function g(){if(o)return r.log.trace("optimistic: already negotiating %s stream",t),void await a.promise;o=!0;try{c||(r.log.trace("optimistic: doing send protocol for %s stream",t),await async function(){if(l)await u.promise;else{l=!0;try{r.log.trace('optimistic: write ["%s", "%s", data] in source',CE,t),await f.writeV([ds(`${CE}\n`),ds(`${t}\n`)]),r.log.trace('optimistic: wrote ["%s", "%s", data] in source',CE,t)}finally{c=!0,l=!1,u.resolve()}}}()),h||(r.log.trace("optimistic: doing read protocol for %s stream",t),await async function(){if(d)await p.promise;else{d=!0;try{r.log.trace("optimistic: reading multistream select header");let e=await PE(f,r);if(r.log.trace('optimistic: read multistream select header "%s"',e),e===CE&&(e=await PE(f,r)),r.log.trace('optimistic: read protocol "%s", expecting "%s"',e,t),e!==t)throw new q("protocol selection failed")}finally{h=!0,d=!1,p.resolve()}}}())}finally{o=!1,i=!0,a.resolve()}}if(e.sink=async e=>{const{sink:n}=f.unwrap();await n(async function*(){let n=!1;for await(const s of e){if(l&&await u.promise,c)yield s;else{l=!0,r.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',CE,t,s.byteLength);const e=`${t}\n`;yield new cc(Uint8Array.from([19]),ds(`${CE}\n`),fn(e.length),ds(e),s).subarray(),r.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',CE,t,s.byteLength),c=!0,l=!1,u.resolve(),g().catch((e=>{r.log.error("could not finish optimistic protocol negotiation of %s",t,e)}))}n=!0}n||await g()}())},e.source=async function*(){await g(),r.log.trace('optimistic: reading data from "%s" stream',t),yield*f.unwrap().source}(),null!=e.closeRead){const t=e.closeRead.bind(e);e.closeRead=async e=>{i||await g().catch((e=>{r.log.error("could not negotiate protocol before close read",e)})),await t(e)}}if(null!=e.closeWrite){const t=e.closeWrite.bind(e);e.closeWrite=async e=>{i||await g().catch((e=>{r.log.error("could not negotiate protocol before close write",e)})),await t(e)}}if(null!=e.close){const t=e.close.bind(e);e.close=async e=>{const r=[];l&&r.push(u.promise),d&&r.push(p.promise),r.length>0?await nu(Promise.all(r),e?.signal):(i=!0,o=!1,a.resolve()),await t(e)}}return{stream:e,protocol:t}}(e,t[0],r);const n=du(e,{...r,maxDataLength:xE}),s=t.shift();if(null==s)throw new Error("At least one protocol must be specified");r.log.trace('select: write ["%s", "%s"]',CE,s);const i=ds(`${CE}\n`),o=ds(`${s}\n`);await async function(e,t,r){await e.writeV(t,r)}(n,[i,o],r),r.log.trace("select: reading multistream-select header");let a=await PE(n,r);if(r.log.trace('select: read "%s"',a),a===CE&&(r.log.trace("select: reading protocol response"),a=await PE(n,r),r.log.trace('select: read "%s"',a)),a===s)return{stream:n.unwrap(),protocol:s};for(const e of t){r.log.trace('select: write "%s"',e),await ME(n,ds(`${e}\n`),r),r.log.trace("select: reading protocol response");const t=await PE(n,r);if(r.log.trace('select: read "%s" for "%s"',t,e),t===e)return{stream:n.unwrap(),protocol:e}}throw new q("protocol selection failed")}const RE=Symbol.for("@libp2p/connection");class BE{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:r,newStream:n,close:s,abort:i,getStreams:o}=e;this.id=`${parseInt(String(1e9*Math.random())).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),null==this.remoteAddr.getPeerId()&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=n,this._close=s,this._abort=i,this._getStreams=o,this.tags=[]}[Symbol.toStringTag]="Connection";[RE]=!0;get streams(){return this._getStreams()}async newStream(e,t){if("closing"===this.status)throw new N("the connection is being closed");if("closed"===this.status)throw new R("the connection is closed");if(Array.isArray(e)||(e=[e]),null!=this.limits&&!0!==t?.runOnLimitedConnection)throw new J("Cannot open protocol stream on limited connection");const r=await this._newStream(e,t);return r.direction="outbound",r}async close(e={}){if("closed"!==this.status&&"closing"!==this.status){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",null==e.signal){const t=AbortSignal.timeout(500);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(e){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,e),this.abort(e)}}}abort(e){"closed"!==this.status&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function LE(e,t,r){let n=0;return r.streams.forEach((r=>{r.direction===t&&r.protocol===e&&n++})),n}class OE{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;outboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach((e=>{this.connectionEncrypters.set(e.protocol,e)})),this.streamMuxers=new Map,t.streamMuxers.forEach((e=>{this.streamMuxers.set(e.protocol,e)})),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??3e3,this.outboundUpgradeTimeout=t.outboundUpgradeTimeout??3e3,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??2e3,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??2e3,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const r=this.components.connectionGater[e];if(null!=r&&!0===await r.apply(this.components.connectionGater,t))throw new LS(`The multiaddr connection is blocked by gater.${e}`)}async upgradeInbound(e,t={}){let r=!1;try{if(this.metrics.dials?.increment({inbound:!0}),r=await this.components.connectionManager.acceptIncomingConnection(e),!r)throw new OS("Connection denied");await this.shouldBlockConnection("denyInboundConnection",e),await this._performUpgrade(e,"inbound",t)}catch(e){throw this.metrics.errors?.increment({inbound:!0}),e}finally{r&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t={}){try{this.metrics.dials?.increment({outbound:!0});const r=e.remoteAddr.getPeerId();let n;return null!=r&&(n=ec(r),await this.shouldBlockConnection("denyOutboundConnection",n,e)),await this._performUpgrade(e,"outbound",t)}catch(e){throw this.metrics.errors?.increment({outbound:!0}),e}}async _performUpgrade(e,t,r){let n,s,i,o,a;const c=Ad([AbortSignal.timeout("inbound"===t?this.inboundUpgradeTimeout:this.outboundUpgradeTimeout),r.signal]);r.signal=c,this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(!0!==r?.skipProtection){const n=this.components.connectionProtector;null!=n&&(e.log("protecting the %s connection",t),l=await n.protect(e,r))}try{if(n=l,!0!==r?.skipEncryption){r?.onProgress?.(new ng(`upgrader:encrypt-${t}-connection`)),({conn:n,remotePeer:s,protocol:a}=await("inbound"===t?this._encryptInbound(l,{...r,signal:c}):this._encryptOutbound(l,{...r,signal:c})));const e={...l,...n};await this.shouldBlockConnection("inbound"===t?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",s,e)}else{const r=e.remoteAddr.getPeerId();if(null==r)throw new $(`${t} connection that skipped encryption must have a peer id`);const n=ec(r);a="native",s=n}if(s.equals(this.components.peerId)){const t=new V("Can not dial self");throw e.abort(t),t}if(i=n,null!=r?.muxerFactory)o=r.muxerFactory;else if(this.streamMuxers.size>0){r?.onProgress?.(new ng(`upgrader:multiplex-${t}-connection`));const e=await("inbound"===t?this._multiplexInbound({...l,...n},this.streamMuxers,r):this._multiplexOutbound({...l,...n},this.streamMuxers,r));o=e.muxerFactory,i=e.stream}}catch(r){throw e.log.error("failed to upgrade inbound connection %s %a - %e","inbound"===t?"from":"to",e.remoteAddr,r),r}finally{c.clear()}return await this.shouldBlockConnection("inbound"===t?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",s,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:a,direction:t,maConn:e,upgradedConn:i,muxerFactory:o,remotePeer:s,limits:r?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:n,upgradedConn:s,remotePeer:i,muxerFactory:o,limits:a}=e;let c,l,u;null!=o&&(c=o.createStreamMuxer({direction:r,onIncomingStream:e=>{null!=u&&Promise.resolve().then((async()=>{const t=this.components.registrar.getProtocols(),r=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:n,protocol:s}=await DE(e,t,{signal:r,log:e.log,yieldBytes:!1});if(null==u)return;u.log("incoming stream opened on %s",s);const o=function(e,t){try{const{options:r}=t.getHandler(e);return r.maxInboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return 32}(s,this.components.registrar);if(LE(s,"inbound",u)===o){const t=new Q(`Too many inbound protocol streams for protocol "${s}" - limit ${o}`);throw e.abort(t),t}e.source=n.source,e.sink=n.sink,e.protocol=s,null!=n.closeWrite&&(e.closeWrite=n.closeWrite),null!=n.closeRead&&(e.closeRead=n.closeRead),null!=n.close&&(e.close=n.close),await this.components.peerStore.merge(i,{protocols:[s]}),this.components.metrics?.trackProtocolStream(e,u),this._onStream({connection:u,stream:e,protocol:s})})).catch((async t=>{u.log.error("error handling incoming stream id %s - %e",e.id,t),null==e.timeline.close&&await e.close()}))}}),l=async(t,n={})=>{if(null==c)throw new US("Connection is not multiplexed");u.log.trace("starting new stream for protocols %s",t);const s=await c.newStream();u.log.trace("started new stream %s for protocols %s",s.id,t);try{if(null==n.signal){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const e=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:e}}s.log.trace("selecting protocol from protocols %s",t);const{stream:e,protocol:r}=await NE(s,t,{...n,log:s.log,yieldBytes:!0});s.log.trace("selected protocol %s",r);const o=function(e,t,r={}){try{const{options:r}=t.getHandler(e);if(null!=r.maxOutboundStreams)return r.maxOutboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return r.maxOutboundStreams??64}(r,this.components.registrar,n),a=LE(r,"outbound",u);if(a>=o){const e=new Z(`Too many outbound protocol streams for protocol "${r}" - ${a}/${o}`);throw s.abort(e),e}return await this.components.peerStore.merge(i,{protocols:[r]}),s.source=e.source,s.sink=e.sink,s.protocol=r,null!=e.closeWrite&&(s.closeWrite=e.closeWrite),null!=e.closeRead&&(s.closeRead=e.closeRead),null!=e.close&&(s.close=e.close),this.components.metrics?.trackProtocolStream(s,u),s}catch(n){throw u.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e","inbound"===r?"from":"to",e.maConn.remoteAddr,t,n),null==s.timeline.close&&s.abort(n),n}},Promise.all([c.sink(s.source),s.sink(c.source)]).catch((e=>{u.log.error("error piping data through muxer - %e",e)})));const h=n.timeline;var d;return n.timeline=new Proxy(h,{set:(...e)=>("close"===e[1]&&null!=e[2]&&null==h.close&&(async()=>{try{"open"===u.status&&await u.close()}catch(e){u.log.error("error closing connection after timeline close %e",e)}finally{this.events.safeDispatchEvent("connection:close",{detail:u})}})().catch((e=>{u.log.error("error thrown while dispatching connection:close event %e",e)})),Reflect.set(...e))}),n.timeline.upgraded=Date.now(),d={remoteAddr:n.remoteAddr,remotePeer:i,status:"open",direction:r,timeline:n.timeline,multiplexer:c?.protocol,encryption:t,limits:a,logger:this.components.logger,newStream:l??(()=>{throw new US("Connection is not multiplexed")}),getStreams:()=>c?.streams??[],close:async e=>{await(c?.close(e)),await n.close(e)},abort:e=>{n.abort(e),c?.abort(e)}},u=new BE(d),this.events.safeDispatchEvent("connection:open",{detail:u}),u.__maConnTimeline=h,u}_onStream(e){const{connection:t,stream:r,protocol:n}=e,{handler:s,options:i}=this.components.registrar.getHandler(n);if(null!=t.limits&&!0!==i.runOnLimitedConnection)throw new J("Cannot open protocol stream on limited connection");s({connection:t,stream:r})}async _encryptInbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{const{stream:n,protocol:s}=await DE(e,r,{...t,log:e.log}),i=this.connectionEncrypters.get(s);if(null==i)throw new FS(`no crypto module found for ${s}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,s),{...await i.secureInbound(n,t),protocol:s}}catch(t){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,t),new FS(t.message)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",r);const{stream:n,protocol:s}=await NE(e,r,{...t,log:e.log,yieldBytes:!0}),i=this.connectionEncrypters.get(s);if(null==i)throw new FS(`no crypto module found for ${s}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,s),{...await i.secureOutbound(n,t),protocol:s}}catch(t){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,t),new FS(t.message)}}async _multiplexOutbound(e,t,r){const n=Array.from(t.keys());e.log("outbound selecting muxer %s",n);try{e.log.trace("selecting stream muxer from %s",n);const{stream:s,protocol:i}=await NE(e,n,{...r,log:e.log,yieldBytes:!0});return e.log("selected %s as muxer protocol",i),{stream:s,muxerFactory:t.get(i)}}catch(t){throw e.log.error("error multiplexing outbound connection",t),new US(String(t))}}async _multiplexInbound(e,t,r){const n=Array.from(t.keys());e.log("inbound handling muxers %s",n);try{const{stream:s,protocol:i}=await DE(e,n,{...r,log:e.log});return{stream:s,muxerFactory:t.get(i)}}catch(t){throw e.log.error("error multiplexing inbound connection",t),new US(String(t))}}}class UE extends b{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new b,r=t.dispatchEvent.bind(t);t.dispatchEvent=e=>{const t=r(e),n=this.dispatchEvent(new CustomEvent(e.type,{detail:e.detail}));return t||n},this.peerId=e.peerId,this.logger=e.logger??Mg(),this.log=this.logger.forComponent("libp2p"),this.services={};const n=this.components=function(e={}){const t=new $S(e);return new Proxy(t,{get(e,r,n){if("string"==typeof r&&!zS.includes(r)){const e=t.components[r];if(null==e&&!HS.includes(r))throw new CS(`${r} not set`);return e}return Reflect.get(e,r,n)},set:(e,r,n)=>("string"==typeof r?t.components[r]=n:Reflect.set(e,r,n),!0)})}({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:e.nodeInfo??{name:"js-libp2p",version:"2.4.2"},logger:this.logger,events:t,datastore:e.datastore??new gS,connectionGater:KS(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",function(e,t={}){return new cS(e,t)}(n,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),null!=e.metrics&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),n.events.addEventListener("peer:update",(e=>{if(null==e.detail.previous){const t={id:e.detail.peer.id,multiaddrs:e.detail.peer.addresses.map((e=>e.multiaddr))};n.events.safeDispatchEvent("peer:discovery",{detail:t})}})),null!=e.connectionProtector&&this.configureComponent("connectionProtector",e.connectionProtector(n)),this.components.upgrader=new OE(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map(((e,t)=>this.configureComponent(`connection-encryption-${t}`,e(this.components)))),streamMuxers:(e.streamMuxers??[]).map(((e,t)=>this.configureComponent(`stream-muxers-${t}`,e(this.components)))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,outboundUpgradeTimeout:e.connectionManager?.outboundUpgradeTimeout}),this.configureComponent("transportManager",new _E(this.components,e.transportManager)),this.configureComponent("connectionManager",new mE(this.components,e.connectionManager)),!1!==e.connectionMonitor?.enabled&&this.configureComponent("connectionMonitor",new bE(this.components,e.connectionMonitor)),this.configureComponent("registrar",new AE(this.components)),this.configureComponent("addressManager",new IS(this.components,e.addresses));const s=(e.peerRouters??[]).map(((e,t)=>this.configureComponent(`peer-router-${t}`,e(this.components))));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new EE(this.components,{routers:s}));const i=(e.contentRouters??[]).map(((e,t)=>this.configureComponent(`content-router-${t}`,e(this.components))));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new vE(this.components,{routers:i})),this.configureComponent("randomWalk",new kE(this.components)),(e.peerDiscovery??[]).forEach(((e,t)=>{this.configureComponent(`peer-discovery-${t}`,e(this.components)).addEventListener("peer",(e=>{this.#O(e)}))})),e.transports?.forEach(((e,t)=>{this.components.transportManager.add(this.configureComponent(`transport-${t}`,e(this.components)))})),null!=e.services)for(const t of Object.keys(e.services)){const r=(0,e.services[t])(this.components);null!=r?(this.services[t]=r,this.configureComponent(t,r),null!=r[Iv]&&(this.log("registering service %s for content routing",t),i.push(r[Iv])),null!=r[_v]&&(this.log("registering service %s for peer routing",t),s.push(r[_v])),null!=r[zd]&&(this.log("registering service %s for peer discovery",t),r[zd].addEventListener?.("peer",(e=>{this.#O(e)})))):this.log.error("service factory %s returned null or undefined instance",t)}!function(e){const t={};for(const r of Object.values(e.components))for(const e of qS(r))t[e]=!0;for(const r of Object.values(e.components))for(const e of jS(r))if(!0!==t[e])throw new xS(`Service "${WS(r)}" required capability "${e}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}(n)}configureComponent(e,t){return null==t&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if("stopped"===this.status){this.status="starting",this.log("libp2p is starting");try{await(this.components.beforeStart?.()),await this.components.start(),await(this.components.afterStart?.()),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){"started"===this.status&&(this.log("libp2p is stopping"),this.status="stopping",await(this.components.beforeStop?.()),await this.components.stop(),await(this.components.afterStop?.()),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Qh;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,r={}){if(null==t)throw new M("no protocols were provided to open a stream");if(0===(t=Array.isArray(t)?t:[t]).length)throw new M("no protocols were provided to open a stream");return(await this.dial(e,r)).newStream(t,r)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){Od(e)&&(e=ec(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),null!=e.publicKey)return e.publicKey;try{const t=await this.peerStore.get(e);if(null!=t.id.publicKey)return t.id.publicKey}catch(e){if("NotFoundError"!==e.name)throw e}const r=sc([ds("/pk/"),e.toMultihash().bytes]),n=qa(await this.contentRouting.get(r,t));return await this.peerStore.patch(e,{publicKey:n}),n}async handle(e,t,r){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.registrar.handle(e,t,r)})))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.registrar.unhandle(e)})))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#O(e){const{detail:t}=e;t.id.toString()!==this.peerId.toString()?this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch((e=>{this.log.error(e)})):this.log.error("peer discovery mechanism discovered self")}}var FE,VE=r(9307);function $E(e){switch(e){case 0:case"NULL_VALUE":return FE.NULL_VALUE;default:return FE.UNRECOGNIZED}}!function(e){e[e.NULL_VALUE=0]="NULL_VALUE",e[e.UNRECOGNIZED=-1]="UNRECOGNIZED"}(FE||(FE={}));const HE={encode:(e,t=new VE.fI)=>(Object.entries(e.fields).forEach((([e,r])=>{void 0!==r&&zE.encode({key:e,value:r},t.uint32(10).fork()).join()})),t),decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={fields:{}};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:{if(10!==e)break;const t=zE.decode(r,r.uint32());void 0!==t.value&&(s.fields[t.key]=t.value);continue}}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({fields:WE(e.fields)?Object.entries(e.fields).reduce(((e,[t,r])=>(e[t]=r,e)),{}):{}}),toJSON(e){const t={};if(e.fields){const r=Object.entries(e.fields);r.length>0&&(t.fields={},r.forEach((([e,r])=>{t.fields[e]=r})))}return t},create:e=>HE.fromPartial(e??{}),fromPartial(e){const t={fields:{}};return t.fields=Object.entries(e.fields??{}).reduce(((e,[t,r])=>(void 0!==r&&(e[t]=r),e)),{}),t},wrap(e){const t={fields:{}};if(void 0!==e)for(const r of Object.keys(e))t.fields[r]=e[r];return t},unwrap(e){const t={};if(e.fields)for(const r of Object.keys(e.fields))t[r]=e.fields[r];return t}},zE={encode:(e,t=new VE.fI)=>(""!==e.key&&t.uint32(10).string(e.key),void 0!==e.value&&qE.encode(qE.wrap(e.value),t.uint32(18).fork()).join(),t),decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={key:"",value:void 0};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.key=r.string();continue;case 2:if(18!==e)break;s.value=qE.unwrap(qE.decode(r,r.uint32()));continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({key:KE(e.key)?globalThis.String(e.key):"",value:KE(e?.value)?e.value:void 0}),toJSON(e){const t={};return""!==e.key&&(t.key=e.key),void 0!==e.value&&(t.value=e.value),t},create:e=>zE.fromPartial(e??{}),fromPartial(e){const t={key:"",value:void 0};return t.key=e.key??"",t.value=e.value??void 0,t}},qE={encode:(e,t=new VE.fI)=>(void 0!==e.nullValue&&t.uint32(8).int32(e.nullValue),void 0!==e.numberValue&&t.uint32(17).double(e.numberValue),void 0!==e.stringValue&&t.uint32(26).string(e.stringValue),void 0!==e.boolValue&&t.uint32(32).bool(e.boolValue),void 0!==e.structValue&&HE.encode(HE.wrap(e.structValue),t.uint32(42).fork()).join(),void 0!==e.listValue&&jE.encode(jE.wrap(e.listValue),t.uint32(50).fork()).join(),t),decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={nullValue:void 0,numberValue:void 0,stringValue:void 0,boolValue:void 0,structValue:void 0,listValue:void 0};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(8!==e)break;s.nullValue=r.int32();continue;case 2:if(17!==e)break;s.numberValue=r.double();continue;case 3:if(26!==e)break;s.stringValue=r.string();continue;case 4:if(32!==e)break;s.boolValue=r.bool();continue;case 5:if(42!==e)break;s.structValue=HE.unwrap(HE.decode(r,r.uint32()));continue;case 6:if(50!==e)break;s.listValue=jE.unwrap(jE.decode(r,r.uint32()));continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({nullValue:KE(e.nullValue)?$E(e.nullValue):void 0,numberValue:KE(e.numberValue)?globalThis.Number(e.numberValue):void 0,stringValue:KE(e.stringValue)?globalThis.String(e.stringValue):void 0,boolValue:KE(e.boolValue)?globalThis.Boolean(e.boolValue):void 0,structValue:WE(e.structValue)?e.structValue:void 0,listValue:globalThis.Array.isArray(e.listValue)?[...e.listValue]:void 0}),toJSON(e){const t={};return void 0!==e.nullValue&&(t.nullValue=function(e){switch(e){case FE.NULL_VALUE:return"NULL_VALUE";case FE.UNRECOGNIZED:default:return"UNRECOGNIZED"}}(e.nullValue)),void 0!==e.numberValue&&(t.numberValue=e.numberValue),void 0!==e.stringValue&&(t.stringValue=e.stringValue),void 0!==e.boolValue&&(t.boolValue=e.boolValue),void 0!==e.structValue&&(t.structValue=e.structValue),void 0!==e.listValue&&(t.listValue=e.listValue),t},create:e=>qE.fromPartial(e??{}),fromPartial(e){const t={nullValue:void 0,numberValue:void 0,stringValue:void 0,boolValue:void 0,structValue:void 0,listValue:void 0};return t.nullValue=e.nullValue??void 0,t.numberValue=e.numberValue??void 0,t.stringValue=e.stringValue??void 0,t.boolValue=e.boolValue??void 0,t.structValue=e.structValue??void 0,t.listValue=e.listValue??void 0,t},wrap(e){const t={nullValue:void 0,numberValue:void 0,stringValue:void 0,boolValue:void 0,structValue:void 0,listValue:void 0};if(null===e)t.nullValue=FE.NULL_VALUE;else if("boolean"==typeof e)t.boolValue=e;else if("number"==typeof e)t.numberValue=e;else if("string"==typeof e)t.stringValue=e;else if(globalThis.Array.isArray(e))t.listValue=e;else if("object"==typeof e)t.structValue=e;else if(void 0!==e)throw new globalThis.Error("Unsupported any value type: "+typeof e);return t},unwrap:e=>void 0!==e.stringValue?e.stringValue:void 0!==e?.numberValue?e.numberValue:void 0!==e?.boolValue?e.boolValue:void 0!==e?.structValue?e.structValue:void 0!==e?.listValue?e.listValue:void 0!==e?.nullValue?null:void 0},jE={encode(e,t=new VE.fI){for(const r of e.values)qE.encode(qE.wrap(r),t.uint32(10).fork()).join();return t},decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={values:[]};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.values.push(qE.unwrap(qE.decode(r,r.uint32())));continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({values:globalThis.Array.isArray(e?.values)?[...e.values]:[]}),toJSON(e){const t={};return e.values?.length&&(t.values=e.values),t},create:e=>jE.fromPartial(e??{}),fromPartial(e){const t={values:[]};return t.values=e.values?.map((e=>e))||[],t},wrap(e){const t={values:[]};return t.values=e??[],t},unwrap:e=>e?.hasOwnProperty("values")&&globalThis.Array.isArray(e.values)?e.values:e};function WE(e){return"object"==typeof e&&null!==e}function KE(e){return null!=e}const GE={encode(e,t=new VE.fI){""!==e.hash&&t.uint32(10).string(e.hash),""!==e.nodeId&&t.uint32(18).string(e.nodeId),void 0!==e.operation&&YE.encode(e.operation,t.uint32(26).fork()).join();for(const r of e.dependencies)t.uint32(34).string(r);return t},decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={hash:"",nodeId:"",operation:void 0,dependencies:[]};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.hash=r.string();continue;case 2:if(18!==e)break;s.nodeId=r.string();continue;case 3:if(26!==e)break;s.operation=YE.decode(r,r.uint32());continue;case 4:if(34!==e)break;s.dependencies.push(r.string());continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({hash:JE(e.hash)?globalThis.String(e.hash):"",nodeId:JE(e.nodeId)?globalThis.String(e.nodeId):"",operation:JE(e.operation)?YE.fromJSON(e.operation):void 0,dependencies:globalThis.Array.isArray(e?.dependencies)?e.dependencies.map((e=>globalThis.String(e))):[]}),toJSON(e){const t={};return""!==e.hash&&(t.hash=e.hash),""!==e.nodeId&&(t.nodeId=e.nodeId),void 0!==e.operation&&(t.operation=YE.toJSON(e.operation)),e.dependencies?.length&&(t.dependencies=e.dependencies),t},create:e=>GE.fromPartial(e??{}),fromPartial(e){const t={hash:"",nodeId:"",operation:void 0,dependencies:[]};return t.hash=e.hash??"",t.nodeId=e.nodeId??"",t.operation=void 0!==e.operation&&null!==e.operation?YE.fromPartial(e.operation):void 0,t.dependencies=e.dependencies?.map((e=>e))||[],t}},YE={encode:(e,t=new VE.fI)=>(""!==e.type&&t.uint32(10).string(e.type),void 0!==e.value&&qE.encode(qE.wrap(e.value),t.uint32(18).fork()).join(),t),decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={type:"",value:void 0};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.type=r.string();continue;case 2:if(18!==e)break;s.value=qE.unwrap(qE.decode(r,r.uint32()));continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({type:JE(e.type)?globalThis.String(e.type):"",value:JE(e?.value)?e.value:void 0}),toJSON(e){const t={};return""!==e.type&&(t.type=e.type),void 0!==e.value&&(t.value=e.value),t},create:e=>YE.fromPartial(e??{}),fromPartial(e){const t={type:"",value:void 0};return t.type=e.type??"",t.value=e.value??void 0,t}};function JE(e){return null!=e}var QE;function ZE(e){switch(e){case 0:case"MESSAGE_TYPE_UNSPECIFIED":return QE.MESSAGE_TYPE_UNSPECIFIED;case 1:case"MESSAGE_TYPE_UPDATE":return QE.MESSAGE_TYPE_UPDATE;case 2:case"MESSAGE_TYPE_SYNC":return QE.MESSAGE_TYPE_SYNC;case 3:case"MESSAGE_TYPE_SYNC_ACCEPT":return QE.MESSAGE_TYPE_SYNC_ACCEPT;case 4:case"MESSAGE_TYPE_SYNC_REJECT":return QE.MESSAGE_TYPE_SYNC_REJECT;case 5:case"MESSAGE_TYPE_CUSTOM":return QE.MESSAGE_TYPE_CUSTOM;default:return QE.UNRECOGNIZED}}function XE(){return{sender:"",type:0,data:new Uint8Array(0)}}!function(e){e[e.MESSAGE_TYPE_UNSPECIFIED=0]="MESSAGE_TYPE_UNSPECIFIED",e[e.MESSAGE_TYPE_UPDATE=1]="MESSAGE_TYPE_UPDATE",e[e.MESSAGE_TYPE_SYNC=2]="MESSAGE_TYPE_SYNC",e[e.MESSAGE_TYPE_SYNC_ACCEPT=3]="MESSAGE_TYPE_SYNC_ACCEPT",e[e.MESSAGE_TYPE_SYNC_REJECT=4]="MESSAGE_TYPE_SYNC_REJECT",e[e.MESSAGE_TYPE_CUSTOM=5]="MESSAGE_TYPE_CUSTOM",e[e.UNRECOGNIZED=-1]="UNRECOGNIZED"}(QE||(QE={}));const ek={encode:(e,t=new VE.fI)=>(""!==e.sender&&t.uint32(10).string(e.sender),0!==e.type&&t.uint32(16).int32(e.type),0!==e.data.length&&t.uint32(26).bytes(e.data),t),decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s=XE();for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.sender=r.string();continue;case 2:if(16!==e)break;s.type=r.int32();continue;case 3:if(26!==e)break;s.data=r.bytes();continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({sender:ik(e.sender)?globalThis.String(e.sender):"",type:ik(e.type)?ZE(e.type):0,data:ik(e.data)?sk(e.data):new Uint8Array(0)}),toJSON(e){const t={};return""!==e.sender&&(t.sender=e.sender),0!==e.type&&(t.type=function(e){switch(e){case QE.MESSAGE_TYPE_UNSPECIFIED:return"MESSAGE_TYPE_UNSPECIFIED";case QE.MESSAGE_TYPE_UPDATE:return"MESSAGE_TYPE_UPDATE";case QE.MESSAGE_TYPE_SYNC:return"MESSAGE_TYPE_SYNC";case QE.MESSAGE_TYPE_SYNC_ACCEPT:return"MESSAGE_TYPE_SYNC_ACCEPT";case QE.MESSAGE_TYPE_SYNC_REJECT:return"MESSAGE_TYPE_SYNC_REJECT";case QE.MESSAGE_TYPE_CUSTOM:return"MESSAGE_TYPE_CUSTOM";case QE.UNRECOGNIZED:default:return"UNRECOGNIZED"}}(e.type)),0!==e.data.length&&(t.data=function(e){if(globalThis.Buffer)return globalThis.Buffer.from(e).toString("base64");{const t=[];return e.forEach((e=>{t.push(globalThis.String.fromCharCode(e))})),globalThis.btoa(t.join(""))}}(e.data)),t},create:e=>ek.fromPartial(e??{}),fromPartial(e){const t=XE();return t.sender=e.sender??"",t.type=e.type??0,t.data=e.data??new Uint8Array(0),t}},tk={encode(e,t=new VE.fI){""!==e.objectId&&t.uint32(10).string(e.objectId);for(const r of e.vertices)GE.encode(r,t.uint32(18).fork()).join();return t},decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={objectId:"",vertices:[]};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.objectId=r.string();continue;case 2:if(18!==e)break;s.vertices.push(GE.decode(r,r.uint32()));continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({objectId:ik(e.objectId)?globalThis.String(e.objectId):"",vertices:globalThis.Array.isArray(e?.vertices)?e.vertices.map((e=>GE.fromJSON(e))):[]}),toJSON(e){const t={};return""!==e.objectId&&(t.objectId=e.objectId),e.vertices?.length&&(t.vertices=e.vertices.map((e=>GE.toJSON(e)))),t},create:e=>tk.fromPartial(e??{}),fromPartial(e){const t={objectId:"",vertices:[]};return t.objectId=e.objectId??"",t.vertices=e.vertices?.map((e=>GE.fromPartial(e)))||[],t}},rk={encode(e,t=new VE.fI){""!==e.objectId&&t.uint32(10).string(e.objectId);for(const r of e.vertexHashes)t.uint32(18).string(r);return t},decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={objectId:"",vertexHashes:[]};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.objectId=r.string();continue;case 2:if(18!==e)break;s.vertexHashes.push(r.string());continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({objectId:ik(e.objectId)?globalThis.String(e.objectId):"",vertexHashes:globalThis.Array.isArray(e?.vertexHashes)?e.vertexHashes.map((e=>globalThis.String(e))):[]}),toJSON(e){const t={};return""!==e.objectId&&(t.objectId=e.objectId),e.vertexHashes?.length&&(t.vertexHashes=e.vertexHashes),t},create:e=>rk.fromPartial(e??{}),fromPartial(e){const t={objectId:"",vertexHashes:[]};return t.objectId=e.objectId??"",t.vertexHashes=e.vertexHashes?.map((e=>e))||[],t}},nk={encode(e,t=new VE.fI){""!==e.objectId&&t.uint32(10).string(e.objectId);for(const r of e.requested)GE.encode(r,t.uint32(18).fork()).join();for(const r of e.requesting)t.uint32(26).string(r);return t},decode(e,t){const r=e instanceof VE.V5?e:new VE.V5(e);let n=void 0===t?r.len:r.pos+t;const s={objectId:"",requested:[],requesting:[]};for(;r.pos<n;){const e=r.uint32();switch(e>>>3){case 1:if(10!==e)break;s.objectId=r.string();continue;case 2:if(18!==e)break;s.requested.push(GE.decode(r,r.uint32()));continue;case 3:if(26!==e)break;s.requesting.push(r.string());continue}if(4==(7&e)||0===e)break;r.skip(7&e)}return s},fromJSON:e=>({objectId:ik(e.objectId)?globalThis.String(e.objectId):"",requested:globalThis.Array.isArray(e?.requested)?e.requested.map((e=>GE.fromJSON(e))):[],requesting:globalThis.Array.isArray(e?.requesting)?e.requesting.map((e=>globalThis.String(e))):[]}),toJSON(e){const t={};return""!==e.objectId&&(t.objectId=e.objectId),e.requested?.length&&(t.requested=e.requested.map((e=>GE.toJSON(e)))),e.requesting?.length&&(t.requesting=e.requesting),t},create:e=>nk.fromPartial(e??{}),fromPartial(e){const t={objectId:"",requested:[],requesting:[]};return t.objectId=e.objectId??"",t.requested=e.requested?.map((e=>GE.fromPartial(e)))||[],t.requesting=e.requesting?.map((e=>e))||[],t}};function sk(e){if(globalThis.Buffer)return Uint8Array.from(globalThis.Buffer.from(e,"base64"));{const t=globalThis.atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;++e)r[e]=t.charCodeAt(e);return r}}function ik(e){return null!=e}async function ok(e,t){await Ic(t,(e=>hc([e])),e.sink)}const ak="/drp/message/0.0.1";let ck;class lk{_config;_node;_pubsub;peerId="";constructor(e){this._config=e,ck=new w.V("drp::network",e?.log_config)}async start(){let e;if(this._config?.private_key_seed){const t=this._config.private_key_seed.padEnd(32,"0");e=await async function(e,t){return async function(e){const{privateKey:t,publicKey:r}=function(e){if(32!==e.length)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,r=Wr.getPublicKey(t);return{privateKey:Gr(t,r),publicKey:r}}(e);return new Jr(t,r)}(t)}(0,ds(t))}const t=this._config?.bootstrap_peers?this._config.bootstrap_peers:["/dns4/bootstrap1.topology.gg/tcp/443/wss/p2p/12D3KooWBu1pZ3v2u6tXSmkN35kiMLENpv3bEXcyT1GJTVhipAkG","/dns4/bootstrap2.topology.gg/tcp/443/wss/p2p/12D3KooWLGuTtCHLpd1SBHeyvzT3kHVe2dw8P7UdoXsfQHu8qvkf"],r=function(e={}){return t=>new Pw(t,e)}({interval:5e3,topics:["drp::discovery"]}),n=t.length?[r,(s={list:t},e=>new Ep(e,s))]:[r];var s;const i={autonat:Hd(),dcutr:wg(),identify:Tw(),pubsub:tu({allowPublishToZeroTopicPeers:!0})},o={...i,relay:Gf()};if(this._node=await async function(e={}){e.privateKey??=await za("Ed25519");const t=new UE({...await Av(e),peerId:(r=e.privateKey,tc(r.publicKey))});var r;return!1!==e.start&&await t.start(),t}({privateKey:e,addresses:{listen:this._config?.addresses?this._config.addresses:["/webrtc","/p2p-circuit"]},connectionEncrypters:[bh()],connectionGater:{denyDialMultiaddr:()=>!1},metrics:this._config?.browser_metrics?iw():void 0,peerDiscovery:n,services:this._config?.bootstrap?o:i,streamMuxers:[Gh()],transports:[ug({reservationConcurrency:1}),Lb(),Bb(),Xb({filter:Qb}),cv()]}),!this._config?.bootstrap)for(const e of this._config?.bootstrap_peers||[])try{await this._node.dial(Ud(e))}catch(e){ck.error("::start::dial::error",e)}this._pubsub=this._node.services.pubsub,this.peerId=this._node.peerId.toString(),ck.info("::start: Successfuly started DRP network w/ peer_id",this.peerId),this._node.addEventListener("peer:connect",(e=>ck.info("::start::peer::connect",e.detail))),this._node.addEventListener("peer:discovery",(async e=>{const t=e.detail.multiaddrs.sort(((e,t)=>{const r=/(^\/ip4\/127\.)|(^\/ip4\/10\.)|(^\/ip4\/172\.1[6-9]\.)|(^\/ip4\/172\.2[0-9]\.)|(^\/ip4\/172\.3[0-1]\.)|(^\/ip4\/192\.168\.)/,n=r.test(e.toString()),s=r.test(t.toString()),i=e.toString().includes("/webrtc/"),o=t.toString().includes("/webrtc/");return n&&!s?1:!n&&s||i&&!o?-1:!i&&o?1:0}));for(const r of t)try{await(this._node?.dial(r))}catch(e){ck.error("::start::peer::dial::error",e)}ck.info("::start::peer::discovery",e.detail)})),this._node.addEventListener("peer:identify",(e=>ck.info("::start::peer::identify",e.detail)))}subscribe(e){if(this._node)try{this._pubsub?.subscribe(e),this._pubsub?.getPeers(),ck.info("::subscribe: Successfuly subscribed the topic",e)}catch(e){ck.error("::subscribe:",e)}else ck.error("::subscribe: Node not initialized, please run .start()")}unsubscribe(e){if(this._node)try{this._pubsub?.unsubscribe(e),ck.info("::unsubscribe: Successfuly unsubscribed the topic",e)}catch(e){ck.error("::unsubscribe:",e)}else ck.error("::unsubscribe: Node not initialized, please run .start()")}getAllPeers(){const e=this._node?.getPeers();return e?e.map((e=>e.toString())):[]}getGroupPeers(e){const t=this._pubsub?.getSubscribers(e);return t?t.map((e=>e.toString())):[]}async broadcastMessage(e,t){try{const r=ek.encode(t).finish();await(this._pubsub?.publish(e,r)),ck.info("::broadcastMessage: Successfuly broadcasted message to topic",e)}catch(e){ck.error("::broadcastMessage:",e)}}async sendMessage(e,t){try{const r=await(this._node?.dial([Ud(`/p2p/${e}`)]));ok(await(r?.newStream(ak)),ek.encode(t).finish())}catch(e){ck.error("::sendMessage:",e)}}async sendGroupMessageRandomPeer(e,t){try{const r=this._pubsub?.getSubscribers(e);if(!r||0===r.length)throw Error("Topic wo/ peers");const n=r[Math.floor(Math.random()*r.length)],s=await(this._node?.dial(n));ok(await(s?.newStream(ak)),ek.encode(t).finish())}catch(e){ck.error("::sendMessageRandomTopicPeer:",e)}}addGroupMessageHandler(e,t){this._pubsub?.addEventListener("gossipsub:message",(r=>{e&&r.detail.msg.topic!==e||t(r)}))}addMessageHandler(e){this._node?.handle(ak,e)}addCustomMessageHandler(e,t){this._node?.handle(e,t)}}var uk,hk=r(8583);async function dk(e,t,r){let n;if(t){const e=await async function(e){return await Ic(e.source,(e=>wc(e)),(e=>function(e,t){let r=0;if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)yield t(n,r++)}();const n=Vh(e),{value:s,done:i}=n.next();if(!0===i)return function*(){}();const o=t(s,r++);if("function"==typeof o.then)return async function*(){yield await o;for await(const e of n)yield t(e,r++)}();const a=t;return function*(){yield o;for(const e of n)yield a(e,r++)}()}(e,(e=>e.subarray()))),(async e=>{const t=[];for await(const r of e)t.push(r);return t[0]}))}(t);n=ek.decode(e)}else{if(!r)return void mk.error("::messageHandler: Stream and data are undefined");n=ek.decode(r)}switch(n.type){case QE.MESSAGE_TYPE_UPDATE:!async function(e,t,r){const n=tk.decode(t),s=e.objectStore.get(n.objectId);if(!s)return mk.error("::updateHandler: Object not found"),!1;const[i,o]=s.merge(n.vertices.map((e=>({hash:e.hash,nodeId:e.nodeId,operation:{type:e.operation?.type??"",value:e.operation?.value},dependencies:e.dependencies}))));i||await e.syncObject(n.objectId,r),e.objectStore.put(s.id,s)}(e,n.data,n.sender);break;case QE.MESSAGE_TYPE_SYNC:if(!t)return void mk.error("::messageHandler: Stream is undefined");!function(e,t,r){const n=rk.decode(r),s=e.objectStore.get(n.objectId);if(!s)return void mk.error("::syncHandler: Object not found");const i=new Set(s.vertices),o=[];for(const e of n.vertexHashes){const t=s.vertices.find((t=>t.hash===e));t?i.delete(t):o.push(e)}if(0===i.size&&0===o.length)return;const a=ek.create({sender:e.networkNode.peerId,type:QE.MESSAGE_TYPE_SYNC_ACCEPT,data:nk.encode(nk.create({objectId:s.id,requested:[...i],requesting:o})).finish()});e.networkNode.sendMessage(t,a)}(e,n.sender,n.data);break;case QE.MESSAGE_TYPE_SYNC_ACCEPT:if(!t)return void mk.error("::messageHandler: Stream is undefined");!function(e,t,r){const n=nk.decode(r),s=e.objectStore.get(n.objectId);if(!s)return void mk.error("::syncAcceptHandler: Object not found");const i=n.requested.map((e=>({hash:e.hash,nodeId:e.nodeId,operation:{type:e.operation?.type??"",value:e.operation?.value},dependencies:e.dependencies})));0!==i.length&&(s.merge(i),e.objectStore.put(s.id,s));const o=[];for(const e of n.requesting){const t=s.vertices.find((t=>t.hash===e));t&&o.push(t)}if(0===o.length)return;const a=ek.create({sender:e.networkNode.peerId,type:QE.MESSAGE_TYPE_SYNC_ACCEPT,data:nk.encode(nk.create({objectId:s.id,requested:o,requesting:[]})).finish()});e.networkNode.sendMessage(t,a)}(e,n.sender,n.data);break;case QE.MESSAGE_TYPE_SYNC_REJECT:n.data;break;default:mk.error("::messageHandler: Invalid operation")}}async function pk(e,t){e.networkNode.subscribe(t),e.networkNode.addGroupMessageHandler(t,(async t=>dk(e,void 0,t.detail.msg.data)))}async function fk(e,t,r){const n=e.objectStore.get(t);if(!n)return void mk.error("::syncObject: Object not found");const s=rk.create({objectId:t,vertexHashes:n.vertices.map((e=>e.hash))}),i=ek.create({sender:e.networkNode.peerId,type:QE.MESSAGE_TYPE_SYNC,data:rk.encode(s).finish()});r?await e.networkNode.sendMessage(r,i):await e.networkNode.sendGroupMessageRandomPeer(t,i)}!function(e){e[e.CREATE=0]="CREATE",e[e.UPDATE=1]="UPDATE",e[e.SUBSCRIBE=2]="SUBSCRIBE",e[e.UNSUBSCRIBE=3]="UNSUBSCRIBE",e[e.SYNC=4]="SYNC"}(uk||(uk={}));class gk{_store;_subscriptions;constructor(){this._store=new Map,this._subscriptions=new Map}get(e){return this._store.get(e)}put(e,t){this._store.set(e,t),this._notifySubscribers(e,t)}subscribe(e,t){this._subscriptions.has(e)||this._subscriptions.set(e,[]),this._subscriptions.get(e)?.push(t)}_notifySubscribers(e,t){const r=this._subscriptions.get(e);if(r)for(const n of r)n(e,t)}remove(e){this._store.delete(e)}}let mk;class yk{config;objectStore;networkNode;constructor(e){this.config=e,mk=new w.V("drp::node",e?.log_config),this.networkNode=new lk(e?.network_config),this.objectStore=new gk}async start(){await this.networkNode.start(),this.networkNode.addMessageHandler((async({stream:e})=>dk(this,e)))}addCustomGroup(e){this.networkNode.subscribe(e)}addCustomGroupMessageHandler(e,t){this.networkNode.addGroupMessageHandler(e,t)}sendGroupMessage(e,t){const r=ek.create({sender:this.networkNode.peerId,type:QE.MESSAGE_TYPE_CUSTOM,data:t});this.networkNode.broadcastMessage(e,r)}addCustomMessageHandler(e,t){this.networkNode.addCustomMessageHandler(e,t)}sendCustomMessage(e,t,r){const n=ek.create({sender:this.networkNode.peerId,type:QE.MESSAGE_TYPE_CUSTOM,data:r});this.networkNode.sendMessage(e,n)}async createObject(e,t,r,n,s){const i=new hk.DRPObject(this.networkNode.peerId,e,t,r);return function(e,t){e.objectStore.put(t.id,t),t.subscribe(((t,r,n)=>function(e,t,r,n){switch(r){case"merge":e.objectStore.put(t.id,t);break;case"callFn":{e.objectStore.put(t.id,t);const r=ek.create({sender:e.networkNode.peerId,type:QE.MESSAGE_TYPE_UPDATE,data:tk.encode(tk.create({objectId:t.id,vertices:n})).finish()});e.networkNode.broadcastMessage(t.id,r);break}default:mk.error("::createObject: Invalid origin function")}}(e,t,r,n)))}(this,i),pk(this,i.id),n&&fk(this,i.id,s),i}async subscribeObject(e){return pk(this,e)}unsubscribeObject(e,t){!function(e,t,r){e.networkNode.unsubscribe(t),r&&e.objectStore.remove(t)}(this,e,t)}async syncObject(e,t){fk(this,e,t)}}}}]);